<?php
/**
 * UsersApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NetBox REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.1.1 (4.1)
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.8.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * UsersApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class UsersApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'usersConfigRetrieve' => [
            'application/json',
        ],
        'usersGroupsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersGroupsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersGroupsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersGroupsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersGroupsDestroy' => [
            'application/json',
        ],
        'usersGroupsList' => [
            'application/json',
        ],
        'usersGroupsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersGroupsRetrieve' => [
            'application/json',
        ],
        'usersGroupsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersPermissionsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersPermissionsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersPermissionsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersPermissionsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersPermissionsDestroy' => [
            'application/json',
        ],
        'usersPermissionsList' => [
            'application/json',
        ],
        'usersPermissionsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersPermissionsRetrieve' => [
            'application/json',
        ],
        'usersPermissionsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersTokensBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersTokensBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersTokensBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersTokensCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersTokensDestroy' => [
            'application/json',
        ],
        'usersTokensList' => [
            'application/json',
        ],
        'usersTokensPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersTokensProvisionCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersTokensRetrieve' => [
            'application/json',
        ],
        'usersTokensUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersUsersBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersUsersBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersUsersBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersUsersCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersUsersDestroy' => [
            'application/json',
        ],
        'usersUsersList' => [
            'application/json',
        ],
        'usersUsersPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'usersUsersRetrieve' => [
            'application/json',
        ],
        'usersUsersUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation usersConfigRetrieve
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersConfigRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>
     */
    public function usersConfigRetrieve(string $contentType = self::contentTypes['usersConfigRetrieve'][0])
    {
        list($response) = $this->usersConfigRetrieveWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation usersConfigRetrieveWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersConfigRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersConfigRetrieveWithHttpInfo(string $contentType = self::contentTypes['usersConfigRetrieve'][0])
    {
        $request = $this->usersConfigRetrieveRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersConfigRetrieveAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersConfigRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersConfigRetrieveAsync(string $contentType = self::contentTypes['usersConfigRetrieve'][0])
    {
        return $this->usersConfigRetrieveAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersConfigRetrieveAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersConfigRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersConfigRetrieveAsyncWithHttpInfo(string $contentType = self::contentTypes['usersConfigRetrieve'][0])
    {
        $returnType = 'array<string,mixed>';
        $request = $this->usersConfigRetrieveRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersConfigRetrieve'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersConfigRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersConfigRetrieveRequest(string $contentType = self::contentTypes['usersConfigRetrieve'][0])
    {


        $resourcePath = '/api/users/config/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGroupsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersGroupsBulkDestroy($group_request, string $contentType = self::contentTypes['usersGroupsBulkDestroy'][0])
    {
        $this->usersGroupsBulkDestroyWithHttpInfo($group_request, $contentType);
    }

    /**
     * Operation usersGroupsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGroupsBulkDestroyWithHttpInfo($group_request, string $contentType = self::contentTypes['usersGroupsBulkDestroy'][0])
    {
        $request = $this->usersGroupsBulkDestroyRequest($group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersGroupsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsBulkDestroyAsync($group_request, string $contentType = self::contentTypes['usersGroupsBulkDestroy'][0])
    {
        return $this->usersGroupsBulkDestroyAsyncWithHttpInfo($group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGroupsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsBulkDestroyAsyncWithHttpInfo($group_request, string $contentType = self::contentTypes['usersGroupsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->usersGroupsBulkDestroyRequest($group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGroupsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGroupsBulkDestroyRequest($group_request, string $contentType = self::contentTypes['usersGroupsBulkDestroy'][0])
    {

        // verify the required parameter 'group_request' is set
        if ($group_request === null || (is_array($group_request) && count($group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_request when calling usersGroupsBulkDestroy'
            );
        }


        $resourcePath = '/api/users/groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($group_request));
            } else {
                $httpBody = $group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGroupsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Group[]
     */
    public function usersGroupsBulkPartialUpdate($group_request, string $contentType = self::contentTypes['usersGroupsBulkPartialUpdate'][0])
    {
        list($response) = $this->usersGroupsBulkPartialUpdateWithHttpInfo($group_request, $contentType);
        return $response;
    }

    /**
     * Operation usersGroupsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Group[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGroupsBulkPartialUpdateWithHttpInfo($group_request, string $contentType = self::contentTypes['usersGroupsBulkPartialUpdate'][0])
    {
        $request = $this->usersGroupsBulkPartialUpdateRequest($group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Group[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Group[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Group[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Group[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Group[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersGroupsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsBulkPartialUpdateAsync($group_request, string $contentType = self::contentTypes['usersGroupsBulkPartialUpdate'][0])
    {
        return $this->usersGroupsBulkPartialUpdateAsyncWithHttpInfo($group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGroupsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsBulkPartialUpdateAsyncWithHttpInfo($group_request, string $contentType = self::contentTypes['usersGroupsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Group[]';
        $request = $this->usersGroupsBulkPartialUpdateRequest($group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGroupsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGroupsBulkPartialUpdateRequest($group_request, string $contentType = self::contentTypes['usersGroupsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'group_request' is set
        if ($group_request === null || (is_array($group_request) && count($group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_request when calling usersGroupsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/users/groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($group_request));
            } else {
                $httpBody = $group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGroupsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Group[]
     */
    public function usersGroupsBulkUpdate($group_request, string $contentType = self::contentTypes['usersGroupsBulkUpdate'][0])
    {
        list($response) = $this->usersGroupsBulkUpdateWithHttpInfo($group_request, $contentType);
        return $response;
    }

    /**
     * Operation usersGroupsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Group[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGroupsBulkUpdateWithHttpInfo($group_request, string $contentType = self::contentTypes['usersGroupsBulkUpdate'][0])
    {
        $request = $this->usersGroupsBulkUpdateRequest($group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Group[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Group[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Group[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Group[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Group[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersGroupsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsBulkUpdateAsync($group_request, string $contentType = self::contentTypes['usersGroupsBulkUpdate'][0])
    {
        return $this->usersGroupsBulkUpdateAsyncWithHttpInfo($group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGroupsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsBulkUpdateAsyncWithHttpInfo($group_request, string $contentType = self::contentTypes['usersGroupsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Group[]';
        $request = $this->usersGroupsBulkUpdateRequest($group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGroupsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\GroupRequest[] $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGroupsBulkUpdateRequest($group_request, string $contentType = self::contentTypes['usersGroupsBulkUpdate'][0])
    {

        // verify the required parameter 'group_request' is set
        if ($group_request === null || (is_array($group_request) && count($group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_request when calling usersGroupsBulkUpdate'
            );
        }


        $resourcePath = '/api/users/groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($group_request));
            } else {
                $httpBody = $group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGroupsCreate
     *
     * @param  \OpenAPI\Client\Model\GroupRequest $group_request group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Group
     */
    public function usersGroupsCreate($group_request, string $contentType = self::contentTypes['usersGroupsCreate'][0])
    {
        list($response) = $this->usersGroupsCreateWithHttpInfo($group_request, $contentType);
        return $response;
    }

    /**
     * Operation usersGroupsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\GroupRequest $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGroupsCreateWithHttpInfo($group_request, string $contentType = self::contentTypes['usersGroupsCreate'][0])
    {
        $request = $this->usersGroupsCreateRequest($group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Group' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Group' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Group', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Group';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersGroupsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\GroupRequest $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsCreateAsync($group_request, string $contentType = self::contentTypes['usersGroupsCreate'][0])
    {
        return $this->usersGroupsCreateAsyncWithHttpInfo($group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGroupsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\GroupRequest $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsCreateAsyncWithHttpInfo($group_request, string $contentType = self::contentTypes['usersGroupsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Group';
        $request = $this->usersGroupsCreateRequest($group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGroupsCreate'
     *
     * @param  \OpenAPI\Client\Model\GroupRequest $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGroupsCreateRequest($group_request, string $contentType = self::contentTypes['usersGroupsCreate'][0])
    {

        // verify the required parameter 'group_request' is set
        if ($group_request === null || (is_array($group_request) && count($group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_request when calling usersGroupsCreate'
            );
        }


        $resourcePath = '/api/users/groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($group_request));
            } else {
                $httpBody = $group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGroupsDestroy
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersGroupsDestroy($id, string $contentType = self::contentTypes['usersGroupsDestroy'][0])
    {
        $this->usersGroupsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation usersGroupsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGroupsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['usersGroupsDestroy'][0])
    {
        $request = $this->usersGroupsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersGroupsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsDestroyAsync($id, string $contentType = self::contentTypes['usersGroupsDestroy'][0])
    {
        return $this->usersGroupsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGroupsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['usersGroupsDestroy'][0])
    {
        $returnType = '';
        $request = $this->usersGroupsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGroupsDestroy'
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGroupsDestroyRequest($id, string $contentType = self::contentTypes['usersGroupsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersGroupsDestroy'
            );
        }


        $resourcePath = '/api/users/groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGroupsList
     *
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int[] $notification_group_id Notification group (ID) (optional)
     * @param  int[] $notification_group_id__n Notification group (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $permission_id Permission (ID) (optional)
     * @param  int[] $permission_id__n Permission (ID) (optional)
     * @param  string $q Search (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedGroupList
     */
    public function usersGroupsList($description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $notification_group_id = null, $notification_group_id__n = null, $offset = null, $ordering = null, $permission_id = null, $permission_id__n = null, $q = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['usersGroupsList'][0])
    {
        list($response) = $this->usersGroupsListWithHttpInfo($description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $notification_group_id, $notification_group_id__n, $offset, $ordering, $permission_id, $permission_id__n, $q, $user_id, $user_id__n, $contentType);
        return $response;
    }

    /**
     * Operation usersGroupsListWithHttpInfo
     *
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $notification_group_id Notification group (ID) (optional)
     * @param  int[] $notification_group_id__n Notification group (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $permission_id Permission (ID) (optional)
     * @param  int[] $permission_id__n Permission (ID) (optional)
     * @param  string $q Search (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedGroupList, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGroupsListWithHttpInfo($description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $notification_group_id = null, $notification_group_id__n = null, $offset = null, $ordering = null, $permission_id = null, $permission_id__n = null, $q = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['usersGroupsList'][0])
    {
        $request = $this->usersGroupsListRequest($description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $notification_group_id, $notification_group_id__n, $offset, $ordering, $permission_id, $permission_id__n, $q, $user_id, $user_id__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedGroupList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedGroupList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedGroupList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedGroupList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedGroupList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersGroupsListAsync
     *
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $notification_group_id Notification group (ID) (optional)
     * @param  int[] $notification_group_id__n Notification group (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $permission_id Permission (ID) (optional)
     * @param  int[] $permission_id__n Permission (ID) (optional)
     * @param  string $q Search (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsListAsync($description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $notification_group_id = null, $notification_group_id__n = null, $offset = null, $ordering = null, $permission_id = null, $permission_id__n = null, $q = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['usersGroupsList'][0])
    {
        return $this->usersGroupsListAsyncWithHttpInfo($description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $notification_group_id, $notification_group_id__n, $offset, $ordering, $permission_id, $permission_id__n, $q, $user_id, $user_id__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGroupsListAsyncWithHttpInfo
     *
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $notification_group_id Notification group (ID) (optional)
     * @param  int[] $notification_group_id__n Notification group (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $permission_id Permission (ID) (optional)
     * @param  int[] $permission_id__n Permission (ID) (optional)
     * @param  string $q Search (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsListAsyncWithHttpInfo($description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $notification_group_id = null, $notification_group_id__n = null, $offset = null, $ordering = null, $permission_id = null, $permission_id__n = null, $q = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['usersGroupsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedGroupList';
        $request = $this->usersGroupsListRequest($description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $notification_group_id, $notification_group_id__n, $offset, $ordering, $permission_id, $permission_id__n, $q, $user_id, $user_id__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGroupsList'
     *
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $notification_group_id Notification group (ID) (optional)
     * @param  int[] $notification_group_id__n Notification group (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $permission_id Permission (ID) (optional)
     * @param  int[] $permission_id__n Permission (ID) (optional)
     * @param  string $q Search (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGroupsListRequest($description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $notification_group_id = null, $notification_group_id__n = null, $offset = null, $ordering = null, $permission_id = null, $permission_id__n = null, $q = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['usersGroupsList'][0])
    {









































        $resourcePath = '/api/users/groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $notification_group_id,
            'notification_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $notification_group_id__n,
            'notification_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permission_id,
            'permission_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permission_id__n,
            'permission_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'user_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id__n,
            'user_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGroupsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  \OpenAPI\Client\Model\PatchedGroupRequest $patched_group_request patched_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Group
     */
    public function usersGroupsPartialUpdate($id, $patched_group_request = null, string $contentType = self::contentTypes['usersGroupsPartialUpdate'][0])
    {
        list($response) = $this->usersGroupsPartialUpdateWithHttpInfo($id, $patched_group_request, $contentType);
        return $response;
    }

    /**
     * Operation usersGroupsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  \OpenAPI\Client\Model\PatchedGroupRequest $patched_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGroupsPartialUpdateWithHttpInfo($id, $patched_group_request = null, string $contentType = self::contentTypes['usersGroupsPartialUpdate'][0])
    {
        $request = $this->usersGroupsPartialUpdateRequest($id, $patched_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Group' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Group' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Group', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Group';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersGroupsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  \OpenAPI\Client\Model\PatchedGroupRequest $patched_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsPartialUpdateAsync($id, $patched_group_request = null, string $contentType = self::contentTypes['usersGroupsPartialUpdate'][0])
    {
        return $this->usersGroupsPartialUpdateAsyncWithHttpInfo($id, $patched_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGroupsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  \OpenAPI\Client\Model\PatchedGroupRequest $patched_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsPartialUpdateAsyncWithHttpInfo($id, $patched_group_request = null, string $contentType = self::contentTypes['usersGroupsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Group';
        $request = $this->usersGroupsPartialUpdateRequest($id, $patched_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGroupsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  \OpenAPI\Client\Model\PatchedGroupRequest $patched_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGroupsPartialUpdateRequest($id, $patched_group_request = null, string $contentType = self::contentTypes['usersGroupsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersGroupsPartialUpdate'
            );
        }



        $resourcePath = '/api/users/groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_group_request));
            } else {
                $httpBody = $patched_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGroupsRetrieve
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Group
     */
    public function usersGroupsRetrieve($id, string $contentType = self::contentTypes['usersGroupsRetrieve'][0])
    {
        list($response) = $this->usersGroupsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation usersGroupsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGroupsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['usersGroupsRetrieve'][0])
    {
        $request = $this->usersGroupsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Group' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Group' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Group', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Group';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersGroupsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsRetrieveAsync($id, string $contentType = self::contentTypes['usersGroupsRetrieve'][0])
    {
        return $this->usersGroupsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGroupsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['usersGroupsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Group';
        $request = $this->usersGroupsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGroupsRetrieve'
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGroupsRetrieveRequest($id, string $contentType = self::contentTypes['usersGroupsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersGroupsRetrieve'
            );
        }


        $resourcePath = '/api/users/groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGroupsUpdate
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  \OpenAPI\Client\Model\GroupRequest $group_request group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Group
     */
    public function usersGroupsUpdate($id, $group_request, string $contentType = self::contentTypes['usersGroupsUpdate'][0])
    {
        list($response) = $this->usersGroupsUpdateWithHttpInfo($id, $group_request, $contentType);
        return $response;
    }

    /**
     * Operation usersGroupsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  \OpenAPI\Client\Model\GroupRequest $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGroupsUpdateWithHttpInfo($id, $group_request, string $contentType = self::contentTypes['usersGroupsUpdate'][0])
    {
        $request = $this->usersGroupsUpdateRequest($id, $group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Group' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Group' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Group', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Group';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersGroupsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  \OpenAPI\Client\Model\GroupRequest $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsUpdateAsync($id, $group_request, string $contentType = self::contentTypes['usersGroupsUpdate'][0])
    {
        return $this->usersGroupsUpdateAsyncWithHttpInfo($id, $group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGroupsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  \OpenAPI\Client\Model\GroupRequest $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGroupsUpdateAsyncWithHttpInfo($id, $group_request, string $contentType = self::contentTypes['usersGroupsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Group';
        $request = $this->usersGroupsUpdateRequest($id, $group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGroupsUpdate'
     *
     * @param  int $id A unique integer value identifying this group. (required)
     * @param  \OpenAPI\Client\Model\GroupRequest $group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGroupsUpdateRequest($id, $group_request, string $contentType = self::contentTypes['usersGroupsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersGroupsUpdate'
            );
        }

        // verify the required parameter 'group_request' is set
        if ($group_request === null || (is_array($group_request) && count($group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_request when calling usersGroupsUpdate'
            );
        }


        $resourcePath = '/api/users/groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($group_request));
            } else {
                $httpBody = $group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersPermissionsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersPermissionsBulkDestroy($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkDestroy'][0])
    {
        $this->usersPermissionsBulkDestroyWithHttpInfo($object_permission_request, $contentType);
    }

    /**
     * Operation usersPermissionsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersPermissionsBulkDestroyWithHttpInfo($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkDestroy'][0])
    {
        $request = $this->usersPermissionsBulkDestroyRequest($object_permission_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersPermissionsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsBulkDestroyAsync($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkDestroy'][0])
    {
        return $this->usersPermissionsBulkDestroyAsyncWithHttpInfo($object_permission_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersPermissionsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsBulkDestroyAsyncWithHttpInfo($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->usersPermissionsBulkDestroyRequest($object_permission_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersPermissionsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersPermissionsBulkDestroyRequest($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkDestroy'][0])
    {

        // verify the required parameter 'object_permission_request' is set
        if ($object_permission_request === null || (is_array($object_permission_request) && count($object_permission_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_permission_request when calling usersPermissionsBulkDestroy'
            );
        }


        $resourcePath = '/api/users/permissions/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($object_permission_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($object_permission_request));
            } else {
                $httpBody = $object_permission_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersPermissionsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectPermission[]
     */
    public function usersPermissionsBulkPartialUpdate($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkPartialUpdate'][0])
    {
        list($response) = $this->usersPermissionsBulkPartialUpdateWithHttpInfo($object_permission_request, $contentType);
        return $response;
    }

    /**
     * Operation usersPermissionsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectPermission[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersPermissionsBulkPartialUpdateWithHttpInfo($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkPartialUpdate'][0])
    {
        $request = $this->usersPermissionsBulkPartialUpdateRequest($object_permission_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ObjectPermission[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ObjectPermission[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ObjectPermission[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ObjectPermission[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectPermission[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersPermissionsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsBulkPartialUpdateAsync($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkPartialUpdate'][0])
    {
        return $this->usersPermissionsBulkPartialUpdateAsyncWithHttpInfo($object_permission_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersPermissionsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsBulkPartialUpdateAsyncWithHttpInfo($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectPermission[]';
        $request = $this->usersPermissionsBulkPartialUpdateRequest($object_permission_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersPermissionsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersPermissionsBulkPartialUpdateRequest($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'object_permission_request' is set
        if ($object_permission_request === null || (is_array($object_permission_request) && count($object_permission_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_permission_request when calling usersPermissionsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/users/permissions/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($object_permission_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($object_permission_request));
            } else {
                $httpBody = $object_permission_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersPermissionsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectPermission[]
     */
    public function usersPermissionsBulkUpdate($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkUpdate'][0])
    {
        list($response) = $this->usersPermissionsBulkUpdateWithHttpInfo($object_permission_request, $contentType);
        return $response;
    }

    /**
     * Operation usersPermissionsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectPermission[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersPermissionsBulkUpdateWithHttpInfo($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkUpdate'][0])
    {
        $request = $this->usersPermissionsBulkUpdateRequest($object_permission_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ObjectPermission[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ObjectPermission[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ObjectPermission[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ObjectPermission[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectPermission[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersPermissionsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsBulkUpdateAsync($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkUpdate'][0])
    {
        return $this->usersPermissionsBulkUpdateAsyncWithHttpInfo($object_permission_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersPermissionsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsBulkUpdateAsyncWithHttpInfo($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectPermission[]';
        $request = $this->usersPermissionsBulkUpdateRequest($object_permission_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersPermissionsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest[] $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersPermissionsBulkUpdateRequest($object_permission_request, string $contentType = self::contentTypes['usersPermissionsBulkUpdate'][0])
    {

        // verify the required parameter 'object_permission_request' is set
        if ($object_permission_request === null || (is_array($object_permission_request) && count($object_permission_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_permission_request when calling usersPermissionsBulkUpdate'
            );
        }


        $resourcePath = '/api/users/permissions/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($object_permission_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($object_permission_request));
            } else {
                $httpBody = $object_permission_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersPermissionsCreate
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest $object_permission_request object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectPermission
     */
    public function usersPermissionsCreate($object_permission_request, string $contentType = self::contentTypes['usersPermissionsCreate'][0])
    {
        list($response) = $this->usersPermissionsCreateWithHttpInfo($object_permission_request, $contentType);
        return $response;
    }

    /**
     * Operation usersPermissionsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectPermission, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersPermissionsCreateWithHttpInfo($object_permission_request, string $contentType = self::contentTypes['usersPermissionsCreate'][0])
    {
        $request = $this->usersPermissionsCreateRequest($object_permission_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ObjectPermission' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ObjectPermission' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ObjectPermission', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ObjectPermission';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectPermission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersPermissionsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsCreateAsync($object_permission_request, string $contentType = self::contentTypes['usersPermissionsCreate'][0])
    {
        return $this->usersPermissionsCreateAsyncWithHttpInfo($object_permission_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersPermissionsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsCreateAsyncWithHttpInfo($object_permission_request, string $contentType = self::contentTypes['usersPermissionsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectPermission';
        $request = $this->usersPermissionsCreateRequest($object_permission_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersPermissionsCreate'
     *
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersPermissionsCreateRequest($object_permission_request, string $contentType = self::contentTypes['usersPermissionsCreate'][0])
    {

        // verify the required parameter 'object_permission_request' is set
        if ($object_permission_request === null || (is_array($object_permission_request) && count($object_permission_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_permission_request when calling usersPermissionsCreate'
            );
        }


        $resourcePath = '/api/users/permissions/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($object_permission_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($object_permission_request));
            } else {
                $httpBody = $object_permission_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersPermissionsDestroy
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersPermissionsDestroy($id, string $contentType = self::contentTypes['usersPermissionsDestroy'][0])
    {
        $this->usersPermissionsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation usersPermissionsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersPermissionsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['usersPermissionsDestroy'][0])
    {
        $request = $this->usersPermissionsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersPermissionsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsDestroyAsync($id, string $contentType = self::contentTypes['usersPermissionsDestroy'][0])
    {
        return $this->usersPermissionsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersPermissionsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['usersPermissionsDestroy'][0])
    {
        $returnType = '';
        $request = $this->usersPermissionsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersPermissionsDestroy'
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersPermissionsDestroyRequest($id, string $contentType = self::contentTypes['usersPermissionsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersPermissionsDestroy'
            );
        }


        $resourcePath = '/api/users/permissions/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersPermissionsList
     *
     * @param  bool $can_add can_add (optional)
     * @param  bool $can_change can_change (optional)
     * @param  bool $can_delete can_delete (optional)
     * @param  bool $can_view can_view (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  bool $enabled enabled (optional)
     * @param  string[] $group Group (name) (optional)
     * @param  string[] $group__n Group (name) (optional)
     * @param  int[] $group_id Group (optional)
     * @param  int[] $group_id__n Group (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  string $object_type object_type (optional)
     * @param  string $object_type__ic object_type__ic (optional)
     * @param  string $object_type__ie object_type__ie (optional)
     * @param  string $object_type__iew object_type__iew (optional)
     * @param  string $object_type__isw object_type__isw (optional)
     * @param  string $object_type__n object_type__n (optional)
     * @param  string $object_type__nic object_type__nic (optional)
     * @param  string $object_type__nie object_type__nie (optional)
     * @param  string $object_type__niew object_type__niew (optional)
     * @param  string $object_type__nisw object_type__nisw (optional)
     * @param  int[] $object_type_id object_type_id (optional)
     * @param  int[] $object_type_id__n object_type_id__n (optional)
     * @param  int[] $object_types object_types (optional)
     * @param  int[] $object_types__n object_types__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (optional)
     * @param  int[] $user_id__n User (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedObjectPermissionList
     */
    public function usersPermissionsList($can_add = null, $can_change = null, $can_delete = null, $can_view = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $object_types = null, $object_types__n = null, $offset = null, $ordering = null, $q = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['usersPermissionsList'][0])
    {
        list($response) = $this->usersPermissionsListWithHttpInfo($can_add, $can_change, $can_delete, $can_view, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $object_types, $object_types__n, $offset, $ordering, $q, $user, $user__n, $user_id, $user_id__n, $contentType);
        return $response;
    }

    /**
     * Operation usersPermissionsListWithHttpInfo
     *
     * @param  bool $can_add (optional)
     * @param  bool $can_change (optional)
     * @param  bool $can_delete (optional)
     * @param  bool $can_view (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  string[] $group Group (name) (optional)
     * @param  string[] $group__n Group (name) (optional)
     * @param  int[] $group_id Group (optional)
     * @param  int[] $group_id__n Group (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int[] $object_types (optional)
     * @param  int[] $object_types__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (optional)
     * @param  int[] $user_id__n User (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedObjectPermissionList, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersPermissionsListWithHttpInfo($can_add = null, $can_change = null, $can_delete = null, $can_view = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $object_types = null, $object_types__n = null, $offset = null, $ordering = null, $q = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['usersPermissionsList'][0])
    {
        $request = $this->usersPermissionsListRequest($can_add, $can_change, $can_delete, $can_view, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $object_types, $object_types__n, $offset, $ordering, $q, $user, $user__n, $user_id, $user_id__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedObjectPermissionList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedObjectPermissionList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedObjectPermissionList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedObjectPermissionList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedObjectPermissionList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersPermissionsListAsync
     *
     * @param  bool $can_add (optional)
     * @param  bool $can_change (optional)
     * @param  bool $can_delete (optional)
     * @param  bool $can_view (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  string[] $group Group (name) (optional)
     * @param  string[] $group__n Group (name) (optional)
     * @param  int[] $group_id Group (optional)
     * @param  int[] $group_id__n Group (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int[] $object_types (optional)
     * @param  int[] $object_types__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (optional)
     * @param  int[] $user_id__n User (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsListAsync($can_add = null, $can_change = null, $can_delete = null, $can_view = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $object_types = null, $object_types__n = null, $offset = null, $ordering = null, $q = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['usersPermissionsList'][0])
    {
        return $this->usersPermissionsListAsyncWithHttpInfo($can_add, $can_change, $can_delete, $can_view, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $object_types, $object_types__n, $offset, $ordering, $q, $user, $user__n, $user_id, $user_id__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersPermissionsListAsyncWithHttpInfo
     *
     * @param  bool $can_add (optional)
     * @param  bool $can_change (optional)
     * @param  bool $can_delete (optional)
     * @param  bool $can_view (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  string[] $group Group (name) (optional)
     * @param  string[] $group__n Group (name) (optional)
     * @param  int[] $group_id Group (optional)
     * @param  int[] $group_id__n Group (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int[] $object_types (optional)
     * @param  int[] $object_types__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (optional)
     * @param  int[] $user_id__n User (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsListAsyncWithHttpInfo($can_add = null, $can_change = null, $can_delete = null, $can_view = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $object_types = null, $object_types__n = null, $offset = null, $ordering = null, $q = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['usersPermissionsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedObjectPermissionList';
        $request = $this->usersPermissionsListRequest($can_add, $can_change, $can_delete, $can_view, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $object_types, $object_types__n, $offset, $ordering, $q, $user, $user__n, $user_id, $user_id__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersPermissionsList'
     *
     * @param  bool $can_add (optional)
     * @param  bool $can_change (optional)
     * @param  bool $can_delete (optional)
     * @param  bool $can_view (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  string[] $group Group (name) (optional)
     * @param  string[] $group__n Group (name) (optional)
     * @param  int[] $group_id Group (optional)
     * @param  int[] $group_id__n Group (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int[] $object_types (optional)
     * @param  int[] $object_types__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (optional)
     * @param  int[] $user_id__n User (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersPermissionsListRequest($can_add = null, $can_change = null, $can_delete = null, $can_view = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $object_types = null, $object_types__n = null, $offset = null, $ordering = null, $q = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['usersPermissionsList'][0])
    {






























































        $resourcePath = '/api/users/permissions/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $can_add,
            'can_add', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $can_change,
            'can_change', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $can_delete,
            'can_delete', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $can_view,
            'can_view', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enabled,
            'enabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group,
            'group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group__n,
            'group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id,
            'group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__n,
            'group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type,
            'object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ic,
            'object_type__ic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ie,
            'object_type__ie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__iew,
            'object_type__iew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__isw,
            'object_type__isw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__n,
            'object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nic,
            'object_type__nic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nie,
            'object_type__nie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__niew,
            'object_type__niew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nisw,
            'object_type__nisw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id,
            'object_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__n,
            'object_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_types,
            'object_types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_types__n,
            'object_types__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user,
            'user', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user__n,
            'user__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'user_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id__n,
            'user_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersPermissionsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  \OpenAPI\Client\Model\PatchedObjectPermissionRequest $patched_object_permission_request patched_object_permission_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectPermission
     */
    public function usersPermissionsPartialUpdate($id, $patched_object_permission_request = null, string $contentType = self::contentTypes['usersPermissionsPartialUpdate'][0])
    {
        list($response) = $this->usersPermissionsPartialUpdateWithHttpInfo($id, $patched_object_permission_request, $contentType);
        return $response;
    }

    /**
     * Operation usersPermissionsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  \OpenAPI\Client\Model\PatchedObjectPermissionRequest $patched_object_permission_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectPermission, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersPermissionsPartialUpdateWithHttpInfo($id, $patched_object_permission_request = null, string $contentType = self::contentTypes['usersPermissionsPartialUpdate'][0])
    {
        $request = $this->usersPermissionsPartialUpdateRequest($id, $patched_object_permission_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ObjectPermission' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ObjectPermission' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ObjectPermission', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ObjectPermission';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectPermission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersPermissionsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  \OpenAPI\Client\Model\PatchedObjectPermissionRequest $patched_object_permission_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsPartialUpdateAsync($id, $patched_object_permission_request = null, string $contentType = self::contentTypes['usersPermissionsPartialUpdate'][0])
    {
        return $this->usersPermissionsPartialUpdateAsyncWithHttpInfo($id, $patched_object_permission_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersPermissionsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  \OpenAPI\Client\Model\PatchedObjectPermissionRequest $patched_object_permission_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsPartialUpdateAsyncWithHttpInfo($id, $patched_object_permission_request = null, string $contentType = self::contentTypes['usersPermissionsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectPermission';
        $request = $this->usersPermissionsPartialUpdateRequest($id, $patched_object_permission_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersPermissionsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  \OpenAPI\Client\Model\PatchedObjectPermissionRequest $patched_object_permission_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersPermissionsPartialUpdateRequest($id, $patched_object_permission_request = null, string $contentType = self::contentTypes['usersPermissionsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersPermissionsPartialUpdate'
            );
        }



        $resourcePath = '/api/users/permissions/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_object_permission_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_object_permission_request));
            } else {
                $httpBody = $patched_object_permission_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersPermissionsRetrieve
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectPermission
     */
    public function usersPermissionsRetrieve($id, string $contentType = self::contentTypes['usersPermissionsRetrieve'][0])
    {
        list($response) = $this->usersPermissionsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation usersPermissionsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectPermission, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersPermissionsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['usersPermissionsRetrieve'][0])
    {
        $request = $this->usersPermissionsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ObjectPermission' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ObjectPermission' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ObjectPermission', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ObjectPermission';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectPermission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersPermissionsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsRetrieveAsync($id, string $contentType = self::contentTypes['usersPermissionsRetrieve'][0])
    {
        return $this->usersPermissionsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersPermissionsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['usersPermissionsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectPermission';
        $request = $this->usersPermissionsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersPermissionsRetrieve'
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersPermissionsRetrieveRequest($id, string $contentType = self::contentTypes['usersPermissionsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersPermissionsRetrieve'
            );
        }


        $resourcePath = '/api/users/permissions/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersPermissionsUpdate
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest $object_permission_request object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectPermission
     */
    public function usersPermissionsUpdate($id, $object_permission_request, string $contentType = self::contentTypes['usersPermissionsUpdate'][0])
    {
        list($response) = $this->usersPermissionsUpdateWithHttpInfo($id, $object_permission_request, $contentType);
        return $response;
    }

    /**
     * Operation usersPermissionsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectPermission, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersPermissionsUpdateWithHttpInfo($id, $object_permission_request, string $contentType = self::contentTypes['usersPermissionsUpdate'][0])
    {
        $request = $this->usersPermissionsUpdateRequest($id, $object_permission_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ObjectPermission' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ObjectPermission' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ObjectPermission', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ObjectPermission';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectPermission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersPermissionsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsUpdateAsync($id, $object_permission_request, string $contentType = self::contentTypes['usersPermissionsUpdate'][0])
    {
        return $this->usersPermissionsUpdateAsyncWithHttpInfo($id, $object_permission_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersPermissionsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersPermissionsUpdateAsyncWithHttpInfo($id, $object_permission_request, string $contentType = self::contentTypes['usersPermissionsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectPermission';
        $request = $this->usersPermissionsUpdateRequest($id, $object_permission_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersPermissionsUpdate'
     *
     * @param  int $id A unique integer value identifying this permission. (required)
     * @param  \OpenAPI\Client\Model\ObjectPermissionRequest $object_permission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersPermissionsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersPermissionsUpdateRequest($id, $object_permission_request, string $contentType = self::contentTypes['usersPermissionsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersPermissionsUpdate'
            );
        }

        // verify the required parameter 'object_permission_request' is set
        if ($object_permission_request === null || (is_array($object_permission_request) && count($object_permission_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_permission_request when calling usersPermissionsUpdate'
            );
        }


        $resourcePath = '/api/users/permissions/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($object_permission_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($object_permission_request));
            } else {
                $httpBody = $object_permission_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersTokensBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersTokensBulkDestroy($token_request, string $contentType = self::contentTypes['usersTokensBulkDestroy'][0])
    {
        $this->usersTokensBulkDestroyWithHttpInfo($token_request, $contentType);
    }

    /**
     * Operation usersTokensBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersTokensBulkDestroyWithHttpInfo($token_request, string $contentType = self::contentTypes['usersTokensBulkDestroy'][0])
    {
        $request = $this->usersTokensBulkDestroyRequest($token_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersTokensBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensBulkDestroyAsync($token_request, string $contentType = self::contentTypes['usersTokensBulkDestroy'][0])
    {
        return $this->usersTokensBulkDestroyAsyncWithHttpInfo($token_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersTokensBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensBulkDestroyAsyncWithHttpInfo($token_request, string $contentType = self::contentTypes['usersTokensBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->usersTokensBulkDestroyRequest($token_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersTokensBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersTokensBulkDestroyRequest($token_request, string $contentType = self::contentTypes['usersTokensBulkDestroy'][0])
    {

        // verify the required parameter 'token_request' is set
        if ($token_request === null || (is_array($token_request) && count($token_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_request when calling usersTokensBulkDestroy'
            );
        }


        $resourcePath = '/api/users/tokens/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($token_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($token_request));
            } else {
                $httpBody = $token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersTokensBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Token[]
     */
    public function usersTokensBulkPartialUpdate($token_request, string $contentType = self::contentTypes['usersTokensBulkPartialUpdate'][0])
    {
        list($response) = $this->usersTokensBulkPartialUpdateWithHttpInfo($token_request, $contentType);
        return $response;
    }

    /**
     * Operation usersTokensBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Token[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersTokensBulkPartialUpdateWithHttpInfo($token_request, string $contentType = self::contentTypes['usersTokensBulkPartialUpdate'][0])
    {
        $request = $this->usersTokensBulkPartialUpdateRequest($token_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Token[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Token[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Token[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Token[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Token[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersTokensBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensBulkPartialUpdateAsync($token_request, string $contentType = self::contentTypes['usersTokensBulkPartialUpdate'][0])
    {
        return $this->usersTokensBulkPartialUpdateAsyncWithHttpInfo($token_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersTokensBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensBulkPartialUpdateAsyncWithHttpInfo($token_request, string $contentType = self::contentTypes['usersTokensBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Token[]';
        $request = $this->usersTokensBulkPartialUpdateRequest($token_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersTokensBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersTokensBulkPartialUpdateRequest($token_request, string $contentType = self::contentTypes['usersTokensBulkPartialUpdate'][0])
    {

        // verify the required parameter 'token_request' is set
        if ($token_request === null || (is_array($token_request) && count($token_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_request when calling usersTokensBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/users/tokens/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($token_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($token_request));
            } else {
                $httpBody = $token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersTokensBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Token[]
     */
    public function usersTokensBulkUpdate($token_request, string $contentType = self::contentTypes['usersTokensBulkUpdate'][0])
    {
        list($response) = $this->usersTokensBulkUpdateWithHttpInfo($token_request, $contentType);
        return $response;
    }

    /**
     * Operation usersTokensBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Token[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersTokensBulkUpdateWithHttpInfo($token_request, string $contentType = self::contentTypes['usersTokensBulkUpdate'][0])
    {
        $request = $this->usersTokensBulkUpdateRequest($token_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Token[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Token[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Token[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Token[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Token[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersTokensBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensBulkUpdateAsync($token_request, string $contentType = self::contentTypes['usersTokensBulkUpdate'][0])
    {
        return $this->usersTokensBulkUpdateAsyncWithHttpInfo($token_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersTokensBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensBulkUpdateAsyncWithHttpInfo($token_request, string $contentType = self::contentTypes['usersTokensBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Token[]';
        $request = $this->usersTokensBulkUpdateRequest($token_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersTokensBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\TokenRequest[] $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersTokensBulkUpdateRequest($token_request, string $contentType = self::contentTypes['usersTokensBulkUpdate'][0])
    {

        // verify the required parameter 'token_request' is set
        if ($token_request === null || (is_array($token_request) && count($token_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_request when calling usersTokensBulkUpdate'
            );
        }


        $resourcePath = '/api/users/tokens/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($token_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($token_request));
            } else {
                $httpBody = $token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersTokensCreate
     *
     * @param  \OpenAPI\Client\Model\TokenRequest $token_request token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Token
     */
    public function usersTokensCreate($token_request, string $contentType = self::contentTypes['usersTokensCreate'][0])
    {
        list($response) = $this->usersTokensCreateWithHttpInfo($token_request, $contentType);
        return $response;
    }

    /**
     * Operation usersTokensCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TokenRequest $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Token, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersTokensCreateWithHttpInfo($token_request, string $contentType = self::contentTypes['usersTokensCreate'][0])
    {
        $request = $this->usersTokensCreateRequest($token_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Token' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Token' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Token', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Token';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Token',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersTokensCreateAsync
     *
     * @param  \OpenAPI\Client\Model\TokenRequest $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensCreateAsync($token_request, string $contentType = self::contentTypes['usersTokensCreate'][0])
    {
        return $this->usersTokensCreateAsyncWithHttpInfo($token_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersTokensCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TokenRequest $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensCreateAsyncWithHttpInfo($token_request, string $contentType = self::contentTypes['usersTokensCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Token';
        $request = $this->usersTokensCreateRequest($token_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersTokensCreate'
     *
     * @param  \OpenAPI\Client\Model\TokenRequest $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersTokensCreateRequest($token_request, string $contentType = self::contentTypes['usersTokensCreate'][0])
    {

        // verify the required parameter 'token_request' is set
        if ($token_request === null || (is_array($token_request) && count($token_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_request when calling usersTokensCreate'
            );
        }


        $resourcePath = '/api/users/tokens/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($token_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($token_request));
            } else {
                $httpBody = $token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersTokensDestroy
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersTokensDestroy($id, string $contentType = self::contentTypes['usersTokensDestroy'][0])
    {
        $this->usersTokensDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation usersTokensDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersTokensDestroyWithHttpInfo($id, string $contentType = self::contentTypes['usersTokensDestroy'][0])
    {
        $request = $this->usersTokensDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersTokensDestroyAsync
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensDestroyAsync($id, string $contentType = self::contentTypes['usersTokensDestroy'][0])
    {
        return $this->usersTokensDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersTokensDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['usersTokensDestroy'][0])
    {
        $returnType = '';
        $request = $this->usersTokensDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersTokensDestroy'
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersTokensDestroyRequest($id, string $contentType = self::contentTypes['usersTokensDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersTokensDestroy'
            );
        }


        $resourcePath = '/api/users/tokens/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersTokensList
     *
     * @param  \DateTime $created created (optional)
     * @param  \DateTime $created__gte created__gte (optional)
     * @param  \DateTime $created__lte created__lte (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  \DateTime $expires expires (optional)
     * @param  \DateTime $expires__gte expires__gte (optional)
     * @param  \DateTime $expires__lte expires__lte (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $key key (optional)
     * @param  bool $key__empty key__empty (optional)
     * @param  string[] $key__ic key__ic (optional)
     * @param  string[] $key__ie key__ie (optional)
     * @param  string[] $key__iew key__iew (optional)
     * @param  string[] $key__isw key__isw (optional)
     * @param  string[] $key__n key__n (optional)
     * @param  string[] $key__nic key__nic (optional)
     * @param  string[] $key__nie key__nie (optional)
     * @param  string[] $key__niew key__niew (optional)
     * @param  string[] $key__nisw key__nisw (optional)
     * @param  \DateTime[] $last_used last_used (optional)
     * @param  bool $last_used__empty last_used__empty (optional)
     * @param  \DateTime[] $last_used__gt last_used__gt (optional)
     * @param  \DateTime[] $last_used__gte last_used__gte (optional)
     * @param  \DateTime[] $last_used__lt last_used__lt (optional)
     * @param  \DateTime[] $last_used__lte last_used__lte (optional)
     * @param  \DateTime[] $last_used__n last_used__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (optional)
     * @param  int[] $user_id__n User (optional)
     * @param  bool $write_enabled write_enabled (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedTokenList
     */
    public function usersTokensList($created = null, $created__gte = null, $created__lte = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $expires = null, $expires__gte = null, $expires__lte = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $key = null, $key__empty = null, $key__ic = null, $key__ie = null, $key__iew = null, $key__isw = null, $key__n = null, $key__nic = null, $key__nie = null, $key__niew = null, $key__nisw = null, $last_used = null, $last_used__empty = null, $last_used__gt = null, $last_used__gte = null, $last_used__lt = null, $last_used__lte = null, $last_used__n = null, $limit = null, $offset = null, $ordering = null, $q = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $write_enabled = null, string $contentType = self::contentTypes['usersTokensList'][0])
    {
        list($response) = $this->usersTokensListWithHttpInfo($created, $created__gte, $created__lte, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $expires, $expires__gte, $expires__lte, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $key, $key__empty, $key__ic, $key__ie, $key__iew, $key__isw, $key__n, $key__nic, $key__nie, $key__niew, $key__nisw, $last_used, $last_used__empty, $last_used__gt, $last_used__gte, $last_used__lt, $last_used__lte, $last_used__n, $limit, $offset, $ordering, $q, $user, $user__n, $user_id, $user_id__n, $write_enabled, $contentType);
        return $response;
    }

    /**
     * Operation usersTokensListWithHttpInfo
     *
     * @param  \DateTime $created (optional)
     * @param  \DateTime $created__gte (optional)
     * @param  \DateTime $created__lte (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  \DateTime $expires (optional)
     * @param  \DateTime $expires__gte (optional)
     * @param  \DateTime $expires__lte (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $key (optional)
     * @param  bool $key__empty (optional)
     * @param  string[] $key__ic (optional)
     * @param  string[] $key__ie (optional)
     * @param  string[] $key__iew (optional)
     * @param  string[] $key__isw (optional)
     * @param  string[] $key__n (optional)
     * @param  string[] $key__nic (optional)
     * @param  string[] $key__nie (optional)
     * @param  string[] $key__niew (optional)
     * @param  string[] $key__nisw (optional)
     * @param  \DateTime[] $last_used (optional)
     * @param  bool $last_used__empty (optional)
     * @param  \DateTime[] $last_used__gt (optional)
     * @param  \DateTime[] $last_used__gte (optional)
     * @param  \DateTime[] $last_used__lt (optional)
     * @param  \DateTime[] $last_used__lte (optional)
     * @param  \DateTime[] $last_used__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (optional)
     * @param  int[] $user_id__n User (optional)
     * @param  bool $write_enabled (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedTokenList, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersTokensListWithHttpInfo($created = null, $created__gte = null, $created__lte = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $expires = null, $expires__gte = null, $expires__lte = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $key = null, $key__empty = null, $key__ic = null, $key__ie = null, $key__iew = null, $key__isw = null, $key__n = null, $key__nic = null, $key__nie = null, $key__niew = null, $key__nisw = null, $last_used = null, $last_used__empty = null, $last_used__gt = null, $last_used__gte = null, $last_used__lt = null, $last_used__lte = null, $last_used__n = null, $limit = null, $offset = null, $ordering = null, $q = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $write_enabled = null, string $contentType = self::contentTypes['usersTokensList'][0])
    {
        $request = $this->usersTokensListRequest($created, $created__gte, $created__lte, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $expires, $expires__gte, $expires__lte, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $key, $key__empty, $key__ic, $key__ie, $key__iew, $key__isw, $key__n, $key__nic, $key__nie, $key__niew, $key__nisw, $last_used, $last_used__empty, $last_used__gt, $last_used__gte, $last_used__lt, $last_used__lte, $last_used__n, $limit, $offset, $ordering, $q, $user, $user__n, $user_id, $user_id__n, $write_enabled, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedTokenList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedTokenList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedTokenList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedTokenList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedTokenList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersTokensListAsync
     *
     * @param  \DateTime $created (optional)
     * @param  \DateTime $created__gte (optional)
     * @param  \DateTime $created__lte (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  \DateTime $expires (optional)
     * @param  \DateTime $expires__gte (optional)
     * @param  \DateTime $expires__lte (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $key (optional)
     * @param  bool $key__empty (optional)
     * @param  string[] $key__ic (optional)
     * @param  string[] $key__ie (optional)
     * @param  string[] $key__iew (optional)
     * @param  string[] $key__isw (optional)
     * @param  string[] $key__n (optional)
     * @param  string[] $key__nic (optional)
     * @param  string[] $key__nie (optional)
     * @param  string[] $key__niew (optional)
     * @param  string[] $key__nisw (optional)
     * @param  \DateTime[] $last_used (optional)
     * @param  bool $last_used__empty (optional)
     * @param  \DateTime[] $last_used__gt (optional)
     * @param  \DateTime[] $last_used__gte (optional)
     * @param  \DateTime[] $last_used__lt (optional)
     * @param  \DateTime[] $last_used__lte (optional)
     * @param  \DateTime[] $last_used__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (optional)
     * @param  int[] $user_id__n User (optional)
     * @param  bool $write_enabled (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensListAsync($created = null, $created__gte = null, $created__lte = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $expires = null, $expires__gte = null, $expires__lte = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $key = null, $key__empty = null, $key__ic = null, $key__ie = null, $key__iew = null, $key__isw = null, $key__n = null, $key__nic = null, $key__nie = null, $key__niew = null, $key__nisw = null, $last_used = null, $last_used__empty = null, $last_used__gt = null, $last_used__gte = null, $last_used__lt = null, $last_used__lte = null, $last_used__n = null, $limit = null, $offset = null, $ordering = null, $q = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $write_enabled = null, string $contentType = self::contentTypes['usersTokensList'][0])
    {
        return $this->usersTokensListAsyncWithHttpInfo($created, $created__gte, $created__lte, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $expires, $expires__gte, $expires__lte, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $key, $key__empty, $key__ic, $key__ie, $key__iew, $key__isw, $key__n, $key__nic, $key__nie, $key__niew, $key__nisw, $last_used, $last_used__empty, $last_used__gt, $last_used__gte, $last_used__lt, $last_used__lte, $last_used__n, $limit, $offset, $ordering, $q, $user, $user__n, $user_id, $user_id__n, $write_enabled, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersTokensListAsyncWithHttpInfo
     *
     * @param  \DateTime $created (optional)
     * @param  \DateTime $created__gte (optional)
     * @param  \DateTime $created__lte (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  \DateTime $expires (optional)
     * @param  \DateTime $expires__gte (optional)
     * @param  \DateTime $expires__lte (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $key (optional)
     * @param  bool $key__empty (optional)
     * @param  string[] $key__ic (optional)
     * @param  string[] $key__ie (optional)
     * @param  string[] $key__iew (optional)
     * @param  string[] $key__isw (optional)
     * @param  string[] $key__n (optional)
     * @param  string[] $key__nic (optional)
     * @param  string[] $key__nie (optional)
     * @param  string[] $key__niew (optional)
     * @param  string[] $key__nisw (optional)
     * @param  \DateTime[] $last_used (optional)
     * @param  bool $last_used__empty (optional)
     * @param  \DateTime[] $last_used__gt (optional)
     * @param  \DateTime[] $last_used__gte (optional)
     * @param  \DateTime[] $last_used__lt (optional)
     * @param  \DateTime[] $last_used__lte (optional)
     * @param  \DateTime[] $last_used__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (optional)
     * @param  int[] $user_id__n User (optional)
     * @param  bool $write_enabled (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensListAsyncWithHttpInfo($created = null, $created__gte = null, $created__lte = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $expires = null, $expires__gte = null, $expires__lte = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $key = null, $key__empty = null, $key__ic = null, $key__ie = null, $key__iew = null, $key__isw = null, $key__n = null, $key__nic = null, $key__nie = null, $key__niew = null, $key__nisw = null, $last_used = null, $last_used__empty = null, $last_used__gt = null, $last_used__gte = null, $last_used__lt = null, $last_used__lte = null, $last_used__n = null, $limit = null, $offset = null, $ordering = null, $q = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $write_enabled = null, string $contentType = self::contentTypes['usersTokensList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedTokenList';
        $request = $this->usersTokensListRequest($created, $created__gte, $created__lte, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $expires, $expires__gte, $expires__lte, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $key, $key__empty, $key__ic, $key__ie, $key__iew, $key__isw, $key__n, $key__nic, $key__nie, $key__niew, $key__nisw, $last_used, $last_used__empty, $last_used__gt, $last_used__gte, $last_used__lt, $last_used__lte, $last_used__n, $limit, $offset, $ordering, $q, $user, $user__n, $user_id, $user_id__n, $write_enabled, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersTokensList'
     *
     * @param  \DateTime $created (optional)
     * @param  \DateTime $created__gte (optional)
     * @param  \DateTime $created__lte (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  \DateTime $expires (optional)
     * @param  \DateTime $expires__gte (optional)
     * @param  \DateTime $expires__lte (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $key (optional)
     * @param  bool $key__empty (optional)
     * @param  string[] $key__ic (optional)
     * @param  string[] $key__ie (optional)
     * @param  string[] $key__iew (optional)
     * @param  string[] $key__isw (optional)
     * @param  string[] $key__n (optional)
     * @param  string[] $key__nic (optional)
     * @param  string[] $key__nie (optional)
     * @param  string[] $key__niew (optional)
     * @param  string[] $key__nisw (optional)
     * @param  \DateTime[] $last_used (optional)
     * @param  bool $last_used__empty (optional)
     * @param  \DateTime[] $last_used__gt (optional)
     * @param  \DateTime[] $last_used__gte (optional)
     * @param  \DateTime[] $last_used__lt (optional)
     * @param  \DateTime[] $last_used__lte (optional)
     * @param  \DateTime[] $last_used__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (optional)
     * @param  int[] $user_id__n User (optional)
     * @param  bool $write_enabled (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersTokensListRequest($created = null, $created__gte = null, $created__lte = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $expires = null, $expires__gte = null, $expires__lte = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $key = null, $key__empty = null, $key__ic = null, $key__ie = null, $key__iew = null, $key__isw = null, $key__n = null, $key__nic = null, $key__nie = null, $key__niew = null, $key__nisw = null, $last_used = null, $last_used__empty = null, $last_used__gt = null, $last_used__gte = null, $last_used__lt = null, $last_used__lte = null, $last_used__n = null, $limit = null, $offset = null, $ordering = null, $q = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $write_enabled = null, string $contentType = self::contentTypes['usersTokensList'][0])
    {





















































        $resourcePath = '/api/users/tokens/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expires,
            'expires', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expires__gte,
            'expires__gte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expires__lte,
            'expires__lte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key,
            'key', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key__empty,
            'key__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key__ic,
            'key__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key__ie,
            'key__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key__iew,
            'key__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key__isw,
            'key__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key__n,
            'key__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key__nic,
            'key__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key__nie,
            'key__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key__niew,
            'key__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key__nisw,
            'key__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_used,
            'last_used', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_used__empty,
            'last_used__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_used__gt,
            'last_used__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_used__gte,
            'last_used__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_used__lt,
            'last_used__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_used__lte,
            'last_used__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_used__n,
            'last_used__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user,
            'user', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user__n,
            'user__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'user_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id__n,
            'user_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $write_enabled,
            'write_enabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersTokensPartialUpdate
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  \OpenAPI\Client\Model\PatchedTokenRequest $patched_token_request patched_token_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Token
     */
    public function usersTokensPartialUpdate($id, $patched_token_request = null, string $contentType = self::contentTypes['usersTokensPartialUpdate'][0])
    {
        list($response) = $this->usersTokensPartialUpdateWithHttpInfo($id, $patched_token_request, $contentType);
        return $response;
    }

    /**
     * Operation usersTokensPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  \OpenAPI\Client\Model\PatchedTokenRequest $patched_token_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Token, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersTokensPartialUpdateWithHttpInfo($id, $patched_token_request = null, string $contentType = self::contentTypes['usersTokensPartialUpdate'][0])
    {
        $request = $this->usersTokensPartialUpdateRequest($id, $patched_token_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Token' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Token' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Token', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Token';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Token',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersTokensPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  \OpenAPI\Client\Model\PatchedTokenRequest $patched_token_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensPartialUpdateAsync($id, $patched_token_request = null, string $contentType = self::contentTypes['usersTokensPartialUpdate'][0])
    {
        return $this->usersTokensPartialUpdateAsyncWithHttpInfo($id, $patched_token_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersTokensPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  \OpenAPI\Client\Model\PatchedTokenRequest $patched_token_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensPartialUpdateAsyncWithHttpInfo($id, $patched_token_request = null, string $contentType = self::contentTypes['usersTokensPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Token';
        $request = $this->usersTokensPartialUpdateRequest($id, $patched_token_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersTokensPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  \OpenAPI\Client\Model\PatchedTokenRequest $patched_token_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersTokensPartialUpdateRequest($id, $patched_token_request = null, string $contentType = self::contentTypes['usersTokensPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersTokensPartialUpdate'
            );
        }



        $resourcePath = '/api/users/tokens/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_token_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_token_request));
            } else {
                $httpBody = $patched_token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersTokensProvisionCreate
     *
     * @param  \OpenAPI\Client\Model\TokenProvisionRequest $token_provision_request token_provision_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensProvisionCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TokenProvision|array<string,mixed>
     */
    public function usersTokensProvisionCreate($token_provision_request, string $contentType = self::contentTypes['usersTokensProvisionCreate'][0])
    {
        list($response) = $this->usersTokensProvisionCreateWithHttpInfo($token_provision_request, $contentType);
        return $response;
    }

    /**
     * Operation usersTokensProvisionCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TokenProvisionRequest $token_provision_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensProvisionCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TokenProvision|array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersTokensProvisionCreateWithHttpInfo($token_provision_request, string $contentType = self::contentTypes['usersTokensProvisionCreate'][0])
    {
        $request = $this->usersTokensProvisionCreateRequest($token_provision_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\TokenProvision' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TokenProvision' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TokenProvision', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('array<string,mixed>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TokenProvision';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TokenProvision',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersTokensProvisionCreateAsync
     *
     * @param  \OpenAPI\Client\Model\TokenProvisionRequest $token_provision_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensProvisionCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensProvisionCreateAsync($token_provision_request, string $contentType = self::contentTypes['usersTokensProvisionCreate'][0])
    {
        return $this->usersTokensProvisionCreateAsyncWithHttpInfo($token_provision_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersTokensProvisionCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TokenProvisionRequest $token_provision_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensProvisionCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensProvisionCreateAsyncWithHttpInfo($token_provision_request, string $contentType = self::contentTypes['usersTokensProvisionCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TokenProvision';
        $request = $this->usersTokensProvisionCreateRequest($token_provision_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersTokensProvisionCreate'
     *
     * @param  \OpenAPI\Client\Model\TokenProvisionRequest $token_provision_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensProvisionCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersTokensProvisionCreateRequest($token_provision_request, string $contentType = self::contentTypes['usersTokensProvisionCreate'][0])
    {

        // verify the required parameter 'token_provision_request' is set
        if ($token_provision_request === null || (is_array($token_provision_request) && count($token_provision_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_provision_request when calling usersTokensProvisionCreate'
            );
        }


        $resourcePath = '/api/users/tokens/provision/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($token_provision_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($token_provision_request));
            } else {
                $httpBody = $token_provision_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersTokensRetrieve
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Token
     */
    public function usersTokensRetrieve($id, string $contentType = self::contentTypes['usersTokensRetrieve'][0])
    {
        list($response) = $this->usersTokensRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation usersTokensRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Token, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersTokensRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['usersTokensRetrieve'][0])
    {
        $request = $this->usersTokensRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Token' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Token' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Token', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Token';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Token',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersTokensRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensRetrieveAsync($id, string $contentType = self::contentTypes['usersTokensRetrieve'][0])
    {
        return $this->usersTokensRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersTokensRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['usersTokensRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Token';
        $request = $this->usersTokensRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersTokensRetrieve'
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersTokensRetrieveRequest($id, string $contentType = self::contentTypes['usersTokensRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersTokensRetrieve'
            );
        }


        $resourcePath = '/api/users/tokens/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersTokensUpdate
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  \OpenAPI\Client\Model\TokenRequest $token_request token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Token
     */
    public function usersTokensUpdate($id, $token_request, string $contentType = self::contentTypes['usersTokensUpdate'][0])
    {
        list($response) = $this->usersTokensUpdateWithHttpInfo($id, $token_request, $contentType);
        return $response;
    }

    /**
     * Operation usersTokensUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  \OpenAPI\Client\Model\TokenRequest $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Token, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersTokensUpdateWithHttpInfo($id, $token_request, string $contentType = self::contentTypes['usersTokensUpdate'][0])
    {
        $request = $this->usersTokensUpdateRequest($id, $token_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Token' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Token' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Token', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Token';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Token',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersTokensUpdateAsync
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  \OpenAPI\Client\Model\TokenRequest $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensUpdateAsync($id, $token_request, string $contentType = self::contentTypes['usersTokensUpdate'][0])
    {
        return $this->usersTokensUpdateAsyncWithHttpInfo($id, $token_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersTokensUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  \OpenAPI\Client\Model\TokenRequest $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersTokensUpdateAsyncWithHttpInfo($id, $token_request, string $contentType = self::contentTypes['usersTokensUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Token';
        $request = $this->usersTokensUpdateRequest($id, $token_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersTokensUpdate'
     *
     * @param  int $id A unique integer value identifying this token. (required)
     * @param  \OpenAPI\Client\Model\TokenRequest $token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersTokensUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersTokensUpdateRequest($id, $token_request, string $contentType = self::contentTypes['usersTokensUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersTokensUpdate'
            );
        }

        // verify the required parameter 'token_request' is set
        if ($token_request === null || (is_array($token_request) && count($token_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_request when calling usersTokensUpdate'
            );
        }


        $resourcePath = '/api/users/tokens/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($token_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($token_request));
            } else {
                $httpBody = $token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUsersBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersUsersBulkDestroy($user_request, string $contentType = self::contentTypes['usersUsersBulkDestroy'][0])
    {
        $this->usersUsersBulkDestroyWithHttpInfo($user_request, $contentType);
    }

    /**
     * Operation usersUsersBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUsersBulkDestroyWithHttpInfo($user_request, string $contentType = self::contentTypes['usersUsersBulkDestroy'][0])
    {
        $request = $this->usersUsersBulkDestroyRequest($user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersUsersBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersBulkDestroyAsync($user_request, string $contentType = self::contentTypes['usersUsersBulkDestroy'][0])
    {
        return $this->usersUsersBulkDestroyAsyncWithHttpInfo($user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUsersBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersBulkDestroyAsyncWithHttpInfo($user_request, string $contentType = self::contentTypes['usersUsersBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->usersUsersBulkDestroyRequest($user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUsersBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUsersBulkDestroyRequest($user_request, string $contentType = self::contentTypes['usersUsersBulkDestroy'][0])
    {

        // verify the required parameter 'user_request' is set
        if ($user_request === null || (is_array($user_request) && count($user_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_request when calling usersUsersBulkDestroy'
            );
        }


        $resourcePath = '/api/users/users/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_request));
            } else {
                $httpBody = $user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUsersBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\User[]
     */
    public function usersUsersBulkPartialUpdate($user_request, string $contentType = self::contentTypes['usersUsersBulkPartialUpdate'][0])
    {
        list($response) = $this->usersUsersBulkPartialUpdateWithHttpInfo($user_request, $contentType);
        return $response;
    }

    /**
     * Operation usersUsersBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\User[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUsersBulkPartialUpdateWithHttpInfo($user_request, string $contentType = self::contentTypes['usersUsersBulkPartialUpdate'][0])
    {
        $request = $this->usersUsersBulkPartialUpdateRequest($user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\User[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\User[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\User[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\User[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\User[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersUsersBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersBulkPartialUpdateAsync($user_request, string $contentType = self::contentTypes['usersUsersBulkPartialUpdate'][0])
    {
        return $this->usersUsersBulkPartialUpdateAsyncWithHttpInfo($user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUsersBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersBulkPartialUpdateAsyncWithHttpInfo($user_request, string $contentType = self::contentTypes['usersUsersBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\User[]';
        $request = $this->usersUsersBulkPartialUpdateRequest($user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUsersBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUsersBulkPartialUpdateRequest($user_request, string $contentType = self::contentTypes['usersUsersBulkPartialUpdate'][0])
    {

        // verify the required parameter 'user_request' is set
        if ($user_request === null || (is_array($user_request) && count($user_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_request when calling usersUsersBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/users/users/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_request));
            } else {
                $httpBody = $user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUsersBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\User[]
     */
    public function usersUsersBulkUpdate($user_request, string $contentType = self::contentTypes['usersUsersBulkUpdate'][0])
    {
        list($response) = $this->usersUsersBulkUpdateWithHttpInfo($user_request, $contentType);
        return $response;
    }

    /**
     * Operation usersUsersBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\User[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUsersBulkUpdateWithHttpInfo($user_request, string $contentType = self::contentTypes['usersUsersBulkUpdate'][0])
    {
        $request = $this->usersUsersBulkUpdateRequest($user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\User[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\User[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\User[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\User[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\User[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersUsersBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersBulkUpdateAsync($user_request, string $contentType = self::contentTypes['usersUsersBulkUpdate'][0])
    {
        return $this->usersUsersBulkUpdateAsyncWithHttpInfo($user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUsersBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersBulkUpdateAsyncWithHttpInfo($user_request, string $contentType = self::contentTypes['usersUsersBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\User[]';
        $request = $this->usersUsersBulkUpdateRequest($user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUsersBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\UserRequest[] $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUsersBulkUpdateRequest($user_request, string $contentType = self::contentTypes['usersUsersBulkUpdate'][0])
    {

        // verify the required parameter 'user_request' is set
        if ($user_request === null || (is_array($user_request) && count($user_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_request when calling usersUsersBulkUpdate'
            );
        }


        $resourcePath = '/api/users/users/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_request));
            } else {
                $httpBody = $user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUsersCreate
     *
     * @param  \OpenAPI\Client\Model\UserRequest $user_request user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\User
     */
    public function usersUsersCreate($user_request, string $contentType = self::contentTypes['usersUsersCreate'][0])
    {
        list($response) = $this->usersUsersCreateWithHttpInfo($user_request, $contentType);
        return $response;
    }

    /**
     * Operation usersUsersCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\UserRequest $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUsersCreateWithHttpInfo($user_request, string $contentType = self::contentTypes['usersUsersCreate'][0])
    {
        $request = $this->usersUsersCreateRequest($user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\User' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\User' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\User', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\User';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersUsersCreateAsync
     *
     * @param  \OpenAPI\Client\Model\UserRequest $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersCreateAsync($user_request, string $contentType = self::contentTypes['usersUsersCreate'][0])
    {
        return $this->usersUsersCreateAsyncWithHttpInfo($user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUsersCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\UserRequest $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersCreateAsyncWithHttpInfo($user_request, string $contentType = self::contentTypes['usersUsersCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\User';
        $request = $this->usersUsersCreateRequest($user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUsersCreate'
     *
     * @param  \OpenAPI\Client\Model\UserRequest $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUsersCreateRequest($user_request, string $contentType = self::contentTypes['usersUsersCreate'][0])
    {

        // verify the required parameter 'user_request' is set
        if ($user_request === null || (is_array($user_request) && count($user_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_request when calling usersUsersCreate'
            );
        }


        $resourcePath = '/api/users/users/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_request));
            } else {
                $httpBody = $user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUsersDestroy
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersUsersDestroy($id, string $contentType = self::contentTypes['usersUsersDestroy'][0])
    {
        $this->usersUsersDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation usersUsersDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUsersDestroyWithHttpInfo($id, string $contentType = self::contentTypes['usersUsersDestroy'][0])
    {
        $request = $this->usersUsersDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersUsersDestroyAsync
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersDestroyAsync($id, string $contentType = self::contentTypes['usersUsersDestroy'][0])
    {
        return $this->usersUsersDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUsersDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['usersUsersDestroy'][0])
    {
        $returnType = '';
        $request = $this->usersUsersDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUsersDestroy'
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUsersDestroyRequest($id, string $contentType = self::contentTypes['usersUsersDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersUsersDestroy'
            );
        }


        $resourcePath = '/api/users/users/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUsersList
     *
     * @param  \DateTime[] $date_joined date_joined (optional)
     * @param  bool $date_joined__empty date_joined__empty (optional)
     * @param  \DateTime[] $date_joined__gt date_joined__gt (optional)
     * @param  \DateTime[] $date_joined__gte date_joined__gte (optional)
     * @param  \DateTime[] $date_joined__lt date_joined__lt (optional)
     * @param  \DateTime[] $date_joined__lte date_joined__lte (optional)
     * @param  \DateTime[] $date_joined__n date_joined__n (optional)
     * @param  string[] $email email (optional)
     * @param  bool $email__empty email__empty (optional)
     * @param  string[] $email__ic email__ic (optional)
     * @param  string[] $email__ie email__ie (optional)
     * @param  string[] $email__iew email__iew (optional)
     * @param  string[] $email__isw email__isw (optional)
     * @param  string[] $email__n email__n (optional)
     * @param  string[] $email__nic email__nic (optional)
     * @param  string[] $email__nie email__nie (optional)
     * @param  string[] $email__niew email__niew (optional)
     * @param  string[] $email__nisw email__nisw (optional)
     * @param  string[] $first_name first_name (optional)
     * @param  bool $first_name__empty first_name__empty (optional)
     * @param  string[] $first_name__ic first_name__ic (optional)
     * @param  string[] $first_name__ie first_name__ie (optional)
     * @param  string[] $first_name__iew first_name__iew (optional)
     * @param  string[] $first_name__isw first_name__isw (optional)
     * @param  string[] $first_name__n first_name__n (optional)
     * @param  string[] $first_name__nic first_name__nic (optional)
     * @param  string[] $first_name__nie first_name__nie (optional)
     * @param  string[] $first_name__niew first_name__niew (optional)
     * @param  string[] $first_name__nisw first_name__nisw (optional)
     * @param  string[] $group Group (name) (optional)
     * @param  string[] $group__n Group (name) (optional)
     * @param  int[] $group_id Group (optional)
     * @param  int[] $group_id__n Group (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  bool $is_active is_active (optional)
     * @param  bool $is_staff is_staff (optional)
     * @param  bool $is_superuser is_superuser (optional)
     * @param  \DateTime[] $last_login last_login (optional)
     * @param  bool $last_login__empty last_login__empty (optional)
     * @param  \DateTime[] $last_login__gt last_login__gt (optional)
     * @param  \DateTime[] $last_login__gte last_login__gte (optional)
     * @param  \DateTime[] $last_login__lt last_login__lt (optional)
     * @param  \DateTime[] $last_login__lte last_login__lte (optional)
     * @param  \DateTime[] $last_login__n last_login__n (optional)
     * @param  string[] $last_name last_name (optional)
     * @param  bool $last_name__empty last_name__empty (optional)
     * @param  string[] $last_name__ic last_name__ic (optional)
     * @param  string[] $last_name__ie last_name__ie (optional)
     * @param  string[] $last_name__iew last_name__iew (optional)
     * @param  string[] $last_name__isw last_name__isw (optional)
     * @param  string[] $last_name__n last_name__n (optional)
     * @param  string[] $last_name__nic last_name__nic (optional)
     * @param  string[] $last_name__nie last_name__nie (optional)
     * @param  string[] $last_name__niew last_name__niew (optional)
     * @param  string[] $last_name__nisw last_name__nisw (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $notification_group_id Notification group (ID) (optional)
     * @param  int[] $notification_group_id__n Notification group (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $permission_id Permission (ID) (optional)
     * @param  int[] $permission_id__n Permission (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $username username (optional)
     * @param  bool $username__empty username__empty (optional)
     * @param  string[] $username__ic username__ic (optional)
     * @param  string[] $username__ie username__ie (optional)
     * @param  string[] $username__iew username__iew (optional)
     * @param  string[] $username__isw username__isw (optional)
     * @param  string[] $username__n username__n (optional)
     * @param  string[] $username__nic username__nic (optional)
     * @param  string[] $username__nie username__nie (optional)
     * @param  string[] $username__niew username__niew (optional)
     * @param  string[] $username__nisw username__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedUserList
     */
    public function usersUsersList($date_joined = null, $date_joined__empty = null, $date_joined__gt = null, $date_joined__gte = null, $date_joined__lt = null, $date_joined__lte = null, $date_joined__n = null, $email = null, $email__empty = null, $email__ic = null, $email__ie = null, $email__iew = null, $email__isw = null, $email__n = null, $email__nic = null, $email__nie = null, $email__niew = null, $email__nisw = null, $first_name = null, $first_name__empty = null, $first_name__ic = null, $first_name__ie = null, $first_name__iew = null, $first_name__isw = null, $first_name__n = null, $first_name__nic = null, $first_name__nie = null, $first_name__niew = null, $first_name__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_active = null, $is_staff = null, $is_superuser = null, $last_login = null, $last_login__empty = null, $last_login__gt = null, $last_login__gte = null, $last_login__lt = null, $last_login__lte = null, $last_login__n = null, $last_name = null, $last_name__empty = null, $last_name__ic = null, $last_name__ie = null, $last_name__iew = null, $last_name__isw = null, $last_name__n = null, $last_name__nic = null, $last_name__nie = null, $last_name__niew = null, $last_name__nisw = null, $limit = null, $notification_group_id = null, $notification_group_id__n = null, $offset = null, $ordering = null, $permission_id = null, $permission_id__n = null, $q = null, $username = null, $username__empty = null, $username__ic = null, $username__ie = null, $username__iew = null, $username__isw = null, $username__n = null, $username__nic = null, $username__nie = null, $username__niew = null, $username__nisw = null, string $contentType = self::contentTypes['usersUsersList'][0])
    {
        list($response) = $this->usersUsersListWithHttpInfo($date_joined, $date_joined__empty, $date_joined__gt, $date_joined__gte, $date_joined__lt, $date_joined__lte, $date_joined__n, $email, $email__empty, $email__ic, $email__ie, $email__iew, $email__isw, $email__n, $email__nic, $email__nie, $email__niew, $email__nisw, $first_name, $first_name__empty, $first_name__ic, $first_name__ie, $first_name__iew, $first_name__isw, $first_name__n, $first_name__nic, $first_name__nie, $first_name__niew, $first_name__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_active, $is_staff, $is_superuser, $last_login, $last_login__empty, $last_login__gt, $last_login__gte, $last_login__lt, $last_login__lte, $last_login__n, $last_name, $last_name__empty, $last_name__ic, $last_name__ie, $last_name__iew, $last_name__isw, $last_name__n, $last_name__nic, $last_name__nie, $last_name__niew, $last_name__nisw, $limit, $notification_group_id, $notification_group_id__n, $offset, $ordering, $permission_id, $permission_id__n, $q, $username, $username__empty, $username__ic, $username__ie, $username__iew, $username__isw, $username__n, $username__nic, $username__nie, $username__niew, $username__nisw, $contentType);
        return $response;
    }

    /**
     * Operation usersUsersListWithHttpInfo
     *
     * @param  \DateTime[] $date_joined (optional)
     * @param  bool $date_joined__empty (optional)
     * @param  \DateTime[] $date_joined__gt (optional)
     * @param  \DateTime[] $date_joined__gte (optional)
     * @param  \DateTime[] $date_joined__lt (optional)
     * @param  \DateTime[] $date_joined__lte (optional)
     * @param  \DateTime[] $date_joined__n (optional)
     * @param  string[] $email (optional)
     * @param  bool $email__empty (optional)
     * @param  string[] $email__ic (optional)
     * @param  string[] $email__ie (optional)
     * @param  string[] $email__iew (optional)
     * @param  string[] $email__isw (optional)
     * @param  string[] $email__n (optional)
     * @param  string[] $email__nic (optional)
     * @param  string[] $email__nie (optional)
     * @param  string[] $email__niew (optional)
     * @param  string[] $email__nisw (optional)
     * @param  string[] $first_name (optional)
     * @param  bool $first_name__empty (optional)
     * @param  string[] $first_name__ic (optional)
     * @param  string[] $first_name__ie (optional)
     * @param  string[] $first_name__iew (optional)
     * @param  string[] $first_name__isw (optional)
     * @param  string[] $first_name__n (optional)
     * @param  string[] $first_name__nic (optional)
     * @param  string[] $first_name__nie (optional)
     * @param  string[] $first_name__niew (optional)
     * @param  string[] $first_name__nisw (optional)
     * @param  string[] $group Group (name) (optional)
     * @param  string[] $group__n Group (name) (optional)
     * @param  int[] $group_id Group (optional)
     * @param  int[] $group_id__n Group (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_active (optional)
     * @param  bool $is_staff (optional)
     * @param  bool $is_superuser (optional)
     * @param  \DateTime[] $last_login (optional)
     * @param  bool $last_login__empty (optional)
     * @param  \DateTime[] $last_login__gt (optional)
     * @param  \DateTime[] $last_login__gte (optional)
     * @param  \DateTime[] $last_login__lt (optional)
     * @param  \DateTime[] $last_login__lte (optional)
     * @param  \DateTime[] $last_login__n (optional)
     * @param  string[] $last_name (optional)
     * @param  bool $last_name__empty (optional)
     * @param  string[] $last_name__ic (optional)
     * @param  string[] $last_name__ie (optional)
     * @param  string[] $last_name__iew (optional)
     * @param  string[] $last_name__isw (optional)
     * @param  string[] $last_name__n (optional)
     * @param  string[] $last_name__nic (optional)
     * @param  string[] $last_name__nie (optional)
     * @param  string[] $last_name__niew (optional)
     * @param  string[] $last_name__nisw (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $notification_group_id Notification group (ID) (optional)
     * @param  int[] $notification_group_id__n Notification group (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $permission_id Permission (ID) (optional)
     * @param  int[] $permission_id__n Permission (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $username (optional)
     * @param  bool $username__empty (optional)
     * @param  string[] $username__ic (optional)
     * @param  string[] $username__ie (optional)
     * @param  string[] $username__iew (optional)
     * @param  string[] $username__isw (optional)
     * @param  string[] $username__n (optional)
     * @param  string[] $username__nic (optional)
     * @param  string[] $username__nie (optional)
     * @param  string[] $username__niew (optional)
     * @param  string[] $username__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedUserList, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUsersListWithHttpInfo($date_joined = null, $date_joined__empty = null, $date_joined__gt = null, $date_joined__gte = null, $date_joined__lt = null, $date_joined__lte = null, $date_joined__n = null, $email = null, $email__empty = null, $email__ic = null, $email__ie = null, $email__iew = null, $email__isw = null, $email__n = null, $email__nic = null, $email__nie = null, $email__niew = null, $email__nisw = null, $first_name = null, $first_name__empty = null, $first_name__ic = null, $first_name__ie = null, $first_name__iew = null, $first_name__isw = null, $first_name__n = null, $first_name__nic = null, $first_name__nie = null, $first_name__niew = null, $first_name__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_active = null, $is_staff = null, $is_superuser = null, $last_login = null, $last_login__empty = null, $last_login__gt = null, $last_login__gte = null, $last_login__lt = null, $last_login__lte = null, $last_login__n = null, $last_name = null, $last_name__empty = null, $last_name__ic = null, $last_name__ie = null, $last_name__iew = null, $last_name__isw = null, $last_name__n = null, $last_name__nic = null, $last_name__nie = null, $last_name__niew = null, $last_name__nisw = null, $limit = null, $notification_group_id = null, $notification_group_id__n = null, $offset = null, $ordering = null, $permission_id = null, $permission_id__n = null, $q = null, $username = null, $username__empty = null, $username__ic = null, $username__ie = null, $username__iew = null, $username__isw = null, $username__n = null, $username__nic = null, $username__nie = null, $username__niew = null, $username__nisw = null, string $contentType = self::contentTypes['usersUsersList'][0])
    {
        $request = $this->usersUsersListRequest($date_joined, $date_joined__empty, $date_joined__gt, $date_joined__gte, $date_joined__lt, $date_joined__lte, $date_joined__n, $email, $email__empty, $email__ic, $email__ie, $email__iew, $email__isw, $email__n, $email__nic, $email__nie, $email__niew, $email__nisw, $first_name, $first_name__empty, $first_name__ic, $first_name__ie, $first_name__iew, $first_name__isw, $first_name__n, $first_name__nic, $first_name__nie, $first_name__niew, $first_name__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_active, $is_staff, $is_superuser, $last_login, $last_login__empty, $last_login__gt, $last_login__gte, $last_login__lt, $last_login__lte, $last_login__n, $last_name, $last_name__empty, $last_name__ic, $last_name__ie, $last_name__iew, $last_name__isw, $last_name__n, $last_name__nic, $last_name__nie, $last_name__niew, $last_name__nisw, $limit, $notification_group_id, $notification_group_id__n, $offset, $ordering, $permission_id, $permission_id__n, $q, $username, $username__empty, $username__ic, $username__ie, $username__iew, $username__isw, $username__n, $username__nic, $username__nie, $username__niew, $username__nisw, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedUserList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedUserList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedUserList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedUserList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedUserList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersUsersListAsync
     *
     * @param  \DateTime[] $date_joined (optional)
     * @param  bool $date_joined__empty (optional)
     * @param  \DateTime[] $date_joined__gt (optional)
     * @param  \DateTime[] $date_joined__gte (optional)
     * @param  \DateTime[] $date_joined__lt (optional)
     * @param  \DateTime[] $date_joined__lte (optional)
     * @param  \DateTime[] $date_joined__n (optional)
     * @param  string[] $email (optional)
     * @param  bool $email__empty (optional)
     * @param  string[] $email__ic (optional)
     * @param  string[] $email__ie (optional)
     * @param  string[] $email__iew (optional)
     * @param  string[] $email__isw (optional)
     * @param  string[] $email__n (optional)
     * @param  string[] $email__nic (optional)
     * @param  string[] $email__nie (optional)
     * @param  string[] $email__niew (optional)
     * @param  string[] $email__nisw (optional)
     * @param  string[] $first_name (optional)
     * @param  bool $first_name__empty (optional)
     * @param  string[] $first_name__ic (optional)
     * @param  string[] $first_name__ie (optional)
     * @param  string[] $first_name__iew (optional)
     * @param  string[] $first_name__isw (optional)
     * @param  string[] $first_name__n (optional)
     * @param  string[] $first_name__nic (optional)
     * @param  string[] $first_name__nie (optional)
     * @param  string[] $first_name__niew (optional)
     * @param  string[] $first_name__nisw (optional)
     * @param  string[] $group Group (name) (optional)
     * @param  string[] $group__n Group (name) (optional)
     * @param  int[] $group_id Group (optional)
     * @param  int[] $group_id__n Group (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_active (optional)
     * @param  bool $is_staff (optional)
     * @param  bool $is_superuser (optional)
     * @param  \DateTime[] $last_login (optional)
     * @param  bool $last_login__empty (optional)
     * @param  \DateTime[] $last_login__gt (optional)
     * @param  \DateTime[] $last_login__gte (optional)
     * @param  \DateTime[] $last_login__lt (optional)
     * @param  \DateTime[] $last_login__lte (optional)
     * @param  \DateTime[] $last_login__n (optional)
     * @param  string[] $last_name (optional)
     * @param  bool $last_name__empty (optional)
     * @param  string[] $last_name__ic (optional)
     * @param  string[] $last_name__ie (optional)
     * @param  string[] $last_name__iew (optional)
     * @param  string[] $last_name__isw (optional)
     * @param  string[] $last_name__n (optional)
     * @param  string[] $last_name__nic (optional)
     * @param  string[] $last_name__nie (optional)
     * @param  string[] $last_name__niew (optional)
     * @param  string[] $last_name__nisw (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $notification_group_id Notification group (ID) (optional)
     * @param  int[] $notification_group_id__n Notification group (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $permission_id Permission (ID) (optional)
     * @param  int[] $permission_id__n Permission (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $username (optional)
     * @param  bool $username__empty (optional)
     * @param  string[] $username__ic (optional)
     * @param  string[] $username__ie (optional)
     * @param  string[] $username__iew (optional)
     * @param  string[] $username__isw (optional)
     * @param  string[] $username__n (optional)
     * @param  string[] $username__nic (optional)
     * @param  string[] $username__nie (optional)
     * @param  string[] $username__niew (optional)
     * @param  string[] $username__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersListAsync($date_joined = null, $date_joined__empty = null, $date_joined__gt = null, $date_joined__gte = null, $date_joined__lt = null, $date_joined__lte = null, $date_joined__n = null, $email = null, $email__empty = null, $email__ic = null, $email__ie = null, $email__iew = null, $email__isw = null, $email__n = null, $email__nic = null, $email__nie = null, $email__niew = null, $email__nisw = null, $first_name = null, $first_name__empty = null, $first_name__ic = null, $first_name__ie = null, $first_name__iew = null, $first_name__isw = null, $first_name__n = null, $first_name__nic = null, $first_name__nie = null, $first_name__niew = null, $first_name__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_active = null, $is_staff = null, $is_superuser = null, $last_login = null, $last_login__empty = null, $last_login__gt = null, $last_login__gte = null, $last_login__lt = null, $last_login__lte = null, $last_login__n = null, $last_name = null, $last_name__empty = null, $last_name__ic = null, $last_name__ie = null, $last_name__iew = null, $last_name__isw = null, $last_name__n = null, $last_name__nic = null, $last_name__nie = null, $last_name__niew = null, $last_name__nisw = null, $limit = null, $notification_group_id = null, $notification_group_id__n = null, $offset = null, $ordering = null, $permission_id = null, $permission_id__n = null, $q = null, $username = null, $username__empty = null, $username__ic = null, $username__ie = null, $username__iew = null, $username__isw = null, $username__n = null, $username__nic = null, $username__nie = null, $username__niew = null, $username__nisw = null, string $contentType = self::contentTypes['usersUsersList'][0])
    {
        return $this->usersUsersListAsyncWithHttpInfo($date_joined, $date_joined__empty, $date_joined__gt, $date_joined__gte, $date_joined__lt, $date_joined__lte, $date_joined__n, $email, $email__empty, $email__ic, $email__ie, $email__iew, $email__isw, $email__n, $email__nic, $email__nie, $email__niew, $email__nisw, $first_name, $first_name__empty, $first_name__ic, $first_name__ie, $first_name__iew, $first_name__isw, $first_name__n, $first_name__nic, $first_name__nie, $first_name__niew, $first_name__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_active, $is_staff, $is_superuser, $last_login, $last_login__empty, $last_login__gt, $last_login__gte, $last_login__lt, $last_login__lte, $last_login__n, $last_name, $last_name__empty, $last_name__ic, $last_name__ie, $last_name__iew, $last_name__isw, $last_name__n, $last_name__nic, $last_name__nie, $last_name__niew, $last_name__nisw, $limit, $notification_group_id, $notification_group_id__n, $offset, $ordering, $permission_id, $permission_id__n, $q, $username, $username__empty, $username__ic, $username__ie, $username__iew, $username__isw, $username__n, $username__nic, $username__nie, $username__niew, $username__nisw, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUsersListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $date_joined (optional)
     * @param  bool $date_joined__empty (optional)
     * @param  \DateTime[] $date_joined__gt (optional)
     * @param  \DateTime[] $date_joined__gte (optional)
     * @param  \DateTime[] $date_joined__lt (optional)
     * @param  \DateTime[] $date_joined__lte (optional)
     * @param  \DateTime[] $date_joined__n (optional)
     * @param  string[] $email (optional)
     * @param  bool $email__empty (optional)
     * @param  string[] $email__ic (optional)
     * @param  string[] $email__ie (optional)
     * @param  string[] $email__iew (optional)
     * @param  string[] $email__isw (optional)
     * @param  string[] $email__n (optional)
     * @param  string[] $email__nic (optional)
     * @param  string[] $email__nie (optional)
     * @param  string[] $email__niew (optional)
     * @param  string[] $email__nisw (optional)
     * @param  string[] $first_name (optional)
     * @param  bool $first_name__empty (optional)
     * @param  string[] $first_name__ic (optional)
     * @param  string[] $first_name__ie (optional)
     * @param  string[] $first_name__iew (optional)
     * @param  string[] $first_name__isw (optional)
     * @param  string[] $first_name__n (optional)
     * @param  string[] $first_name__nic (optional)
     * @param  string[] $first_name__nie (optional)
     * @param  string[] $first_name__niew (optional)
     * @param  string[] $first_name__nisw (optional)
     * @param  string[] $group Group (name) (optional)
     * @param  string[] $group__n Group (name) (optional)
     * @param  int[] $group_id Group (optional)
     * @param  int[] $group_id__n Group (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_active (optional)
     * @param  bool $is_staff (optional)
     * @param  bool $is_superuser (optional)
     * @param  \DateTime[] $last_login (optional)
     * @param  bool $last_login__empty (optional)
     * @param  \DateTime[] $last_login__gt (optional)
     * @param  \DateTime[] $last_login__gte (optional)
     * @param  \DateTime[] $last_login__lt (optional)
     * @param  \DateTime[] $last_login__lte (optional)
     * @param  \DateTime[] $last_login__n (optional)
     * @param  string[] $last_name (optional)
     * @param  bool $last_name__empty (optional)
     * @param  string[] $last_name__ic (optional)
     * @param  string[] $last_name__ie (optional)
     * @param  string[] $last_name__iew (optional)
     * @param  string[] $last_name__isw (optional)
     * @param  string[] $last_name__n (optional)
     * @param  string[] $last_name__nic (optional)
     * @param  string[] $last_name__nie (optional)
     * @param  string[] $last_name__niew (optional)
     * @param  string[] $last_name__nisw (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $notification_group_id Notification group (ID) (optional)
     * @param  int[] $notification_group_id__n Notification group (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $permission_id Permission (ID) (optional)
     * @param  int[] $permission_id__n Permission (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $username (optional)
     * @param  bool $username__empty (optional)
     * @param  string[] $username__ic (optional)
     * @param  string[] $username__ie (optional)
     * @param  string[] $username__iew (optional)
     * @param  string[] $username__isw (optional)
     * @param  string[] $username__n (optional)
     * @param  string[] $username__nic (optional)
     * @param  string[] $username__nie (optional)
     * @param  string[] $username__niew (optional)
     * @param  string[] $username__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersListAsyncWithHttpInfo($date_joined = null, $date_joined__empty = null, $date_joined__gt = null, $date_joined__gte = null, $date_joined__lt = null, $date_joined__lte = null, $date_joined__n = null, $email = null, $email__empty = null, $email__ic = null, $email__ie = null, $email__iew = null, $email__isw = null, $email__n = null, $email__nic = null, $email__nie = null, $email__niew = null, $email__nisw = null, $first_name = null, $first_name__empty = null, $first_name__ic = null, $first_name__ie = null, $first_name__iew = null, $first_name__isw = null, $first_name__n = null, $first_name__nic = null, $first_name__nie = null, $first_name__niew = null, $first_name__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_active = null, $is_staff = null, $is_superuser = null, $last_login = null, $last_login__empty = null, $last_login__gt = null, $last_login__gte = null, $last_login__lt = null, $last_login__lte = null, $last_login__n = null, $last_name = null, $last_name__empty = null, $last_name__ic = null, $last_name__ie = null, $last_name__iew = null, $last_name__isw = null, $last_name__n = null, $last_name__nic = null, $last_name__nie = null, $last_name__niew = null, $last_name__nisw = null, $limit = null, $notification_group_id = null, $notification_group_id__n = null, $offset = null, $ordering = null, $permission_id = null, $permission_id__n = null, $q = null, $username = null, $username__empty = null, $username__ic = null, $username__ie = null, $username__iew = null, $username__isw = null, $username__n = null, $username__nic = null, $username__nie = null, $username__niew = null, $username__nisw = null, string $contentType = self::contentTypes['usersUsersList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedUserList';
        $request = $this->usersUsersListRequest($date_joined, $date_joined__empty, $date_joined__gt, $date_joined__gte, $date_joined__lt, $date_joined__lte, $date_joined__n, $email, $email__empty, $email__ic, $email__ie, $email__iew, $email__isw, $email__n, $email__nic, $email__nie, $email__niew, $email__nisw, $first_name, $first_name__empty, $first_name__ic, $first_name__ie, $first_name__iew, $first_name__isw, $first_name__n, $first_name__nic, $first_name__nie, $first_name__niew, $first_name__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_active, $is_staff, $is_superuser, $last_login, $last_login__empty, $last_login__gt, $last_login__gte, $last_login__lt, $last_login__lte, $last_login__n, $last_name, $last_name__empty, $last_name__ic, $last_name__ie, $last_name__iew, $last_name__isw, $last_name__n, $last_name__nic, $last_name__nie, $last_name__niew, $last_name__nisw, $limit, $notification_group_id, $notification_group_id__n, $offset, $ordering, $permission_id, $permission_id__n, $q, $username, $username__empty, $username__ic, $username__ie, $username__iew, $username__isw, $username__n, $username__nic, $username__nie, $username__niew, $username__nisw, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUsersList'
     *
     * @param  \DateTime[] $date_joined (optional)
     * @param  bool $date_joined__empty (optional)
     * @param  \DateTime[] $date_joined__gt (optional)
     * @param  \DateTime[] $date_joined__gte (optional)
     * @param  \DateTime[] $date_joined__lt (optional)
     * @param  \DateTime[] $date_joined__lte (optional)
     * @param  \DateTime[] $date_joined__n (optional)
     * @param  string[] $email (optional)
     * @param  bool $email__empty (optional)
     * @param  string[] $email__ic (optional)
     * @param  string[] $email__ie (optional)
     * @param  string[] $email__iew (optional)
     * @param  string[] $email__isw (optional)
     * @param  string[] $email__n (optional)
     * @param  string[] $email__nic (optional)
     * @param  string[] $email__nie (optional)
     * @param  string[] $email__niew (optional)
     * @param  string[] $email__nisw (optional)
     * @param  string[] $first_name (optional)
     * @param  bool $first_name__empty (optional)
     * @param  string[] $first_name__ic (optional)
     * @param  string[] $first_name__ie (optional)
     * @param  string[] $first_name__iew (optional)
     * @param  string[] $first_name__isw (optional)
     * @param  string[] $first_name__n (optional)
     * @param  string[] $first_name__nic (optional)
     * @param  string[] $first_name__nie (optional)
     * @param  string[] $first_name__niew (optional)
     * @param  string[] $first_name__nisw (optional)
     * @param  string[] $group Group (name) (optional)
     * @param  string[] $group__n Group (name) (optional)
     * @param  int[] $group_id Group (optional)
     * @param  int[] $group_id__n Group (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_active (optional)
     * @param  bool $is_staff (optional)
     * @param  bool $is_superuser (optional)
     * @param  \DateTime[] $last_login (optional)
     * @param  bool $last_login__empty (optional)
     * @param  \DateTime[] $last_login__gt (optional)
     * @param  \DateTime[] $last_login__gte (optional)
     * @param  \DateTime[] $last_login__lt (optional)
     * @param  \DateTime[] $last_login__lte (optional)
     * @param  \DateTime[] $last_login__n (optional)
     * @param  string[] $last_name (optional)
     * @param  bool $last_name__empty (optional)
     * @param  string[] $last_name__ic (optional)
     * @param  string[] $last_name__ie (optional)
     * @param  string[] $last_name__iew (optional)
     * @param  string[] $last_name__isw (optional)
     * @param  string[] $last_name__n (optional)
     * @param  string[] $last_name__nic (optional)
     * @param  string[] $last_name__nie (optional)
     * @param  string[] $last_name__niew (optional)
     * @param  string[] $last_name__nisw (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $notification_group_id Notification group (ID) (optional)
     * @param  int[] $notification_group_id__n Notification group (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $permission_id Permission (ID) (optional)
     * @param  int[] $permission_id__n Permission (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $username (optional)
     * @param  bool $username__empty (optional)
     * @param  string[] $username__ic (optional)
     * @param  string[] $username__ie (optional)
     * @param  string[] $username__iew (optional)
     * @param  string[] $username__isw (optional)
     * @param  string[] $username__n (optional)
     * @param  string[] $username__nic (optional)
     * @param  string[] $username__nie (optional)
     * @param  string[] $username__niew (optional)
     * @param  string[] $username__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUsersListRequest($date_joined = null, $date_joined__empty = null, $date_joined__gt = null, $date_joined__gte = null, $date_joined__lt = null, $date_joined__lte = null, $date_joined__n = null, $email = null, $email__empty = null, $email__ic = null, $email__ie = null, $email__iew = null, $email__isw = null, $email__n = null, $email__nic = null, $email__nie = null, $email__niew = null, $email__nisw = null, $first_name = null, $first_name__empty = null, $first_name__ic = null, $first_name__ie = null, $first_name__iew = null, $first_name__isw = null, $first_name__n = null, $first_name__nic = null, $first_name__nie = null, $first_name__niew = null, $first_name__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_active = null, $is_staff = null, $is_superuser = null, $last_login = null, $last_login__empty = null, $last_login__gt = null, $last_login__gte = null, $last_login__lt = null, $last_login__lte = null, $last_login__n = null, $last_name = null, $last_name__empty = null, $last_name__ic = null, $last_name__ie = null, $last_name__iew = null, $last_name__isw = null, $last_name__n = null, $last_name__nic = null, $last_name__nie = null, $last_name__niew = null, $last_name__nisw = null, $limit = null, $notification_group_id = null, $notification_group_id__n = null, $offset = null, $ordering = null, $permission_id = null, $permission_id__n = null, $q = null, $username = null, $username__empty = null, $username__ic = null, $username__ie = null, $username__iew = null, $username__isw = null, $username__n = null, $username__nic = null, $username__nie = null, $username__niew = null, $username__nisw = null, string $contentType = self::contentTypes['usersUsersList'][0])
    {


















































































        $resourcePath = '/api/users/users/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_joined,
            'date_joined', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_joined__empty,
            'date_joined__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_joined__gt,
            'date_joined__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_joined__gte,
            'date_joined__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_joined__lt,
            'date_joined__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_joined__lte,
            'date_joined__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_joined__n,
            'date_joined__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email__empty,
            'email__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email__ic,
            'email__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email__ie,
            'email__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email__iew,
            'email__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email__isw,
            'email__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email__n,
            'email__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email__nic,
            'email__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email__nie,
            'email__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email__niew,
            'email__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email__nisw,
            'email__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name,
            'first_name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name__empty,
            'first_name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name__ic,
            'first_name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name__ie,
            'first_name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name__iew,
            'first_name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name__isw,
            'first_name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name__n,
            'first_name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name__nic,
            'first_name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name__nie,
            'first_name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name__niew,
            'first_name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name__nisw,
            'first_name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group,
            'group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group__n,
            'group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id,
            'group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__n,
            'group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_active,
            'is_active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_staff,
            'is_staff', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_superuser,
            'is_superuser', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_login,
            'last_login', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_login__empty,
            'last_login__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_login__gt,
            'last_login__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_login__gte,
            'last_login__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_login__lt,
            'last_login__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_login__lte,
            'last_login__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_login__n,
            'last_login__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name,
            'last_name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name__empty,
            'last_name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name__ic,
            'last_name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name__ie,
            'last_name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name__iew,
            'last_name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name__isw,
            'last_name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name__n,
            'last_name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name__nic,
            'last_name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name__nie,
            'last_name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name__niew,
            'last_name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name__nisw,
            'last_name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $notification_group_id,
            'notification_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $notification_group_id__n,
            'notification_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permission_id,
            'permission_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permission_id__n,
            'permission_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username,
            'username', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username__empty,
            'username__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username__ic,
            'username__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username__ie,
            'username__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username__iew,
            'username__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username__isw,
            'username__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username__n,
            'username__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username__nic,
            'username__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username__nie,
            'username__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username__niew,
            'username__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username__nisw,
            'username__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUsersPartialUpdate
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  \OpenAPI\Client\Model\PatchedUserRequest $patched_user_request patched_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\User
     */
    public function usersUsersPartialUpdate($id, $patched_user_request = null, string $contentType = self::contentTypes['usersUsersPartialUpdate'][0])
    {
        list($response) = $this->usersUsersPartialUpdateWithHttpInfo($id, $patched_user_request, $contentType);
        return $response;
    }

    /**
     * Operation usersUsersPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  \OpenAPI\Client\Model\PatchedUserRequest $patched_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUsersPartialUpdateWithHttpInfo($id, $patched_user_request = null, string $contentType = self::contentTypes['usersUsersPartialUpdate'][0])
    {
        $request = $this->usersUsersPartialUpdateRequest($id, $patched_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\User' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\User' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\User', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\User';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersUsersPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  \OpenAPI\Client\Model\PatchedUserRequest $patched_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersPartialUpdateAsync($id, $patched_user_request = null, string $contentType = self::contentTypes['usersUsersPartialUpdate'][0])
    {
        return $this->usersUsersPartialUpdateAsyncWithHttpInfo($id, $patched_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUsersPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  \OpenAPI\Client\Model\PatchedUserRequest $patched_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersPartialUpdateAsyncWithHttpInfo($id, $patched_user_request = null, string $contentType = self::contentTypes['usersUsersPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\User';
        $request = $this->usersUsersPartialUpdateRequest($id, $patched_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUsersPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  \OpenAPI\Client\Model\PatchedUserRequest $patched_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUsersPartialUpdateRequest($id, $patched_user_request = null, string $contentType = self::contentTypes['usersUsersPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersUsersPartialUpdate'
            );
        }



        $resourcePath = '/api/users/users/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_user_request));
            } else {
                $httpBody = $patched_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUsersRetrieve
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\User
     */
    public function usersUsersRetrieve($id, string $contentType = self::contentTypes['usersUsersRetrieve'][0])
    {
        list($response) = $this->usersUsersRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation usersUsersRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUsersRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['usersUsersRetrieve'][0])
    {
        $request = $this->usersUsersRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\User' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\User' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\User', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\User';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersUsersRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersRetrieveAsync($id, string $contentType = self::contentTypes['usersUsersRetrieve'][0])
    {
        return $this->usersUsersRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUsersRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['usersUsersRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\User';
        $request = $this->usersUsersRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUsersRetrieve'
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUsersRetrieveRequest($id, string $contentType = self::contentTypes['usersUsersRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersUsersRetrieve'
            );
        }


        $resourcePath = '/api/users/users/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUsersUpdate
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  \OpenAPI\Client\Model\UserRequest $user_request user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\User
     */
    public function usersUsersUpdate($id, $user_request, string $contentType = self::contentTypes['usersUsersUpdate'][0])
    {
        list($response) = $this->usersUsersUpdateWithHttpInfo($id, $user_request, $contentType);
        return $response;
    }

    /**
     * Operation usersUsersUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  \OpenAPI\Client\Model\UserRequest $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUsersUpdateWithHttpInfo($id, $user_request, string $contentType = self::contentTypes['usersUsersUpdate'][0])
    {
        $request = $this->usersUsersUpdateRequest($id, $user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\User' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\User' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\User', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\User';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersUsersUpdateAsync
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  \OpenAPI\Client\Model\UserRequest $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersUpdateAsync($id, $user_request, string $contentType = self::contentTypes['usersUsersUpdate'][0])
    {
        return $this->usersUsersUpdateAsyncWithHttpInfo($id, $user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUsersUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  \OpenAPI\Client\Model\UserRequest $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUsersUpdateAsyncWithHttpInfo($id, $user_request, string $contentType = self::contentTypes['usersUsersUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\User';
        $request = $this->usersUsersUpdateRequest($id, $user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUsersUpdate'
     *
     * @param  int $id A unique integer value identifying this user. (required)
     * @param  \OpenAPI\Client\Model\UserRequest $user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUsersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUsersUpdateRequest($id, $user_request, string $contentType = self::contentTypes['usersUsersUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersUsersUpdate'
            );
        }

        // verify the required parameter 'user_request' is set
        if ($user_request === null || (is_array($user_request) && count($user_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_request when calling usersUsersUpdate'
            );
        }


        $resourcePath = '/api/users/users/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_request));
            } else {
                $httpBody = $user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
