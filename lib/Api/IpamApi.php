<?php
/**
 * IpamApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NetBox REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0.8 (4.0)
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.8.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * IpamApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class IpamApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'ipamAggregatesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAggregatesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAggregatesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAggregatesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAggregatesDestroy' => [
            'application/json',
        ],
        'ipamAggregatesList' => [
            'application/json',
        ],
        'ipamAggregatesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAggregatesRetrieve' => [
            'application/json',
        ],
        'ipamAggregatesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnRangesAvailableAsnsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnRangesAvailableAsnsList' => [
            'application/json',
        ],
        'ipamAsnRangesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnRangesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnRangesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnRangesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnRangesDestroy' => [
            'application/json',
        ],
        'ipamAsnRangesList' => [
            'application/json',
        ],
        'ipamAsnRangesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnRangesRetrieve' => [
            'application/json',
        ],
        'ipamAsnRangesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnsDestroy' => [
            'application/json',
        ],
        'ipamAsnsList' => [
            'application/json',
        ],
        'ipamAsnsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamAsnsRetrieve' => [
            'application/json',
        ],
        'ipamAsnsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupAssignmentsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupAssignmentsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupAssignmentsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupAssignmentsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupAssignmentsDestroy' => [
            'application/json',
        ],
        'ipamFhrpGroupAssignmentsList' => [
            'application/json',
        ],
        'ipamFhrpGroupAssignmentsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupAssignmentsRetrieve' => [
            'application/json',
        ],
        'ipamFhrpGroupAssignmentsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupsDestroy' => [
            'application/json',
        ],
        'ipamFhrpGroupsList' => [
            'application/json',
        ],
        'ipamFhrpGroupsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamFhrpGroupsRetrieve' => [
            'application/json',
        ],
        'ipamFhrpGroupsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpAddressesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpAddressesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpAddressesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpAddressesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpAddressesDestroy' => [
            'application/json',
        ],
        'ipamIpAddressesList' => [
            'application/json',
        ],
        'ipamIpAddressesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpAddressesRetrieve' => [
            'application/json',
        ],
        'ipamIpAddressesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpRangesAvailableIpsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpRangesAvailableIpsList' => [
            'application/json',
        ],
        'ipamIpRangesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpRangesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpRangesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpRangesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpRangesDestroy' => [
            'application/json',
        ],
        'ipamIpRangesList' => [
            'application/json',
        ],
        'ipamIpRangesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamIpRangesRetrieve' => [
            'application/json',
        ],
        'ipamIpRangesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamPrefixesAvailableIpsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamPrefixesAvailableIpsList' => [
            'application/json',
        ],
        'ipamPrefixesAvailablePrefixesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamPrefixesAvailablePrefixesList' => [
            'application/json',
        ],
        'ipamPrefixesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamPrefixesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamPrefixesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamPrefixesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamPrefixesDestroy' => [
            'application/json',
        ],
        'ipamPrefixesList' => [
            'application/json',
        ],
        'ipamPrefixesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamPrefixesRetrieve' => [
            'application/json',
        ],
        'ipamPrefixesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRirsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRirsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRirsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRirsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRirsDestroy' => [
            'application/json',
        ],
        'ipamRirsList' => [
            'application/json',
        ],
        'ipamRirsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRirsRetrieve' => [
            'application/json',
        ],
        'ipamRirsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRolesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRolesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRolesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRolesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRolesDestroy' => [
            'application/json',
        ],
        'ipamRolesList' => [
            'application/json',
        ],
        'ipamRolesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRolesRetrieve' => [
            'application/json',
        ],
        'ipamRolesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRouteTargetsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRouteTargetsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRouteTargetsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRouteTargetsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRouteTargetsDestroy' => [
            'application/json',
        ],
        'ipamRouteTargetsList' => [
            'application/json',
        ],
        'ipamRouteTargetsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamRouteTargetsRetrieve' => [
            'application/json',
        ],
        'ipamRouteTargetsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServiceTemplatesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServiceTemplatesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServiceTemplatesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServiceTemplatesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServiceTemplatesDestroy' => [
            'application/json',
        ],
        'ipamServiceTemplatesList' => [
            'application/json',
        ],
        'ipamServiceTemplatesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServiceTemplatesRetrieve' => [
            'application/json',
        ],
        'ipamServiceTemplatesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServicesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServicesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServicesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServicesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServicesDestroy' => [
            'application/json',
        ],
        'ipamServicesList' => [
            'application/json',
        ],
        'ipamServicesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamServicesRetrieve' => [
            'application/json',
        ],
        'ipamServicesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlanGroupsAvailableVlansCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlanGroupsAvailableVlansList' => [
            'application/json',
        ],
        'ipamVlanGroupsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlanGroupsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlanGroupsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlanGroupsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlanGroupsDestroy' => [
            'application/json',
        ],
        'ipamVlanGroupsList' => [
            'application/json',
        ],
        'ipamVlanGroupsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlanGroupsRetrieve' => [
            'application/json',
        ],
        'ipamVlanGroupsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlansBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlansBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlansBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlansCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlansDestroy' => [
            'application/json',
        ],
        'ipamVlansList' => [
            'application/json',
        ],
        'ipamVlansPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVlansRetrieve' => [
            'application/json',
        ],
        'ipamVlansUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVrfsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVrfsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVrfsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVrfsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVrfsDestroy' => [
            'application/json',
        ],
        'ipamVrfsList' => [
            'application/json',
        ],
        'ipamVrfsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'ipamVrfsRetrieve' => [
            'application/json',
        ],
        'ipamVrfsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation ipamAggregatesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamAggregatesBulkDestroy($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkDestroy'][0])
    {
        $this->ipamAggregatesBulkDestroyWithHttpInfo($aggregate_request, $contentType);
    }

    /**
     * Operation ipamAggregatesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAggregatesBulkDestroyWithHttpInfo($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkDestroy'][0])
    {
        $request = $this->ipamAggregatesBulkDestroyRequest($aggregate_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAggregatesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesBulkDestroyAsync($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkDestroy'][0])
    {
        return $this->ipamAggregatesBulkDestroyAsyncWithHttpInfo($aggregate_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAggregatesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesBulkDestroyAsyncWithHttpInfo($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamAggregatesBulkDestroyRequest($aggregate_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAggregatesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAggregatesBulkDestroyRequest($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkDestroy'][0])
    {

        // verify the required parameter 'aggregate_request' is set
        if ($aggregate_request === null || (is_array($aggregate_request) && count($aggregate_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $aggregate_request when calling ipamAggregatesBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/aggregates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($aggregate_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($aggregate_request));
            } else {
                $httpBody = $aggregate_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAggregatesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Aggregate[]
     */
    public function ipamAggregatesBulkPartialUpdate($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamAggregatesBulkPartialUpdateWithHttpInfo($aggregate_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAggregatesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Aggregate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAggregatesBulkPartialUpdateWithHttpInfo($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkPartialUpdate'][0])
    {
        $request = $this->ipamAggregatesBulkPartialUpdateRequest($aggregate_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Aggregate[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Aggregate[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Aggregate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Aggregate[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Aggregate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAggregatesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesBulkPartialUpdateAsync($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkPartialUpdate'][0])
    {
        return $this->ipamAggregatesBulkPartialUpdateAsyncWithHttpInfo($aggregate_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAggregatesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesBulkPartialUpdateAsyncWithHttpInfo($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Aggregate[]';
        $request = $this->ipamAggregatesBulkPartialUpdateRequest($aggregate_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAggregatesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAggregatesBulkPartialUpdateRequest($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'aggregate_request' is set
        if ($aggregate_request === null || (is_array($aggregate_request) && count($aggregate_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $aggregate_request when calling ipamAggregatesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/aggregates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($aggregate_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($aggregate_request));
            } else {
                $httpBody = $aggregate_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAggregatesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Aggregate[]
     */
    public function ipamAggregatesBulkUpdate($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkUpdate'][0])
    {
        list($response) = $this->ipamAggregatesBulkUpdateWithHttpInfo($aggregate_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAggregatesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Aggregate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAggregatesBulkUpdateWithHttpInfo($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkUpdate'][0])
    {
        $request = $this->ipamAggregatesBulkUpdateRequest($aggregate_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Aggregate[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Aggregate[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Aggregate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Aggregate[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Aggregate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAggregatesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesBulkUpdateAsync($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkUpdate'][0])
    {
        return $this->ipamAggregatesBulkUpdateAsyncWithHttpInfo($aggregate_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAggregatesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesBulkUpdateAsyncWithHttpInfo($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Aggregate[]';
        $request = $this->ipamAggregatesBulkUpdateRequest($aggregate_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAggregatesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\AggregateRequest[] $aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAggregatesBulkUpdateRequest($aggregate_request, string $contentType = self::contentTypes['ipamAggregatesBulkUpdate'][0])
    {

        // verify the required parameter 'aggregate_request' is set
        if ($aggregate_request === null || (is_array($aggregate_request) && count($aggregate_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $aggregate_request when calling ipamAggregatesBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/aggregates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($aggregate_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($aggregate_request));
            } else {
                $httpBody = $aggregate_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAggregatesCreate
     *
     * @param  \OpenAPI\Client\Model\WritableAggregateRequest $writable_aggregate_request writable_aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Aggregate
     */
    public function ipamAggregatesCreate($writable_aggregate_request, string $contentType = self::contentTypes['ipamAggregatesCreate'][0])
    {
        list($response) = $this->ipamAggregatesCreateWithHttpInfo($writable_aggregate_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAggregatesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableAggregateRequest $writable_aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Aggregate, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAggregatesCreateWithHttpInfo($writable_aggregate_request, string $contentType = self::contentTypes['ipamAggregatesCreate'][0])
    {
        $request = $this->ipamAggregatesCreateRequest($writable_aggregate_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Aggregate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Aggregate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Aggregate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Aggregate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Aggregate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAggregatesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableAggregateRequest $writable_aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesCreateAsync($writable_aggregate_request, string $contentType = self::contentTypes['ipamAggregatesCreate'][0])
    {
        return $this->ipamAggregatesCreateAsyncWithHttpInfo($writable_aggregate_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAggregatesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableAggregateRequest $writable_aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesCreateAsyncWithHttpInfo($writable_aggregate_request, string $contentType = self::contentTypes['ipamAggregatesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Aggregate';
        $request = $this->ipamAggregatesCreateRequest($writable_aggregate_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAggregatesCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableAggregateRequest $writable_aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAggregatesCreateRequest($writable_aggregate_request, string $contentType = self::contentTypes['ipamAggregatesCreate'][0])
    {

        // verify the required parameter 'writable_aggregate_request' is set
        if ($writable_aggregate_request === null || (is_array($writable_aggregate_request) && count($writable_aggregate_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_aggregate_request when calling ipamAggregatesCreate'
            );
        }


        $resourcePath = '/api/ipam/aggregates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_aggregate_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_aggregate_request));
            } else {
                $httpBody = $writable_aggregate_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAggregatesDestroy
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamAggregatesDestroy($id, string $contentType = self::contentTypes['ipamAggregatesDestroy'][0])
    {
        $this->ipamAggregatesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamAggregatesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAggregatesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamAggregatesDestroy'][0])
    {
        $request = $this->ipamAggregatesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAggregatesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesDestroyAsync($id, string $contentType = self::contentTypes['ipamAggregatesDestroy'][0])
    {
        return $this->ipamAggregatesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAggregatesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamAggregatesDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamAggregatesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAggregatesDestroy'
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAggregatesDestroyRequest($id, string $contentType = self::contentTypes['ipamAggregatesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAggregatesDestroy'
            );
        }


        $resourcePath = '/api/ipam/aggregates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAggregatesList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  \DateTime[] $date_added date_added (optional)
     * @param  bool $date_added__empty date_added__empty (optional)
     * @param  \DateTime[] $date_added__gt date_added__gt (optional)
     * @param  \DateTime[] $date_added__gte date_added__gte (optional)
     * @param  \DateTime[] $date_added__lt date_added__lt (optional)
     * @param  \DateTime[] $date_added__lte date_added__lte (optional)
     * @param  \DateTime[] $date_added__n date_added__n (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  float $family family (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $prefix Prefix (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedAggregateList
     */
    public function ipamAggregatesList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $date_added = null, $date_added__empty = null, $date_added__gt = null, $date_added__gte = null, $date_added__lt = null, $date_added__lte = null, $date_added__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $prefix = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAggregatesList'][0])
    {
        list($response) = $this->ipamAggregatesListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $date_added, $date_added__empty, $date_added__gt, $date_added__gte, $date_added__lt, $date_added__lte, $date_added__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $prefix, $q, $rir, $rir__n, $rir_id, $rir_id__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAggregatesListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  \DateTime[] $date_added (optional)
     * @param  bool $date_added__empty (optional)
     * @param  \DateTime[] $date_added__gt (optional)
     * @param  \DateTime[] $date_added__gte (optional)
     * @param  \DateTime[] $date_added__lt (optional)
     * @param  \DateTime[] $date_added__lte (optional)
     * @param  \DateTime[] $date_added__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $prefix Prefix (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedAggregateList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAggregatesListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $date_added = null, $date_added__empty = null, $date_added__gt = null, $date_added__gte = null, $date_added__lt = null, $date_added__lte = null, $date_added__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $prefix = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAggregatesList'][0])
    {
        $request = $this->ipamAggregatesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $date_added, $date_added__empty, $date_added__gt, $date_added__gte, $date_added__lt, $date_added__lte, $date_added__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $prefix, $q, $rir, $rir__n, $rir_id, $rir_id__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedAggregateList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedAggregateList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedAggregateList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedAggregateList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedAggregateList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAggregatesListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  \DateTime[] $date_added (optional)
     * @param  bool $date_added__empty (optional)
     * @param  \DateTime[] $date_added__gt (optional)
     * @param  \DateTime[] $date_added__gte (optional)
     * @param  \DateTime[] $date_added__lt (optional)
     * @param  \DateTime[] $date_added__lte (optional)
     * @param  \DateTime[] $date_added__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $prefix Prefix (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $date_added = null, $date_added__empty = null, $date_added__gt = null, $date_added__gte = null, $date_added__lt = null, $date_added__lte = null, $date_added__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $prefix = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAggregatesList'][0])
    {
        return $this->ipamAggregatesListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $date_added, $date_added__empty, $date_added__gt, $date_added__gte, $date_added__lt, $date_added__lte, $date_added__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $prefix, $q, $rir, $rir__n, $rir_id, $rir_id__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAggregatesListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  \DateTime[] $date_added (optional)
     * @param  bool $date_added__empty (optional)
     * @param  \DateTime[] $date_added__gt (optional)
     * @param  \DateTime[] $date_added__gte (optional)
     * @param  \DateTime[] $date_added__lt (optional)
     * @param  \DateTime[] $date_added__lte (optional)
     * @param  \DateTime[] $date_added__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $prefix Prefix (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $date_added = null, $date_added__empty = null, $date_added__gt = null, $date_added__gte = null, $date_added__lt = null, $date_added__lte = null, $date_added__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $prefix = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAggregatesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedAggregateList';
        $request = $this->ipamAggregatesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $date_added, $date_added__empty, $date_added__gt, $date_added__gte, $date_added__lt, $date_added__lte, $date_added__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $prefix, $q, $rir, $rir__n, $rir_id, $rir_id__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAggregatesList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  \DateTime[] $date_added (optional)
     * @param  bool $date_added__empty (optional)
     * @param  \DateTime[] $date_added__gt (optional)
     * @param  \DateTime[] $date_added__gte (optional)
     * @param  \DateTime[] $date_added__lt (optional)
     * @param  \DateTime[] $date_added__lte (optional)
     * @param  \DateTime[] $date_added__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $prefix Prefix (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAggregatesListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $date_added = null, $date_added__empty = null, $date_added__gt = null, $date_added__gte = null, $date_added__lt = null, $date_added__lte = null, $date_added__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $prefix = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAggregatesList'][0])
    {
































































        $resourcePath = '/api/ipam/aggregates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_added,
            'date_added', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_added__empty,
            'date_added__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_added__gt,
            'date_added__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_added__gte,
            'date_added__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_added__lt,
            'date_added__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_added__lte,
            'date_added__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_added__n,
            'date_added__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $family,
            'family', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $prefix,
            'prefix', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir,
            'rir', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir__n,
            'rir__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir_id,
            'rir_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir_id__n,
            'rir_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAggregatesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableAggregateRequest $patched_writable_aggregate_request patched_writable_aggregate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Aggregate
     */
    public function ipamAggregatesPartialUpdate($id, $patched_writable_aggregate_request = null, string $contentType = self::contentTypes['ipamAggregatesPartialUpdate'][0])
    {
        list($response) = $this->ipamAggregatesPartialUpdateWithHttpInfo($id, $patched_writable_aggregate_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAggregatesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableAggregateRequest $patched_writable_aggregate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Aggregate, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAggregatesPartialUpdateWithHttpInfo($id, $patched_writable_aggregate_request = null, string $contentType = self::contentTypes['ipamAggregatesPartialUpdate'][0])
    {
        $request = $this->ipamAggregatesPartialUpdateRequest($id, $patched_writable_aggregate_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Aggregate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Aggregate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Aggregate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Aggregate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Aggregate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAggregatesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableAggregateRequest $patched_writable_aggregate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesPartialUpdateAsync($id, $patched_writable_aggregate_request = null, string $contentType = self::contentTypes['ipamAggregatesPartialUpdate'][0])
    {
        return $this->ipamAggregatesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_aggregate_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAggregatesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableAggregateRequest $patched_writable_aggregate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_aggregate_request = null, string $contentType = self::contentTypes['ipamAggregatesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Aggregate';
        $request = $this->ipamAggregatesPartialUpdateRequest($id, $patched_writable_aggregate_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAggregatesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableAggregateRequest $patched_writable_aggregate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAggregatesPartialUpdateRequest($id, $patched_writable_aggregate_request = null, string $contentType = self::contentTypes['ipamAggregatesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAggregatesPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/aggregates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_aggregate_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_aggregate_request));
            } else {
                $httpBody = $patched_writable_aggregate_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAggregatesRetrieve
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Aggregate
     */
    public function ipamAggregatesRetrieve($id, string $contentType = self::contentTypes['ipamAggregatesRetrieve'][0])
    {
        list($response) = $this->ipamAggregatesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamAggregatesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Aggregate, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAggregatesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamAggregatesRetrieve'][0])
    {
        $request = $this->ipamAggregatesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Aggregate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Aggregate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Aggregate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Aggregate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Aggregate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAggregatesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesRetrieveAsync($id, string $contentType = self::contentTypes['ipamAggregatesRetrieve'][0])
    {
        return $this->ipamAggregatesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAggregatesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamAggregatesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Aggregate';
        $request = $this->ipamAggregatesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAggregatesRetrieve'
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAggregatesRetrieveRequest($id, string $contentType = self::contentTypes['ipamAggregatesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAggregatesRetrieve'
            );
        }


        $resourcePath = '/api/ipam/aggregates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAggregatesUpdate
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  \OpenAPI\Client\Model\WritableAggregateRequest $writable_aggregate_request writable_aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Aggregate
     */
    public function ipamAggregatesUpdate($id, $writable_aggregate_request, string $contentType = self::contentTypes['ipamAggregatesUpdate'][0])
    {
        list($response) = $this->ipamAggregatesUpdateWithHttpInfo($id, $writable_aggregate_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAggregatesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  \OpenAPI\Client\Model\WritableAggregateRequest $writable_aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Aggregate, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAggregatesUpdateWithHttpInfo($id, $writable_aggregate_request, string $contentType = self::contentTypes['ipamAggregatesUpdate'][0])
    {
        $request = $this->ipamAggregatesUpdateRequest($id, $writable_aggregate_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Aggregate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Aggregate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Aggregate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Aggregate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Aggregate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAggregatesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  \OpenAPI\Client\Model\WritableAggregateRequest $writable_aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesUpdateAsync($id, $writable_aggregate_request, string $contentType = self::contentTypes['ipamAggregatesUpdate'][0])
    {
        return $this->ipamAggregatesUpdateAsyncWithHttpInfo($id, $writable_aggregate_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAggregatesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  \OpenAPI\Client\Model\WritableAggregateRequest $writable_aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAggregatesUpdateAsyncWithHttpInfo($id, $writable_aggregate_request, string $contentType = self::contentTypes['ipamAggregatesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Aggregate';
        $request = $this->ipamAggregatesUpdateRequest($id, $writable_aggregate_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAggregatesUpdate'
     *
     * @param  int $id A unique integer value identifying this aggregate. (required)
     * @param  \OpenAPI\Client\Model\WritableAggregateRequest $writable_aggregate_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAggregatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAggregatesUpdateRequest($id, $writable_aggregate_request, string $contentType = self::contentTypes['ipamAggregatesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAggregatesUpdate'
            );
        }

        // verify the required parameter 'writable_aggregate_request' is set
        if ($writable_aggregate_request === null || (is_array($writable_aggregate_request) && count($writable_aggregate_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_aggregate_request when calling ipamAggregatesUpdate'
            );
        }


        $resourcePath = '/api/ipam/aggregates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_aggregate_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_aggregate_request));
            } else {
                $httpBody = $writable_aggregate_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnRangesAvailableAsnsCreate
     *
     * @param  int $id id (required)
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesAvailableAsnsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASN[]
     */
    public function ipamAsnRangesAvailableAsnsCreate($id, $asn_request, string $contentType = self::contentTypes['ipamAsnRangesAvailableAsnsCreate'][0])
    {
        list($response) = $this->ipamAsnRangesAvailableAsnsCreateWithHttpInfo($id, $asn_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnRangesAvailableAsnsCreateWithHttpInfo
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesAvailableAsnsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnRangesAvailableAsnsCreateWithHttpInfo($id, $asn_request, string $contentType = self::contentTypes['ipamAsnRangesAvailableAsnsCreate'][0])
    {
        $request = $this->ipamAsnRangesAvailableAsnsCreateRequest($id, $asn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ASN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnRangesAvailableAsnsCreateAsync
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesAvailableAsnsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesAvailableAsnsCreateAsync($id, $asn_request, string $contentType = self::contentTypes['ipamAsnRangesAvailableAsnsCreate'][0])
    {
        return $this->ipamAsnRangesAvailableAsnsCreateAsyncWithHttpInfo($id, $asn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnRangesAvailableAsnsCreateAsyncWithHttpInfo
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesAvailableAsnsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesAvailableAsnsCreateAsyncWithHttpInfo($id, $asn_request, string $contentType = self::contentTypes['ipamAsnRangesAvailableAsnsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASN[]';
        $request = $this->ipamAsnRangesAvailableAsnsCreateRequest($id, $asn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnRangesAvailableAsnsCreate'
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesAvailableAsnsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnRangesAvailableAsnsCreateRequest($id, $asn_request, string $contentType = self::contentTypes['ipamAsnRangesAvailableAsnsCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAsnRangesAvailableAsnsCreate'
            );
        }

        // verify the required parameter 'asn_request' is set
        if ($asn_request === null || (is_array($asn_request) && count($asn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asn_request when calling ipamAsnRangesAvailableAsnsCreate'
            );
        }


        $resourcePath = '/api/ipam/asn-ranges/{id}/available-asns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($asn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($asn_request));
            } else {
                $httpBody = $asn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnRangesAvailableAsnsList
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesAvailableAsnsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AvailableASN[]
     */
    public function ipamAsnRangesAvailableAsnsList($id, string $contentType = self::contentTypes['ipamAsnRangesAvailableAsnsList'][0])
    {
        list($response) = $this->ipamAsnRangesAvailableAsnsListWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnRangesAvailableAsnsListWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesAvailableAsnsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AvailableASN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnRangesAvailableAsnsListWithHttpInfo($id, string $contentType = self::contentTypes['ipamAsnRangesAvailableAsnsList'][0])
    {
        $request = $this->ipamAsnRangesAvailableAsnsListRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AvailableASN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AvailableASN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AvailableASN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AvailableASN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AvailableASN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnRangesAvailableAsnsListAsync
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesAvailableAsnsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesAvailableAsnsListAsync($id, string $contentType = self::contentTypes['ipamAsnRangesAvailableAsnsList'][0])
    {
        return $this->ipamAsnRangesAvailableAsnsListAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnRangesAvailableAsnsListAsyncWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesAvailableAsnsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesAvailableAsnsListAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamAsnRangesAvailableAsnsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AvailableASN[]';
        $request = $this->ipamAsnRangesAvailableAsnsListRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnRangesAvailableAsnsList'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesAvailableAsnsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnRangesAvailableAsnsListRequest($id, string $contentType = self::contentTypes['ipamAsnRangesAvailableAsnsList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAsnRangesAvailableAsnsList'
            );
        }


        $resourcePath = '/api/ipam/asn-ranges/{id}/available-asns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnRangesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamAsnRangesBulkDestroy($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkDestroy'][0])
    {
        $this->ipamAsnRangesBulkDestroyWithHttpInfo($asn_range_request, $contentType);
    }

    /**
     * Operation ipamAsnRangesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnRangesBulkDestroyWithHttpInfo($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkDestroy'][0])
    {
        $request = $this->ipamAsnRangesBulkDestroyRequest($asn_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnRangesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesBulkDestroyAsync($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkDestroy'][0])
    {
        return $this->ipamAsnRangesBulkDestroyAsyncWithHttpInfo($asn_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnRangesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesBulkDestroyAsyncWithHttpInfo($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamAsnRangesBulkDestroyRequest($asn_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnRangesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnRangesBulkDestroyRequest($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkDestroy'][0])
    {

        // verify the required parameter 'asn_range_request' is set
        if ($asn_range_request === null || (is_array($asn_range_request) && count($asn_range_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asn_range_request when calling ipamAsnRangesBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/asn-ranges/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($asn_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($asn_range_request));
            } else {
                $httpBody = $asn_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnRangesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASNRange[]
     */
    public function ipamAsnRangesBulkPartialUpdate($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamAsnRangesBulkPartialUpdateWithHttpInfo($asn_range_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnRangesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASNRange[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnRangesBulkPartialUpdateWithHttpInfo($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkPartialUpdate'][0])
    {
        $request = $this->ipamAsnRangesBulkPartialUpdateRequest($asn_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ASNRange[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASNRange[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASNRange[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASNRange[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASNRange[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnRangesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesBulkPartialUpdateAsync($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkPartialUpdate'][0])
    {
        return $this->ipamAsnRangesBulkPartialUpdateAsyncWithHttpInfo($asn_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnRangesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesBulkPartialUpdateAsyncWithHttpInfo($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASNRange[]';
        $request = $this->ipamAsnRangesBulkPartialUpdateRequest($asn_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnRangesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnRangesBulkPartialUpdateRequest($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'asn_range_request' is set
        if ($asn_range_request === null || (is_array($asn_range_request) && count($asn_range_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asn_range_request when calling ipamAsnRangesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/asn-ranges/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($asn_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($asn_range_request));
            } else {
                $httpBody = $asn_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnRangesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASNRange[]
     */
    public function ipamAsnRangesBulkUpdate($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkUpdate'][0])
    {
        list($response) = $this->ipamAsnRangesBulkUpdateWithHttpInfo($asn_range_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnRangesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASNRange[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnRangesBulkUpdateWithHttpInfo($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkUpdate'][0])
    {
        $request = $this->ipamAsnRangesBulkUpdateRequest($asn_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ASNRange[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASNRange[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASNRange[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASNRange[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASNRange[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnRangesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesBulkUpdateAsync($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkUpdate'][0])
    {
        return $this->ipamAsnRangesBulkUpdateAsyncWithHttpInfo($asn_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnRangesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesBulkUpdateAsyncWithHttpInfo($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASNRange[]';
        $request = $this->ipamAsnRangesBulkUpdateRequest($asn_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnRangesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest[] $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnRangesBulkUpdateRequest($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesBulkUpdate'][0])
    {

        // verify the required parameter 'asn_range_request' is set
        if ($asn_range_request === null || (is_array($asn_range_request) && count($asn_range_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asn_range_request when calling ipamAsnRangesBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/asn-ranges/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($asn_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($asn_range_request));
            } else {
                $httpBody = $asn_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnRangesCreate
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest $asn_range_request asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASNRange
     */
    public function ipamAsnRangesCreate($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesCreate'][0])
    {
        list($response) = $this->ipamAsnRangesCreateWithHttpInfo($asn_range_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnRangesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASNRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnRangesCreateWithHttpInfo($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesCreate'][0])
    {
        $request = $this->ipamAsnRangesCreateRequest($asn_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ASNRange' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASNRange' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASNRange', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASNRange';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASNRange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnRangesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesCreateAsync($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesCreate'][0])
    {
        return $this->ipamAsnRangesCreateAsyncWithHttpInfo($asn_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnRangesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesCreateAsyncWithHttpInfo($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASNRange';
        $request = $this->ipamAsnRangesCreateRequest($asn_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnRangesCreate'
     *
     * @param  \OpenAPI\Client\Model\ASNRangeRequest $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnRangesCreateRequest($asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesCreate'][0])
    {

        // verify the required parameter 'asn_range_request' is set
        if ($asn_range_request === null || (is_array($asn_range_request) && count($asn_range_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asn_range_request when calling ipamAsnRangesCreate'
            );
        }


        $resourcePath = '/api/ipam/asn-ranges/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($asn_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($asn_range_request));
            } else {
                $httpBody = $asn_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnRangesDestroy
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamAsnRangesDestroy($id, string $contentType = self::contentTypes['ipamAsnRangesDestroy'][0])
    {
        $this->ipamAsnRangesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamAsnRangesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnRangesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamAsnRangesDestroy'][0])
    {
        $request = $this->ipamAsnRangesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnRangesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesDestroyAsync($id, string $contentType = self::contentTypes['ipamAsnRangesDestroy'][0])
    {
        return $this->ipamAsnRangesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnRangesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamAsnRangesDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamAsnRangesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnRangesDestroy'
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnRangesDestroyRequest($id, string $contentType = self::contentTypes['ipamAsnRangesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAsnRangesDestroy'
            );
        }


        $resourcePath = '/api/ipam/asn-ranges/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnRangesList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $end end (optional)
     * @param  bool $end__empty end__empty (optional)
     * @param  int[] $end__gt end__gt (optional)
     * @param  int[] $end__gte end__gte (optional)
     * @param  int[] $end__lt end__lt (optional)
     * @param  int[] $end__lte end__lte (optional)
     * @param  int[] $end__n end__n (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $slug slug (optional)
     * @param  bool $slug__empty slug__empty (optional)
     * @param  string[] $slug__ic slug__ic (optional)
     * @param  string[] $slug__ie slug__ie (optional)
     * @param  string[] $slug__iew slug__iew (optional)
     * @param  string[] $slug__isw slug__isw (optional)
     * @param  string[] $slug__n slug__n (optional)
     * @param  string[] $slug__nic slug__nic (optional)
     * @param  string[] $slug__nie slug__nie (optional)
     * @param  string[] $slug__niew slug__niew (optional)
     * @param  string[] $slug__nisw slug__nisw (optional)
     * @param  int[] $start start (optional)
     * @param  bool $start__empty start__empty (optional)
     * @param  int[] $start__gt start__gt (optional)
     * @param  int[] $start__gte start__gte (optional)
     * @param  int[] $start__lt start__lt (optional)
     * @param  int[] $start__lte start__lte (optional)
     * @param  int[] $start__n start__n (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedASNRangeList
     */
    public function ipamAsnRangesList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $end = null, $end__empty = null, $end__gt = null, $end__gte = null, $end__lt = null, $end__lte = null, $end__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $start = null, $start__empty = null, $start__gt = null, $start__gte = null, $start__lt = null, $start__lte = null, $start__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAsnRangesList'][0])
    {
        list($response) = $this->ipamAsnRangesListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $end, $end__empty, $end__gt, $end__gte, $end__lt, $end__lte, $end__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rir, $rir__n, $rir_id, $rir_id__n, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $start, $start__empty, $start__gt, $start__gte, $start__lt, $start__lte, $start__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnRangesListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $end (optional)
     * @param  bool $end__empty (optional)
     * @param  int[] $end__gt (optional)
     * @param  int[] $end__gte (optional)
     * @param  int[] $end__lt (optional)
     * @param  int[] $end__lte (optional)
     * @param  int[] $end__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  int[] $start (optional)
     * @param  bool $start__empty (optional)
     * @param  int[] $start__gt (optional)
     * @param  int[] $start__gte (optional)
     * @param  int[] $start__lt (optional)
     * @param  int[] $start__lte (optional)
     * @param  int[] $start__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedASNRangeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnRangesListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $end = null, $end__empty = null, $end__gt = null, $end__gte = null, $end__lt = null, $end__lte = null, $end__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $start = null, $start__empty = null, $start__gt = null, $start__gte = null, $start__lt = null, $start__lte = null, $start__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAsnRangesList'][0])
    {
        $request = $this->ipamAsnRangesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $end, $end__empty, $end__gt, $end__gte, $end__lt, $end__lte, $end__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rir, $rir__n, $rir_id, $rir_id__n, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $start, $start__empty, $start__gt, $start__gte, $start__lt, $start__lte, $start__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedASNRangeList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedASNRangeList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedASNRangeList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedASNRangeList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedASNRangeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnRangesListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $end (optional)
     * @param  bool $end__empty (optional)
     * @param  int[] $end__gt (optional)
     * @param  int[] $end__gte (optional)
     * @param  int[] $end__lt (optional)
     * @param  int[] $end__lte (optional)
     * @param  int[] $end__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  int[] $start (optional)
     * @param  bool $start__empty (optional)
     * @param  int[] $start__gt (optional)
     * @param  int[] $start__gte (optional)
     * @param  int[] $start__lt (optional)
     * @param  int[] $start__lte (optional)
     * @param  int[] $start__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $end = null, $end__empty = null, $end__gt = null, $end__gte = null, $end__lt = null, $end__lte = null, $end__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $start = null, $start__empty = null, $start__gt = null, $start__gte = null, $start__lt = null, $start__lte = null, $start__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAsnRangesList'][0])
    {
        return $this->ipamAsnRangesListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $end, $end__empty, $end__gt, $end__gte, $end__lt, $end__lte, $end__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rir, $rir__n, $rir_id, $rir_id__n, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $start, $start__empty, $start__gt, $start__gte, $start__lt, $start__lte, $start__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnRangesListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $end (optional)
     * @param  bool $end__empty (optional)
     * @param  int[] $end__gt (optional)
     * @param  int[] $end__gte (optional)
     * @param  int[] $end__lt (optional)
     * @param  int[] $end__lte (optional)
     * @param  int[] $end__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  int[] $start (optional)
     * @param  bool $start__empty (optional)
     * @param  int[] $start__gt (optional)
     * @param  int[] $start__gte (optional)
     * @param  int[] $start__lt (optional)
     * @param  int[] $start__lte (optional)
     * @param  int[] $start__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $end = null, $end__empty = null, $end__gt = null, $end__gte = null, $end__lt = null, $end__lte = null, $end__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $start = null, $start__empty = null, $start__gt = null, $start__gte = null, $start__lt = null, $start__lte = null, $start__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAsnRangesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedASNRangeList';
        $request = $this->ipamAsnRangesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $end, $end__empty, $end__gt, $end__gte, $end__lt, $end__lte, $end__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rir, $rir__n, $rir_id, $rir_id__n, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $start, $start__empty, $start__gt, $start__gte, $start__lt, $start__lte, $start__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnRangesList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $end (optional)
     * @param  bool $end__empty (optional)
     * @param  int[] $end__gt (optional)
     * @param  int[] $end__gte (optional)
     * @param  int[] $end__lt (optional)
     * @param  int[] $end__lte (optional)
     * @param  int[] $end__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  int[] $start (optional)
     * @param  bool $start__empty (optional)
     * @param  int[] $start__gt (optional)
     * @param  int[] $start__gte (optional)
     * @param  int[] $start__lt (optional)
     * @param  int[] $start__lte (optional)
     * @param  int[] $start__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnRangesListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $end = null, $end__empty = null, $end__gt = null, $end__gte = null, $end__lt = null, $end__lte = null, $end__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $start = null, $start__empty = null, $start__gt = null, $start__gte = null, $start__lt = null, $start__lte = null, $start__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAsnRangesList'][0])
    {



























































































        $resourcePath = '/api/ipam/asn-ranges/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end,
            'end', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end__empty,
            'end__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end__gt,
            'end__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end__gte,
            'end__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end__lt,
            'end__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end__lte,
            'end__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end__n,
            'end__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir,
            'rir', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir__n,
            'rir__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir_id,
            'rir_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir_id__n,
            'rir_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__empty,
            'slug__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ic,
            'slug__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ie,
            'slug__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__iew,
            'slug__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__isw,
            'slug__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__n,
            'slug__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nic,
            'slug__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nie,
            'slug__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__niew,
            'slug__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nisw,
            'slug__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start__empty,
            'start__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start__gt,
            'start__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start__gte,
            'start__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start__lt,
            'start__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start__lte,
            'start__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start__n,
            'start__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnRangesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  \OpenAPI\Client\Model\PatchedASNRangeRequest $patched_asn_range_request patched_asn_range_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASNRange
     */
    public function ipamAsnRangesPartialUpdate($id, $patched_asn_range_request = null, string $contentType = self::contentTypes['ipamAsnRangesPartialUpdate'][0])
    {
        list($response) = $this->ipamAsnRangesPartialUpdateWithHttpInfo($id, $patched_asn_range_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnRangesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  \OpenAPI\Client\Model\PatchedASNRangeRequest $patched_asn_range_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASNRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnRangesPartialUpdateWithHttpInfo($id, $patched_asn_range_request = null, string $contentType = self::contentTypes['ipamAsnRangesPartialUpdate'][0])
    {
        $request = $this->ipamAsnRangesPartialUpdateRequest($id, $patched_asn_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ASNRange' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASNRange' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASNRange', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASNRange';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASNRange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnRangesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  \OpenAPI\Client\Model\PatchedASNRangeRequest $patched_asn_range_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesPartialUpdateAsync($id, $patched_asn_range_request = null, string $contentType = self::contentTypes['ipamAsnRangesPartialUpdate'][0])
    {
        return $this->ipamAsnRangesPartialUpdateAsyncWithHttpInfo($id, $patched_asn_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnRangesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  \OpenAPI\Client\Model\PatchedASNRangeRequest $patched_asn_range_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesPartialUpdateAsyncWithHttpInfo($id, $patched_asn_range_request = null, string $contentType = self::contentTypes['ipamAsnRangesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASNRange';
        $request = $this->ipamAsnRangesPartialUpdateRequest($id, $patched_asn_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnRangesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  \OpenAPI\Client\Model\PatchedASNRangeRequest $patched_asn_range_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnRangesPartialUpdateRequest($id, $patched_asn_range_request = null, string $contentType = self::contentTypes['ipamAsnRangesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAsnRangesPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/asn-ranges/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_asn_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_asn_range_request));
            } else {
                $httpBody = $patched_asn_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnRangesRetrieve
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASNRange
     */
    public function ipamAsnRangesRetrieve($id, string $contentType = self::contentTypes['ipamAsnRangesRetrieve'][0])
    {
        list($response) = $this->ipamAsnRangesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnRangesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASNRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnRangesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamAsnRangesRetrieve'][0])
    {
        $request = $this->ipamAsnRangesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ASNRange' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASNRange' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASNRange', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASNRange';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASNRange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnRangesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesRetrieveAsync($id, string $contentType = self::contentTypes['ipamAsnRangesRetrieve'][0])
    {
        return $this->ipamAsnRangesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnRangesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamAsnRangesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASNRange';
        $request = $this->ipamAsnRangesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnRangesRetrieve'
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnRangesRetrieveRequest($id, string $contentType = self::contentTypes['ipamAsnRangesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAsnRangesRetrieve'
            );
        }


        $resourcePath = '/api/ipam/asn-ranges/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnRangesUpdate
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  \OpenAPI\Client\Model\ASNRangeRequest $asn_range_request asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASNRange
     */
    public function ipamAsnRangesUpdate($id, $asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesUpdate'][0])
    {
        list($response) = $this->ipamAsnRangesUpdateWithHttpInfo($id, $asn_range_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnRangesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  \OpenAPI\Client\Model\ASNRangeRequest $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASNRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnRangesUpdateWithHttpInfo($id, $asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesUpdate'][0])
    {
        $request = $this->ipamAsnRangesUpdateRequest($id, $asn_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ASNRange' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASNRange' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASNRange', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASNRange';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASNRange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnRangesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  \OpenAPI\Client\Model\ASNRangeRequest $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesUpdateAsync($id, $asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesUpdate'][0])
    {
        return $this->ipamAsnRangesUpdateAsyncWithHttpInfo($id, $asn_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnRangesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  \OpenAPI\Client\Model\ASNRangeRequest $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnRangesUpdateAsyncWithHttpInfo($id, $asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASNRange';
        $request = $this->ipamAsnRangesUpdateRequest($id, $asn_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnRangesUpdate'
     *
     * @param  int $id A unique integer value identifying this ASN range. (required)
     * @param  \OpenAPI\Client\Model\ASNRangeRequest $asn_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnRangesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnRangesUpdateRequest($id, $asn_range_request, string $contentType = self::contentTypes['ipamAsnRangesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAsnRangesUpdate'
            );
        }

        // verify the required parameter 'asn_range_request' is set
        if ($asn_range_request === null || (is_array($asn_range_request) && count($asn_range_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asn_range_request when calling ipamAsnRangesUpdate'
            );
        }


        $resourcePath = '/api/ipam/asn-ranges/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($asn_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($asn_range_request));
            } else {
                $httpBody = $asn_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamAsnsBulkDestroy($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkDestroy'][0])
    {
        $this->ipamAsnsBulkDestroyWithHttpInfo($asn_request, $contentType);
    }

    /**
     * Operation ipamAsnsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnsBulkDestroyWithHttpInfo($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkDestroy'][0])
    {
        $request = $this->ipamAsnsBulkDestroyRequest($asn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsBulkDestroyAsync($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkDestroy'][0])
    {
        return $this->ipamAsnsBulkDestroyAsyncWithHttpInfo($asn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsBulkDestroyAsyncWithHttpInfo($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamAsnsBulkDestroyRequest($asn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnsBulkDestroyRequest($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkDestroy'][0])
    {

        // verify the required parameter 'asn_request' is set
        if ($asn_request === null || (is_array($asn_request) && count($asn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asn_request when calling ipamAsnsBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/asns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($asn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($asn_request));
            } else {
                $httpBody = $asn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASN[]
     */
    public function ipamAsnsBulkPartialUpdate($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamAsnsBulkPartialUpdateWithHttpInfo($asn_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnsBulkPartialUpdateWithHttpInfo($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkPartialUpdate'][0])
    {
        $request = $this->ipamAsnsBulkPartialUpdateRequest($asn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ASN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsBulkPartialUpdateAsync($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkPartialUpdate'][0])
    {
        return $this->ipamAsnsBulkPartialUpdateAsyncWithHttpInfo($asn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsBulkPartialUpdateAsyncWithHttpInfo($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASN[]';
        $request = $this->ipamAsnsBulkPartialUpdateRequest($asn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnsBulkPartialUpdateRequest($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'asn_request' is set
        if ($asn_request === null || (is_array($asn_request) && count($asn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asn_request when calling ipamAsnsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/asns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($asn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($asn_request));
            } else {
                $httpBody = $asn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASN[]
     */
    public function ipamAsnsBulkUpdate($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkUpdate'][0])
    {
        list($response) = $this->ipamAsnsBulkUpdateWithHttpInfo($asn_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnsBulkUpdateWithHttpInfo($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkUpdate'][0])
    {
        $request = $this->ipamAsnsBulkUpdateRequest($asn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ASN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsBulkUpdateAsync($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkUpdate'][0])
    {
        return $this->ipamAsnsBulkUpdateAsyncWithHttpInfo($asn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsBulkUpdateAsyncWithHttpInfo($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASN[]';
        $request = $this->ipamAsnsBulkUpdateRequest($asn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ASNRequest[] $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnsBulkUpdateRequest($asn_request, string $contentType = self::contentTypes['ipamAsnsBulkUpdate'][0])
    {

        // verify the required parameter 'asn_request' is set
        if ($asn_request === null || (is_array($asn_request) && count($asn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asn_request when calling ipamAsnsBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/asns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($asn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($asn_request));
            } else {
                $httpBody = $asn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnsCreate
     *
     * @param  \OpenAPI\Client\Model\ASNRequest $asn_request asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASN
     */
    public function ipamAsnsCreate($asn_request, string $contentType = self::contentTypes['ipamAsnsCreate'][0])
    {
        list($response) = $this->ipamAsnsCreateWithHttpInfo($asn_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRequest $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASN, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnsCreateWithHttpInfo($asn_request, string $contentType = self::contentTypes['ipamAsnsCreate'][0])
    {
        $request = $this->ipamAsnsCreateRequest($asn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ASN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\ASNRequest $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsCreateAsync($asn_request, string $contentType = self::contentTypes['ipamAsnsCreate'][0])
    {
        return $this->ipamAsnsCreateAsyncWithHttpInfo($asn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ASNRequest $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsCreateAsyncWithHttpInfo($asn_request, string $contentType = self::contentTypes['ipamAsnsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASN';
        $request = $this->ipamAsnsCreateRequest($asn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnsCreate'
     *
     * @param  \OpenAPI\Client\Model\ASNRequest $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnsCreateRequest($asn_request, string $contentType = self::contentTypes['ipamAsnsCreate'][0])
    {

        // verify the required parameter 'asn_request' is set
        if ($asn_request === null || (is_array($asn_request) && count($asn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asn_request when calling ipamAsnsCreate'
            );
        }


        $resourcePath = '/api/ipam/asns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($asn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($asn_request));
            } else {
                $httpBody = $asn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnsDestroy
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamAsnsDestroy($id, string $contentType = self::contentTypes['ipamAsnsDestroy'][0])
    {
        $this->ipamAsnsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamAsnsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamAsnsDestroy'][0])
    {
        $request = $this->ipamAsnsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsDestroyAsync($id, string $contentType = self::contentTypes['ipamAsnsDestroy'][0])
    {
        return $this->ipamAsnsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamAsnsDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamAsnsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnsDestroy'
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnsDestroyRequest($id, string $contentType = self::contentTypes['ipamAsnsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAsnsDestroy'
            );
        }


        $resourcePath = '/api/ipam/asns/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnsList
     *
     * @param  int[] $asn asn (optional)
     * @param  bool $asn__empty asn__empty (optional)
     * @param  int[] $asn__gt asn__gt (optional)
     * @param  int[] $asn__gte asn__gte (optional)
     * @param  int[] $asn__lt asn__lt (optional)
     * @param  int[] $asn__lte asn__lte (optional)
     * @param  int[] $asn__n asn__n (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedASNList
     */
    public function ipamAsnsList($asn = null, $asn__empty = null, $asn__gt = null, $asn__gte = null, $asn__lt = null, $asn__lte = null, $asn__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $site = null, $site__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAsnsList'][0])
    {
        list($response) = $this->ipamAsnsListWithHttpInfo($asn, $asn__empty, $asn__gt, $asn__gte, $asn__lt, $asn__lte, $asn__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $rir, $rir__n, $rir_id, $rir_id__n, $site, $site__n, $site_id, $site_id__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnsListWithHttpInfo
     *
     * @param  int[] $asn (optional)
     * @param  bool $asn__empty (optional)
     * @param  int[] $asn__gt (optional)
     * @param  int[] $asn__gte (optional)
     * @param  int[] $asn__lt (optional)
     * @param  int[] $asn__lte (optional)
     * @param  int[] $asn__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedASNList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnsListWithHttpInfo($asn = null, $asn__empty = null, $asn__gt = null, $asn__gte = null, $asn__lt = null, $asn__lte = null, $asn__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $site = null, $site__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAsnsList'][0])
    {
        $request = $this->ipamAsnsListRequest($asn, $asn__empty, $asn__gt, $asn__gte, $asn__lt, $asn__lte, $asn__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $rir, $rir__n, $rir_id, $rir_id__n, $site, $site__n, $site_id, $site_id__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedASNList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedASNList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedASNList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedASNList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedASNList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnsListAsync
     *
     * @param  int[] $asn (optional)
     * @param  bool $asn__empty (optional)
     * @param  int[] $asn__gt (optional)
     * @param  int[] $asn__gte (optional)
     * @param  int[] $asn__lt (optional)
     * @param  int[] $asn__lte (optional)
     * @param  int[] $asn__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsListAsync($asn = null, $asn__empty = null, $asn__gt = null, $asn__gte = null, $asn__lt = null, $asn__lte = null, $asn__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $site = null, $site__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAsnsList'][0])
    {
        return $this->ipamAsnsListAsyncWithHttpInfo($asn, $asn__empty, $asn__gt, $asn__gte, $asn__lt, $asn__lte, $asn__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $rir, $rir__n, $rir_id, $rir_id__n, $site, $site__n, $site_id, $site_id__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnsListAsyncWithHttpInfo
     *
     * @param  int[] $asn (optional)
     * @param  bool $asn__empty (optional)
     * @param  int[] $asn__gt (optional)
     * @param  int[] $asn__gte (optional)
     * @param  int[] $asn__lt (optional)
     * @param  int[] $asn__lte (optional)
     * @param  int[] $asn__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsListAsyncWithHttpInfo($asn = null, $asn__empty = null, $asn__gt = null, $asn__gte = null, $asn__lt = null, $asn__lte = null, $asn__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $site = null, $site__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAsnsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedASNList';
        $request = $this->ipamAsnsListRequest($asn, $asn__empty, $asn__gt, $asn__gte, $asn__lt, $asn__lte, $asn__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $rir, $rir__n, $rir_id, $rir_id__n, $site, $site__n, $site_id, $site_id__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnsList'
     *
     * @param  int[] $asn (optional)
     * @param  bool $asn__empty (optional)
     * @param  int[] $asn__gt (optional)
     * @param  int[] $asn__gte (optional)
     * @param  int[] $asn__lt (optional)
     * @param  int[] $asn__lte (optional)
     * @param  int[] $asn__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rir RIR (slug) (optional)
     * @param  string[] $rir__n RIR (slug) (optional)
     * @param  int[] $rir_id RIR (ID) (optional)
     * @param  int[] $rir_id__n RIR (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnsListRequest($asn = null, $asn__empty = null, $asn__gt = null, $asn__gte = null, $asn__lt = null, $asn__lte = null, $asn__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $rir = null, $rir__n = null, $rir_id = null, $rir_id__n = null, $site = null, $site__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamAsnsList'][0])
    {






































































        $resourcePath = '/api/ipam/asns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asn,
            'asn', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asn__empty,
            'asn__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asn__gt,
            'asn__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asn__gte,
            'asn__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asn__lt,
            'asn__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asn__lte,
            'asn__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asn__n,
            'asn__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider,
            'provider', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider__n,
            'provider__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id,
            'provider_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id__n,
            'provider_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir,
            'rir', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir__n,
            'rir__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir_id,
            'rir_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rir_id__n,
            'rir_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site,
            'site', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site__n,
            'site__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id,
            'site_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id__n,
            'site_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  \OpenAPI\Client\Model\PatchedASNRequest $patched_asn_request patched_asn_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASN
     */
    public function ipamAsnsPartialUpdate($id, $patched_asn_request = null, string $contentType = self::contentTypes['ipamAsnsPartialUpdate'][0])
    {
        list($response) = $this->ipamAsnsPartialUpdateWithHttpInfo($id, $patched_asn_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  \OpenAPI\Client\Model\PatchedASNRequest $patched_asn_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASN, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnsPartialUpdateWithHttpInfo($id, $patched_asn_request = null, string $contentType = self::contentTypes['ipamAsnsPartialUpdate'][0])
    {
        $request = $this->ipamAsnsPartialUpdateRequest($id, $patched_asn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ASN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  \OpenAPI\Client\Model\PatchedASNRequest $patched_asn_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsPartialUpdateAsync($id, $patched_asn_request = null, string $contentType = self::contentTypes['ipamAsnsPartialUpdate'][0])
    {
        return $this->ipamAsnsPartialUpdateAsyncWithHttpInfo($id, $patched_asn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  \OpenAPI\Client\Model\PatchedASNRequest $patched_asn_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsPartialUpdateAsyncWithHttpInfo($id, $patched_asn_request = null, string $contentType = self::contentTypes['ipamAsnsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASN';
        $request = $this->ipamAsnsPartialUpdateRequest($id, $patched_asn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  \OpenAPI\Client\Model\PatchedASNRequest $patched_asn_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnsPartialUpdateRequest($id, $patched_asn_request = null, string $contentType = self::contentTypes['ipamAsnsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAsnsPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/asns/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_asn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_asn_request));
            } else {
                $httpBody = $patched_asn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnsRetrieve
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASN
     */
    public function ipamAsnsRetrieve($id, string $contentType = self::contentTypes['ipamAsnsRetrieve'][0])
    {
        list($response) = $this->ipamAsnsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASN, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamAsnsRetrieve'][0])
    {
        $request = $this->ipamAsnsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ASN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsRetrieveAsync($id, string $contentType = self::contentTypes['ipamAsnsRetrieve'][0])
    {
        return $this->ipamAsnsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamAsnsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASN';
        $request = $this->ipamAsnsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnsRetrieve'
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnsRetrieveRequest($id, string $contentType = self::contentTypes['ipamAsnsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAsnsRetrieve'
            );
        }


        $resourcePath = '/api/ipam/asns/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamAsnsUpdate
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  \OpenAPI\Client\Model\ASNRequest $asn_request asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ASN
     */
    public function ipamAsnsUpdate($id, $asn_request, string $contentType = self::contentTypes['ipamAsnsUpdate'][0])
    {
        list($response) = $this->ipamAsnsUpdateWithHttpInfo($id, $asn_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamAsnsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  \OpenAPI\Client\Model\ASNRequest $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ASN, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamAsnsUpdateWithHttpInfo($id, $asn_request, string $contentType = self::contentTypes['ipamAsnsUpdate'][0])
    {
        $request = $this->ipamAsnsUpdateRequest($id, $asn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ASN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ASN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ASN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ASN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ASN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamAsnsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  \OpenAPI\Client\Model\ASNRequest $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsUpdateAsync($id, $asn_request, string $contentType = self::contentTypes['ipamAsnsUpdate'][0])
    {
        return $this->ipamAsnsUpdateAsyncWithHttpInfo($id, $asn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamAsnsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  \OpenAPI\Client\Model\ASNRequest $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamAsnsUpdateAsyncWithHttpInfo($id, $asn_request, string $contentType = self::contentTypes['ipamAsnsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ASN';
        $request = $this->ipamAsnsUpdateRequest($id, $asn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamAsnsUpdate'
     *
     * @param  int $id A unique integer value identifying this ASN. (required)
     * @param  \OpenAPI\Client\Model\ASNRequest $asn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamAsnsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamAsnsUpdateRequest($id, $asn_request, string $contentType = self::contentTypes['ipamAsnsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamAsnsUpdate'
            );
        }

        // verify the required parameter 'asn_request' is set
        if ($asn_request === null || (is_array($asn_request) && count($asn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asn_request when calling ipamAsnsUpdate'
            );
        }


        $resourcePath = '/api/ipam/asns/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($asn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($asn_request));
            } else {
                $httpBody = $asn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamFhrpGroupAssignmentsBulkDestroy($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkDestroy'][0])
    {
        $this->ipamFhrpGroupAssignmentsBulkDestroyWithHttpInfo($fhrp_group_assignment_request, $contentType);
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupAssignmentsBulkDestroyWithHttpInfo($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkDestroy'][0])
    {
        $request = $this->ipamFhrpGroupAssignmentsBulkDestroyRequest($fhrp_group_assignment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsBulkDestroyAsync($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkDestroy'][0])
    {
        return $this->ipamFhrpGroupAssignmentsBulkDestroyAsyncWithHttpInfo($fhrp_group_assignment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsBulkDestroyAsyncWithHttpInfo($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamFhrpGroupAssignmentsBulkDestroyRequest($fhrp_group_assignment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupAssignmentsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupAssignmentsBulkDestroyRequest($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkDestroy'][0])
    {

        // verify the required parameter 'fhrp_group_assignment_request' is set
        if ($fhrp_group_assignment_request === null || (is_array($fhrp_group_assignment_request) && count($fhrp_group_assignment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fhrp_group_assignment_request when calling ipamFhrpGroupAssignmentsBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/fhrp-group-assignments/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fhrp_group_assignment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fhrp_group_assignment_request));
            } else {
                $httpBody = $fhrp_group_assignment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroupAssignment[]
     */
    public function ipamFhrpGroupAssignmentsBulkPartialUpdate($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamFhrpGroupAssignmentsBulkPartialUpdateWithHttpInfo($fhrp_group_assignment_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroupAssignment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupAssignmentsBulkPartialUpdateWithHttpInfo($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkPartialUpdate'][0])
    {
        $request = $this->ipamFhrpGroupAssignmentsBulkPartialUpdateRequest($fhrp_group_assignment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FHRPGroupAssignment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroupAssignment[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroupAssignment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroupAssignment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsBulkPartialUpdateAsync($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkPartialUpdate'][0])
    {
        return $this->ipamFhrpGroupAssignmentsBulkPartialUpdateAsyncWithHttpInfo($fhrp_group_assignment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsBulkPartialUpdateAsyncWithHttpInfo($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment[]';
        $request = $this->ipamFhrpGroupAssignmentsBulkPartialUpdateRequest($fhrp_group_assignment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupAssignmentsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupAssignmentsBulkPartialUpdateRequest($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'fhrp_group_assignment_request' is set
        if ($fhrp_group_assignment_request === null || (is_array($fhrp_group_assignment_request) && count($fhrp_group_assignment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fhrp_group_assignment_request when calling ipamFhrpGroupAssignmentsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/fhrp-group-assignments/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fhrp_group_assignment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fhrp_group_assignment_request));
            } else {
                $httpBody = $fhrp_group_assignment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroupAssignment[]
     */
    public function ipamFhrpGroupAssignmentsBulkUpdate($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkUpdate'][0])
    {
        list($response) = $this->ipamFhrpGroupAssignmentsBulkUpdateWithHttpInfo($fhrp_group_assignment_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroupAssignment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupAssignmentsBulkUpdateWithHttpInfo($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkUpdate'][0])
    {
        $request = $this->ipamFhrpGroupAssignmentsBulkUpdateRequest($fhrp_group_assignment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FHRPGroupAssignment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroupAssignment[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroupAssignment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroupAssignment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsBulkUpdateAsync($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkUpdate'][0])
    {
        return $this->ipamFhrpGroupAssignmentsBulkUpdateAsyncWithHttpInfo($fhrp_group_assignment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsBulkUpdateAsyncWithHttpInfo($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment[]';
        $request = $this->ipamFhrpGroupAssignmentsBulkUpdateRequest($fhrp_group_assignment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupAssignmentsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest[] $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupAssignmentsBulkUpdateRequest($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsBulkUpdate'][0])
    {

        // verify the required parameter 'fhrp_group_assignment_request' is set
        if ($fhrp_group_assignment_request === null || (is_array($fhrp_group_assignment_request) && count($fhrp_group_assignment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fhrp_group_assignment_request when calling ipamFhrpGroupAssignmentsBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/fhrp-group-assignments/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fhrp_group_assignment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fhrp_group_assignment_request));
            } else {
                $httpBody = $fhrp_group_assignment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsCreate
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest $fhrp_group_assignment_request fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroupAssignment
     */
    public function ipamFhrpGroupAssignmentsCreate($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsCreate'][0])
    {
        list($response) = $this->ipamFhrpGroupAssignmentsCreateWithHttpInfo($fhrp_group_assignment_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupAssignmentsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroupAssignment, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupAssignmentsCreateWithHttpInfo($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsCreate'][0])
    {
        $request = $this->ipamFhrpGroupAssignmentsCreateRequest($fhrp_group_assignment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\FHRPGroupAssignment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroupAssignment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroupAssignment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroupAssignment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupAssignmentsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsCreateAsync($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsCreate'][0])
    {
        return $this->ipamFhrpGroupAssignmentsCreateAsyncWithHttpInfo($fhrp_group_assignment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsCreateAsyncWithHttpInfo($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment';
        $request = $this->ipamFhrpGroupAssignmentsCreateRequest($fhrp_group_assignment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupAssignmentsCreate'
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupAssignmentsCreateRequest($fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsCreate'][0])
    {

        // verify the required parameter 'fhrp_group_assignment_request' is set
        if ($fhrp_group_assignment_request === null || (is_array($fhrp_group_assignment_request) && count($fhrp_group_assignment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fhrp_group_assignment_request when calling ipamFhrpGroupAssignmentsCreate'
            );
        }


        $resourcePath = '/api/ipam/fhrp-group-assignments/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fhrp_group_assignment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fhrp_group_assignment_request));
            } else {
                $httpBody = $fhrp_group_assignment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsDestroy
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamFhrpGroupAssignmentsDestroy($id, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsDestroy'][0])
    {
        $this->ipamFhrpGroupAssignmentsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamFhrpGroupAssignmentsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupAssignmentsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsDestroy'][0])
    {
        $request = $this->ipamFhrpGroupAssignmentsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupAssignmentsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsDestroyAsync($id, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsDestroy'][0])
    {
        return $this->ipamFhrpGroupAssignmentsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamFhrpGroupAssignmentsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupAssignmentsDestroy'
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupAssignmentsDestroyRequest($id, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamFhrpGroupAssignmentsDestroy'
            );
        }


        $resourcePath = '/api/ipam/fhrp-group-assignments/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $device device (optional)
     * @param  int[] $device_id device_id (optional)
     * @param  int[] $group_id Group (ID) (optional)
     * @param  int[] $group_id__n Group (ID) (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  int[] $interface_id interface_id (optional)
     * @param  bool $interface_id__empty interface_id__empty (optional)
     * @param  int[] $interface_id__gt interface_id__gt (optional)
     * @param  int[] $interface_id__gte interface_id__gte (optional)
     * @param  int[] $interface_id__lt interface_id__lt (optional)
     * @param  int[] $interface_id__lte interface_id__lte (optional)
     * @param  int[] $interface_id__n interface_id__n (optional)
     * @param  string $interface_type interface_type (optional)
     * @param  string $interface_type__n interface_type__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $priority priority (optional)
     * @param  bool $priority__empty priority__empty (optional)
     * @param  int[] $priority__gt priority__gt (optional)
     * @param  int[] $priority__gte priority__gte (optional)
     * @param  int[] $priority__lt priority__lt (optional)
     * @param  int[] $priority__lte priority__lte (optional)
     * @param  int[] $priority__n priority__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string[] $virtual_machine virtual_machine (optional)
     * @param  int[] $virtual_machine_id virtual_machine_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedFHRPGroupAssignmentList
     */
    public function ipamFhrpGroupAssignmentsList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $device = null, $device_id = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_id = null, $interface_id__empty = null, $interface_id__gt = null, $interface_id__gte = null, $interface_id__lt = null, $interface_id__lte = null, $interface_id__n = null, $interface_type = null, $interface_type__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $priority = null, $priority__empty = null, $priority__gt = null, $priority__gte = null, $priority__lt = null, $priority__lte = null, $priority__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine_id = null, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsList'][0])
    {
        list($response) = $this->ipamFhrpGroupAssignmentsListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $device, $device_id, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_id, $interface_id__empty, $interface_id__gt, $interface_id__gte, $interface_id__lt, $interface_id__lte, $interface_id__n, $interface_type, $interface_type__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $priority, $priority__empty, $priority__gt, $priority__gte, $priority__lt, $priority__lte, $priority__n, $updated_by_request, $virtual_machine, $virtual_machine_id, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupAssignmentsListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $device (optional)
     * @param  int[] $device_id (optional)
     * @param  int[] $group_id Group (ID) (optional)
     * @param  int[] $group_id__n Group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_id (optional)
     * @param  bool $interface_id__empty (optional)
     * @param  int[] $interface_id__gt (optional)
     * @param  int[] $interface_id__gte (optional)
     * @param  int[] $interface_id__lt (optional)
     * @param  int[] $interface_id__lte (optional)
     * @param  int[] $interface_id__n (optional)
     * @param  string $interface_type (optional)
     * @param  string $interface_type__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $priority (optional)
     * @param  bool $priority__empty (optional)
     * @param  int[] $priority__gt (optional)
     * @param  int[] $priority__gte (optional)
     * @param  int[] $priority__lt (optional)
     * @param  int[] $priority__lte (optional)
     * @param  int[] $priority__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine (optional)
     * @param  int[] $virtual_machine_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedFHRPGroupAssignmentList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupAssignmentsListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $device = null, $device_id = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_id = null, $interface_id__empty = null, $interface_id__gt = null, $interface_id__gte = null, $interface_id__lt = null, $interface_id__lte = null, $interface_id__n = null, $interface_type = null, $interface_type__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $priority = null, $priority__empty = null, $priority__gt = null, $priority__gte = null, $priority__lt = null, $priority__lte = null, $priority__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine_id = null, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsList'][0])
    {
        $request = $this->ipamFhrpGroupAssignmentsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $device, $device_id, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_id, $interface_id__empty, $interface_id__gt, $interface_id__gte, $interface_id__lt, $interface_id__lte, $interface_id__n, $interface_type, $interface_type__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $priority, $priority__empty, $priority__gt, $priority__gte, $priority__lt, $priority__lte, $priority__n, $updated_by_request, $virtual_machine, $virtual_machine_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedFHRPGroupAssignmentList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedFHRPGroupAssignmentList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedFHRPGroupAssignmentList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedFHRPGroupAssignmentList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedFHRPGroupAssignmentList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupAssignmentsListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $device (optional)
     * @param  int[] $device_id (optional)
     * @param  int[] $group_id Group (ID) (optional)
     * @param  int[] $group_id__n Group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_id (optional)
     * @param  bool $interface_id__empty (optional)
     * @param  int[] $interface_id__gt (optional)
     * @param  int[] $interface_id__gte (optional)
     * @param  int[] $interface_id__lt (optional)
     * @param  int[] $interface_id__lte (optional)
     * @param  int[] $interface_id__n (optional)
     * @param  string $interface_type (optional)
     * @param  string $interface_type__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $priority (optional)
     * @param  bool $priority__empty (optional)
     * @param  int[] $priority__gt (optional)
     * @param  int[] $priority__gte (optional)
     * @param  int[] $priority__lt (optional)
     * @param  int[] $priority__lte (optional)
     * @param  int[] $priority__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine (optional)
     * @param  int[] $virtual_machine_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $device = null, $device_id = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_id = null, $interface_id__empty = null, $interface_id__gt = null, $interface_id__gte = null, $interface_id__lt = null, $interface_id__lte = null, $interface_id__n = null, $interface_type = null, $interface_type__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $priority = null, $priority__empty = null, $priority__gt = null, $priority__gte = null, $priority__lt = null, $priority__lte = null, $priority__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine_id = null, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsList'][0])
    {
        return $this->ipamFhrpGroupAssignmentsListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $device, $device_id, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_id, $interface_id__empty, $interface_id__gt, $interface_id__gte, $interface_id__lt, $interface_id__lte, $interface_id__n, $interface_type, $interface_type__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $priority, $priority__empty, $priority__gt, $priority__gte, $priority__lt, $priority__lte, $priority__n, $updated_by_request, $virtual_machine, $virtual_machine_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $device (optional)
     * @param  int[] $device_id (optional)
     * @param  int[] $group_id Group (ID) (optional)
     * @param  int[] $group_id__n Group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_id (optional)
     * @param  bool $interface_id__empty (optional)
     * @param  int[] $interface_id__gt (optional)
     * @param  int[] $interface_id__gte (optional)
     * @param  int[] $interface_id__lt (optional)
     * @param  int[] $interface_id__lte (optional)
     * @param  int[] $interface_id__n (optional)
     * @param  string $interface_type (optional)
     * @param  string $interface_type__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $priority (optional)
     * @param  bool $priority__empty (optional)
     * @param  int[] $priority__gt (optional)
     * @param  int[] $priority__gte (optional)
     * @param  int[] $priority__lt (optional)
     * @param  int[] $priority__lte (optional)
     * @param  int[] $priority__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine (optional)
     * @param  int[] $virtual_machine_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $device = null, $device_id = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_id = null, $interface_id__empty = null, $interface_id__gt = null, $interface_id__gte = null, $interface_id__lt = null, $interface_id__lte = null, $interface_id__n = null, $interface_type = null, $interface_type__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $priority = null, $priority__empty = null, $priority__gt = null, $priority__gte = null, $priority__lt = null, $priority__lte = null, $priority__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine_id = null, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedFHRPGroupAssignmentList';
        $request = $this->ipamFhrpGroupAssignmentsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $device, $device_id, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_id, $interface_id__empty, $interface_id__gt, $interface_id__gte, $interface_id__lt, $interface_id__lte, $interface_id__n, $interface_type, $interface_type__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $priority, $priority__empty, $priority__gt, $priority__gte, $priority__lt, $priority__lte, $priority__n, $updated_by_request, $virtual_machine, $virtual_machine_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupAssignmentsList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $device (optional)
     * @param  int[] $device_id (optional)
     * @param  int[] $group_id Group (ID) (optional)
     * @param  int[] $group_id__n Group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_id (optional)
     * @param  bool $interface_id__empty (optional)
     * @param  int[] $interface_id__gt (optional)
     * @param  int[] $interface_id__gte (optional)
     * @param  int[] $interface_id__lt (optional)
     * @param  int[] $interface_id__lte (optional)
     * @param  int[] $interface_id__n (optional)
     * @param  string $interface_type (optional)
     * @param  string $interface_type__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $priority (optional)
     * @param  bool $priority__empty (optional)
     * @param  int[] $priority__gt (optional)
     * @param  int[] $priority__gte (optional)
     * @param  int[] $priority__lt (optional)
     * @param  int[] $priority__lte (optional)
     * @param  int[] $priority__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine (optional)
     * @param  int[] $virtual_machine_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupAssignmentsListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $device = null, $device_id = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_id = null, $interface_id__empty = null, $interface_id__gt = null, $interface_id__gte = null, $interface_id__lt = null, $interface_id__lte = null, $interface_id__n = null, $interface_type = null, $interface_type__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $priority = null, $priority__empty = null, $priority__gt = null, $priority__gte = null, $priority__lt = null, $priority__lte = null, $priority__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine_id = null, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsList'][0])
    {



















































        $resourcePath = '/api/ipam/fhrp-group-assignments/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device,
            'device', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'device_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id,
            'group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__n,
            'group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id,
            'interface_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id__empty,
            'interface_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id__gt,
            'interface_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id__gte,
            'interface_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id__lt,
            'interface_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id__lte,
            'interface_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id__n,
            'interface_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_type,
            'interface_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_type__n,
            'interface_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $priority,
            'priority', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $priority__empty,
            'priority__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $priority__gt,
            'priority__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $priority__gte,
            'priority__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $priority__lt,
            'priority__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $priority__lte,
            'priority__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $priority__n,
            'priority__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine,
            'virtual_machine', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine_id,
            'virtual_machine_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  \OpenAPI\Client\Model\PatchedFHRPGroupAssignmentRequest $patched_fhrp_group_assignment_request patched_fhrp_group_assignment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroupAssignment
     */
    public function ipamFhrpGroupAssignmentsPartialUpdate($id, $patched_fhrp_group_assignment_request = null, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsPartialUpdate'][0])
    {
        list($response) = $this->ipamFhrpGroupAssignmentsPartialUpdateWithHttpInfo($id, $patched_fhrp_group_assignment_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupAssignmentsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  \OpenAPI\Client\Model\PatchedFHRPGroupAssignmentRequest $patched_fhrp_group_assignment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroupAssignment, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupAssignmentsPartialUpdateWithHttpInfo($id, $patched_fhrp_group_assignment_request = null, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsPartialUpdate'][0])
    {
        $request = $this->ipamFhrpGroupAssignmentsPartialUpdateRequest($id, $patched_fhrp_group_assignment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FHRPGroupAssignment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroupAssignment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroupAssignment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroupAssignment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupAssignmentsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  \OpenAPI\Client\Model\PatchedFHRPGroupAssignmentRequest $patched_fhrp_group_assignment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsPartialUpdateAsync($id, $patched_fhrp_group_assignment_request = null, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsPartialUpdate'][0])
    {
        return $this->ipamFhrpGroupAssignmentsPartialUpdateAsyncWithHttpInfo($id, $patched_fhrp_group_assignment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  \OpenAPI\Client\Model\PatchedFHRPGroupAssignmentRequest $patched_fhrp_group_assignment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsPartialUpdateAsyncWithHttpInfo($id, $patched_fhrp_group_assignment_request = null, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment';
        $request = $this->ipamFhrpGroupAssignmentsPartialUpdateRequest($id, $patched_fhrp_group_assignment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupAssignmentsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  \OpenAPI\Client\Model\PatchedFHRPGroupAssignmentRequest $patched_fhrp_group_assignment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupAssignmentsPartialUpdateRequest($id, $patched_fhrp_group_assignment_request = null, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamFhrpGroupAssignmentsPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/fhrp-group-assignments/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_fhrp_group_assignment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_fhrp_group_assignment_request));
            } else {
                $httpBody = $patched_fhrp_group_assignment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsRetrieve
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroupAssignment
     */
    public function ipamFhrpGroupAssignmentsRetrieve($id, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsRetrieve'][0])
    {
        list($response) = $this->ipamFhrpGroupAssignmentsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupAssignmentsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroupAssignment, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupAssignmentsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsRetrieve'][0])
    {
        $request = $this->ipamFhrpGroupAssignmentsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FHRPGroupAssignment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroupAssignment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroupAssignment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroupAssignment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupAssignmentsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsRetrieveAsync($id, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsRetrieve'][0])
    {
        return $this->ipamFhrpGroupAssignmentsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment';
        $request = $this->ipamFhrpGroupAssignmentsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupAssignmentsRetrieve'
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupAssignmentsRetrieveRequest($id, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamFhrpGroupAssignmentsRetrieve'
            );
        }


        $resourcePath = '/api/ipam/fhrp-group-assignments/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsUpdate
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest $fhrp_group_assignment_request fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroupAssignment
     */
    public function ipamFhrpGroupAssignmentsUpdate($id, $fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsUpdate'][0])
    {
        list($response) = $this->ipamFhrpGroupAssignmentsUpdateWithHttpInfo($id, $fhrp_group_assignment_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupAssignmentsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroupAssignment, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupAssignmentsUpdateWithHttpInfo($id, $fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsUpdate'][0])
    {
        $request = $this->ipamFhrpGroupAssignmentsUpdateRequest($id, $fhrp_group_assignment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FHRPGroupAssignment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroupAssignment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroupAssignment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroupAssignment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupAssignmentsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsUpdateAsync($id, $fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsUpdate'][0])
    {
        return $this->ipamFhrpGroupAssignmentsUpdateAsyncWithHttpInfo($id, $fhrp_group_assignment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupAssignmentsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupAssignmentsUpdateAsyncWithHttpInfo($id, $fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroupAssignment';
        $request = $this->ipamFhrpGroupAssignmentsUpdateRequest($id, $fhrp_group_assignment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupAssignmentsUpdate'
     *
     * @param  int $id A unique integer value identifying this FHRP group assignment. (required)
     * @param  \OpenAPI\Client\Model\FHRPGroupAssignmentRequest $fhrp_group_assignment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupAssignmentsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupAssignmentsUpdateRequest($id, $fhrp_group_assignment_request, string $contentType = self::contentTypes['ipamFhrpGroupAssignmentsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamFhrpGroupAssignmentsUpdate'
            );
        }

        // verify the required parameter 'fhrp_group_assignment_request' is set
        if ($fhrp_group_assignment_request === null || (is_array($fhrp_group_assignment_request) && count($fhrp_group_assignment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fhrp_group_assignment_request when calling ipamFhrpGroupAssignmentsUpdate'
            );
        }


        $resourcePath = '/api/ipam/fhrp-group-assignments/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fhrp_group_assignment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fhrp_group_assignment_request));
            } else {
                $httpBody = $fhrp_group_assignment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamFhrpGroupsBulkDestroy($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkDestroy'][0])
    {
        $this->ipamFhrpGroupsBulkDestroyWithHttpInfo($fhrp_group_request, $contentType);
    }

    /**
     * Operation ipamFhrpGroupsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupsBulkDestroyWithHttpInfo($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkDestroy'][0])
    {
        $request = $this->ipamFhrpGroupsBulkDestroyRequest($fhrp_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsBulkDestroyAsync($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkDestroy'][0])
    {
        return $this->ipamFhrpGroupsBulkDestroyAsyncWithHttpInfo($fhrp_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsBulkDestroyAsyncWithHttpInfo($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamFhrpGroupsBulkDestroyRequest($fhrp_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupsBulkDestroyRequest($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkDestroy'][0])
    {

        // verify the required parameter 'fhrp_group_request' is set
        if ($fhrp_group_request === null || (is_array($fhrp_group_request) && count($fhrp_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fhrp_group_request when calling ipamFhrpGroupsBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/fhrp-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fhrp_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fhrp_group_request));
            } else {
                $httpBody = $fhrp_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroup[]
     */
    public function ipamFhrpGroupsBulkPartialUpdate($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamFhrpGroupsBulkPartialUpdateWithHttpInfo($fhrp_group_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupsBulkPartialUpdateWithHttpInfo($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkPartialUpdate'][0])
    {
        $request = $this->ipamFhrpGroupsBulkPartialUpdateRequest($fhrp_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FHRPGroup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroup[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsBulkPartialUpdateAsync($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkPartialUpdate'][0])
    {
        return $this->ipamFhrpGroupsBulkPartialUpdateAsyncWithHttpInfo($fhrp_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsBulkPartialUpdateAsyncWithHttpInfo($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroup[]';
        $request = $this->ipamFhrpGroupsBulkPartialUpdateRequest($fhrp_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupsBulkPartialUpdateRequest($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'fhrp_group_request' is set
        if ($fhrp_group_request === null || (is_array($fhrp_group_request) && count($fhrp_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fhrp_group_request when calling ipamFhrpGroupsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/fhrp-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fhrp_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fhrp_group_request));
            } else {
                $httpBody = $fhrp_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroup[]
     */
    public function ipamFhrpGroupsBulkUpdate($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkUpdate'][0])
    {
        list($response) = $this->ipamFhrpGroupsBulkUpdateWithHttpInfo($fhrp_group_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupsBulkUpdateWithHttpInfo($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkUpdate'][0])
    {
        $request = $this->ipamFhrpGroupsBulkUpdateRequest($fhrp_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FHRPGroup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroup[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsBulkUpdateAsync($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkUpdate'][0])
    {
        return $this->ipamFhrpGroupsBulkUpdateAsyncWithHttpInfo($fhrp_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsBulkUpdateAsyncWithHttpInfo($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroup[]';
        $request = $this->ipamFhrpGroupsBulkUpdateRequest($fhrp_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest[] $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupsBulkUpdateRequest($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsBulkUpdate'][0])
    {

        // verify the required parameter 'fhrp_group_request' is set
        if ($fhrp_group_request === null || (is_array($fhrp_group_request) && count($fhrp_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fhrp_group_request when calling ipamFhrpGroupsBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/fhrp-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fhrp_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fhrp_group_request));
            } else {
                $httpBody = $fhrp_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupsCreate
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest $fhrp_group_request fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroup
     */
    public function ipamFhrpGroupsCreate($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsCreate'][0])
    {
        list($response) = $this->ipamFhrpGroupsCreateWithHttpInfo($fhrp_group_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupsCreateWithHttpInfo($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsCreate'][0])
    {
        $request = $this->ipamFhrpGroupsCreateRequest($fhrp_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\FHRPGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsCreateAsync($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsCreate'][0])
    {
        return $this->ipamFhrpGroupsCreateAsyncWithHttpInfo($fhrp_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsCreateAsyncWithHttpInfo($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroup';
        $request = $this->ipamFhrpGroupsCreateRequest($fhrp_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupsCreate'
     *
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupsCreateRequest($fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsCreate'][0])
    {

        // verify the required parameter 'fhrp_group_request' is set
        if ($fhrp_group_request === null || (is_array($fhrp_group_request) && count($fhrp_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fhrp_group_request when calling ipamFhrpGroupsCreate'
            );
        }


        $resourcePath = '/api/ipam/fhrp-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fhrp_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fhrp_group_request));
            } else {
                $httpBody = $fhrp_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupsDestroy
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamFhrpGroupsDestroy($id, string $contentType = self::contentTypes['ipamFhrpGroupsDestroy'][0])
    {
        $this->ipamFhrpGroupsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamFhrpGroupsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamFhrpGroupsDestroy'][0])
    {
        $request = $this->ipamFhrpGroupsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsDestroyAsync($id, string $contentType = self::contentTypes['ipamFhrpGroupsDestroy'][0])
    {
        return $this->ipamFhrpGroupsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamFhrpGroupsDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamFhrpGroupsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupsDestroy'
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupsDestroyRequest($id, string $contentType = self::contentTypes['ipamFhrpGroupsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamFhrpGroupsDestroy'
            );
        }


        $resourcePath = '/api/ipam/fhrp-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupsList
     *
     * @param  string[] $auth_key auth_key (optional)
     * @param  bool $auth_key__empty auth_key__empty (optional)
     * @param  string[] $auth_key__ic auth_key__ic (optional)
     * @param  string[] $auth_key__ie auth_key__ie (optional)
     * @param  string[] $auth_key__iew auth_key__iew (optional)
     * @param  string[] $auth_key__isw auth_key__isw (optional)
     * @param  string[] $auth_key__n auth_key__n (optional)
     * @param  string[] $auth_key__nic auth_key__nic (optional)
     * @param  string[] $auth_key__nie auth_key__nie (optional)
     * @param  string[] $auth_key__niew auth_key__niew (optional)
     * @param  string[] $auth_key__nisw auth_key__nisw (optional)
     * @param  string[] $auth_type auth_type (optional)
     * @param  string[] $auth_type__n auth_type__n (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $group_id group_id (optional)
     * @param  bool $group_id__empty group_id__empty (optional)
     * @param  int[] $group_id__gt group_id__gt (optional)
     * @param  int[] $group_id__gte group_id__gte (optional)
     * @param  int[] $group_id__lt group_id__lt (optional)
     * @param  int[] $group_id__lte group_id__lte (optional)
     * @param  int[] $group_id__n group_id__n (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $protocol protocol (optional)
     * @param  string[] $protocol__n protocol__n (optional)
     * @param  string $q Search (optional)
     * @param  string[] $related_ip related_ip (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedFHRPGroupList
     */
    public function ipamFhrpGroupsList($auth_key = null, $auth_key__empty = null, $auth_key__ic = null, $auth_key__ie = null, $auth_key__iew = null, $auth_key__isw = null, $auth_key__n = null, $auth_key__nic = null, $auth_key__nie = null, $auth_key__niew = null, $auth_key__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group_id = null, $group_id__empty = null, $group_id__gt = null, $group_id__gte = null, $group_id__lt = null, $group_id__lte = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $protocol = null, $protocol__n = null, $q = null, $related_ip = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamFhrpGroupsList'][0])
    {
        list($response) = $this->ipamFhrpGroupsListWithHttpInfo($auth_key, $auth_key__empty, $auth_key__ic, $auth_key__ie, $auth_key__iew, $auth_key__isw, $auth_key__n, $auth_key__nic, $auth_key__nie, $auth_key__niew, $auth_key__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group_id, $group_id__empty, $group_id__gt, $group_id__gte, $group_id__lt, $group_id__lte, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $protocol, $protocol__n, $q, $related_ip, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupsListWithHttpInfo
     *
     * @param  string[] $auth_key (optional)
     * @param  bool $auth_key__empty (optional)
     * @param  string[] $auth_key__ic (optional)
     * @param  string[] $auth_key__ie (optional)
     * @param  string[] $auth_key__iew (optional)
     * @param  string[] $auth_key__isw (optional)
     * @param  string[] $auth_key__n (optional)
     * @param  string[] $auth_key__nic (optional)
     * @param  string[] $auth_key__nie (optional)
     * @param  string[] $auth_key__niew (optional)
     * @param  string[] $auth_key__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $group_id (optional)
     * @param  bool $group_id__empty (optional)
     * @param  int[] $group_id__gt (optional)
     * @param  int[] $group_id__gte (optional)
     * @param  int[] $group_id__lt (optional)
     * @param  int[] $group_id__lte (optional)
     * @param  int[] $group_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $protocol (optional)
     * @param  string[] $protocol__n (optional)
     * @param  string $q Search (optional)
     * @param  string[] $related_ip (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedFHRPGroupList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupsListWithHttpInfo($auth_key = null, $auth_key__empty = null, $auth_key__ic = null, $auth_key__ie = null, $auth_key__iew = null, $auth_key__isw = null, $auth_key__n = null, $auth_key__nic = null, $auth_key__nie = null, $auth_key__niew = null, $auth_key__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group_id = null, $group_id__empty = null, $group_id__gt = null, $group_id__gte = null, $group_id__lt = null, $group_id__lte = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $protocol = null, $protocol__n = null, $q = null, $related_ip = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamFhrpGroupsList'][0])
    {
        $request = $this->ipamFhrpGroupsListRequest($auth_key, $auth_key__empty, $auth_key__ic, $auth_key__ie, $auth_key__iew, $auth_key__isw, $auth_key__n, $auth_key__nic, $auth_key__nie, $auth_key__niew, $auth_key__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group_id, $group_id__empty, $group_id__gt, $group_id__gte, $group_id__lt, $group_id__lte, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $protocol, $protocol__n, $q, $related_ip, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedFHRPGroupList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedFHRPGroupList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedFHRPGroupList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedFHRPGroupList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedFHRPGroupList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupsListAsync
     *
     * @param  string[] $auth_key (optional)
     * @param  bool $auth_key__empty (optional)
     * @param  string[] $auth_key__ic (optional)
     * @param  string[] $auth_key__ie (optional)
     * @param  string[] $auth_key__iew (optional)
     * @param  string[] $auth_key__isw (optional)
     * @param  string[] $auth_key__n (optional)
     * @param  string[] $auth_key__nic (optional)
     * @param  string[] $auth_key__nie (optional)
     * @param  string[] $auth_key__niew (optional)
     * @param  string[] $auth_key__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $group_id (optional)
     * @param  bool $group_id__empty (optional)
     * @param  int[] $group_id__gt (optional)
     * @param  int[] $group_id__gte (optional)
     * @param  int[] $group_id__lt (optional)
     * @param  int[] $group_id__lte (optional)
     * @param  int[] $group_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $protocol (optional)
     * @param  string[] $protocol__n (optional)
     * @param  string $q Search (optional)
     * @param  string[] $related_ip (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsListAsync($auth_key = null, $auth_key__empty = null, $auth_key__ic = null, $auth_key__ie = null, $auth_key__iew = null, $auth_key__isw = null, $auth_key__n = null, $auth_key__nic = null, $auth_key__nie = null, $auth_key__niew = null, $auth_key__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group_id = null, $group_id__empty = null, $group_id__gt = null, $group_id__gte = null, $group_id__lt = null, $group_id__lte = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $protocol = null, $protocol__n = null, $q = null, $related_ip = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamFhrpGroupsList'][0])
    {
        return $this->ipamFhrpGroupsListAsyncWithHttpInfo($auth_key, $auth_key__empty, $auth_key__ic, $auth_key__ie, $auth_key__iew, $auth_key__isw, $auth_key__n, $auth_key__nic, $auth_key__nie, $auth_key__niew, $auth_key__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group_id, $group_id__empty, $group_id__gt, $group_id__gte, $group_id__lt, $group_id__lte, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $protocol, $protocol__n, $q, $related_ip, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupsListAsyncWithHttpInfo
     *
     * @param  string[] $auth_key (optional)
     * @param  bool $auth_key__empty (optional)
     * @param  string[] $auth_key__ic (optional)
     * @param  string[] $auth_key__ie (optional)
     * @param  string[] $auth_key__iew (optional)
     * @param  string[] $auth_key__isw (optional)
     * @param  string[] $auth_key__n (optional)
     * @param  string[] $auth_key__nic (optional)
     * @param  string[] $auth_key__nie (optional)
     * @param  string[] $auth_key__niew (optional)
     * @param  string[] $auth_key__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $group_id (optional)
     * @param  bool $group_id__empty (optional)
     * @param  int[] $group_id__gt (optional)
     * @param  int[] $group_id__gte (optional)
     * @param  int[] $group_id__lt (optional)
     * @param  int[] $group_id__lte (optional)
     * @param  int[] $group_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $protocol (optional)
     * @param  string[] $protocol__n (optional)
     * @param  string $q Search (optional)
     * @param  string[] $related_ip (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsListAsyncWithHttpInfo($auth_key = null, $auth_key__empty = null, $auth_key__ic = null, $auth_key__ie = null, $auth_key__iew = null, $auth_key__isw = null, $auth_key__n = null, $auth_key__nic = null, $auth_key__nie = null, $auth_key__niew = null, $auth_key__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group_id = null, $group_id__empty = null, $group_id__gt = null, $group_id__gte = null, $group_id__lt = null, $group_id__lte = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $protocol = null, $protocol__n = null, $q = null, $related_ip = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamFhrpGroupsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedFHRPGroupList';
        $request = $this->ipamFhrpGroupsListRequest($auth_key, $auth_key__empty, $auth_key__ic, $auth_key__ie, $auth_key__iew, $auth_key__isw, $auth_key__n, $auth_key__nic, $auth_key__nie, $auth_key__niew, $auth_key__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group_id, $group_id__empty, $group_id__gt, $group_id__gte, $group_id__lt, $group_id__lte, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $protocol, $protocol__n, $q, $related_ip, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupsList'
     *
     * @param  string[] $auth_key (optional)
     * @param  bool $auth_key__empty (optional)
     * @param  string[] $auth_key__ic (optional)
     * @param  string[] $auth_key__ie (optional)
     * @param  string[] $auth_key__iew (optional)
     * @param  string[] $auth_key__isw (optional)
     * @param  string[] $auth_key__n (optional)
     * @param  string[] $auth_key__nic (optional)
     * @param  string[] $auth_key__nie (optional)
     * @param  string[] $auth_key__niew (optional)
     * @param  string[] $auth_key__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $group_id (optional)
     * @param  bool $group_id__empty (optional)
     * @param  int[] $group_id__gt (optional)
     * @param  int[] $group_id__gte (optional)
     * @param  int[] $group_id__lt (optional)
     * @param  int[] $group_id__lte (optional)
     * @param  int[] $group_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $protocol (optional)
     * @param  string[] $protocol__n (optional)
     * @param  string $q Search (optional)
     * @param  string[] $related_ip (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupsListRequest($auth_key = null, $auth_key__empty = null, $auth_key__ic = null, $auth_key__ie = null, $auth_key__iew = null, $auth_key__isw = null, $auth_key__n = null, $auth_key__nic = null, $auth_key__nie = null, $auth_key__niew = null, $auth_key__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group_id = null, $group_id__empty = null, $group_id__gt = null, $group_id__gte = null, $group_id__lt = null, $group_id__lte = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $protocol = null, $protocol__n = null, $q = null, $related_ip = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamFhrpGroupsList'][0])
    {













































































        $resourcePath = '/api/ipam/fhrp-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_key,
            'auth_key', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_key__empty,
            'auth_key__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_key__ic,
            'auth_key__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_key__ie,
            'auth_key__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_key__iew,
            'auth_key__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_key__isw,
            'auth_key__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_key__n,
            'auth_key__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_key__nic,
            'auth_key__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_key__nie,
            'auth_key__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_key__niew,
            'auth_key__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_key__nisw,
            'auth_key__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_type,
            'auth_type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_type__n,
            'auth_type__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id,
            'group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__empty,
            'group_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__gt,
            'group_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__gte,
            'group_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__lt,
            'group_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__lte,
            'group_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__n,
            'group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $protocol,
            'protocol', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $protocol__n,
            'protocol__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_ip,
            'related_ip', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  \OpenAPI\Client\Model\PatchedFHRPGroupRequest $patched_fhrp_group_request patched_fhrp_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroup
     */
    public function ipamFhrpGroupsPartialUpdate($id, $patched_fhrp_group_request = null, string $contentType = self::contentTypes['ipamFhrpGroupsPartialUpdate'][0])
    {
        list($response) = $this->ipamFhrpGroupsPartialUpdateWithHttpInfo($id, $patched_fhrp_group_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  \OpenAPI\Client\Model\PatchedFHRPGroupRequest $patched_fhrp_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupsPartialUpdateWithHttpInfo($id, $patched_fhrp_group_request = null, string $contentType = self::contentTypes['ipamFhrpGroupsPartialUpdate'][0])
    {
        $request = $this->ipamFhrpGroupsPartialUpdateRequest($id, $patched_fhrp_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FHRPGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  \OpenAPI\Client\Model\PatchedFHRPGroupRequest $patched_fhrp_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsPartialUpdateAsync($id, $patched_fhrp_group_request = null, string $contentType = self::contentTypes['ipamFhrpGroupsPartialUpdate'][0])
    {
        return $this->ipamFhrpGroupsPartialUpdateAsyncWithHttpInfo($id, $patched_fhrp_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  \OpenAPI\Client\Model\PatchedFHRPGroupRequest $patched_fhrp_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsPartialUpdateAsyncWithHttpInfo($id, $patched_fhrp_group_request = null, string $contentType = self::contentTypes['ipamFhrpGroupsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroup';
        $request = $this->ipamFhrpGroupsPartialUpdateRequest($id, $patched_fhrp_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  \OpenAPI\Client\Model\PatchedFHRPGroupRequest $patched_fhrp_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupsPartialUpdateRequest($id, $patched_fhrp_group_request = null, string $contentType = self::contentTypes['ipamFhrpGroupsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamFhrpGroupsPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/fhrp-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_fhrp_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_fhrp_group_request));
            } else {
                $httpBody = $patched_fhrp_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupsRetrieve
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroup
     */
    public function ipamFhrpGroupsRetrieve($id, string $contentType = self::contentTypes['ipamFhrpGroupsRetrieve'][0])
    {
        list($response) = $this->ipamFhrpGroupsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamFhrpGroupsRetrieve'][0])
    {
        $request = $this->ipamFhrpGroupsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FHRPGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsRetrieveAsync($id, string $contentType = self::contentTypes['ipamFhrpGroupsRetrieve'][0])
    {
        return $this->ipamFhrpGroupsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamFhrpGroupsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroup';
        $request = $this->ipamFhrpGroupsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupsRetrieve'
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupsRetrieveRequest($id, string $contentType = self::contentTypes['ipamFhrpGroupsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamFhrpGroupsRetrieve'
            );
        }


        $resourcePath = '/api/ipam/fhrp-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamFhrpGroupsUpdate
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest $fhrp_group_request fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FHRPGroup
     */
    public function ipamFhrpGroupsUpdate($id, $fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsUpdate'][0])
    {
        list($response) = $this->ipamFhrpGroupsUpdateWithHttpInfo($id, $fhrp_group_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamFhrpGroupsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FHRPGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamFhrpGroupsUpdateWithHttpInfo($id, $fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsUpdate'][0])
    {
        $request = $this->ipamFhrpGroupsUpdateRequest($id, $fhrp_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FHRPGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FHRPGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FHRPGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FHRPGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FHRPGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamFhrpGroupsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsUpdateAsync($id, $fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsUpdate'][0])
    {
        return $this->ipamFhrpGroupsUpdateAsyncWithHttpInfo($id, $fhrp_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamFhrpGroupsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamFhrpGroupsUpdateAsyncWithHttpInfo($id, $fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FHRPGroup';
        $request = $this->ipamFhrpGroupsUpdateRequest($id, $fhrp_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamFhrpGroupsUpdate'
     *
     * @param  int $id A unique integer value identifying this FHRP group. (required)
     * @param  \OpenAPI\Client\Model\FHRPGroupRequest $fhrp_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamFhrpGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamFhrpGroupsUpdateRequest($id, $fhrp_group_request, string $contentType = self::contentTypes['ipamFhrpGroupsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamFhrpGroupsUpdate'
            );
        }

        // verify the required parameter 'fhrp_group_request' is set
        if ($fhrp_group_request === null || (is_array($fhrp_group_request) && count($fhrp_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fhrp_group_request when calling ipamFhrpGroupsUpdate'
            );
        }


        $resourcePath = '/api/ipam/fhrp-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fhrp_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fhrp_group_request));
            } else {
                $httpBody = $fhrp_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpAddressesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamIpAddressesBulkDestroy($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkDestroy'][0])
    {
        $this->ipamIpAddressesBulkDestroyWithHttpInfo($ip_address_request, $contentType);
    }

    /**
     * Operation ipamIpAddressesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpAddressesBulkDestroyWithHttpInfo($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkDestroy'][0])
    {
        $request = $this->ipamIpAddressesBulkDestroyRequest($ip_address_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpAddressesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesBulkDestroyAsync($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkDestroy'][0])
    {
        return $this->ipamIpAddressesBulkDestroyAsyncWithHttpInfo($ip_address_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpAddressesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesBulkDestroyAsyncWithHttpInfo($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamIpAddressesBulkDestroyRequest($ip_address_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpAddressesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpAddressesBulkDestroyRequest($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkDestroy'][0])
    {

        // verify the required parameter 'ip_address_request' is set
        if ($ip_address_request === null || (is_array($ip_address_request) && count($ip_address_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_address_request when calling ipamIpAddressesBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/ip-addresses/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_address_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_address_request));
            } else {
                $httpBody = $ip_address_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpAddressesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPAddress[]
     */
    public function ipamIpAddressesBulkPartialUpdate($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamIpAddressesBulkPartialUpdateWithHttpInfo($ip_address_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpAddressesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPAddress[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpAddressesBulkPartialUpdateWithHttpInfo($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkPartialUpdate'][0])
    {
        $request = $this->ipamIpAddressesBulkPartialUpdateRequest($ip_address_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPAddress[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPAddress[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPAddress[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPAddress[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpAddressesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesBulkPartialUpdateAsync($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkPartialUpdate'][0])
    {
        return $this->ipamIpAddressesBulkPartialUpdateAsyncWithHttpInfo($ip_address_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpAddressesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesBulkPartialUpdateAsyncWithHttpInfo($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPAddress[]';
        $request = $this->ipamIpAddressesBulkPartialUpdateRequest($ip_address_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpAddressesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpAddressesBulkPartialUpdateRequest($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'ip_address_request' is set
        if ($ip_address_request === null || (is_array($ip_address_request) && count($ip_address_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_address_request when calling ipamIpAddressesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/ip-addresses/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_address_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_address_request));
            } else {
                $httpBody = $ip_address_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpAddressesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPAddress[]
     */
    public function ipamIpAddressesBulkUpdate($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkUpdate'][0])
    {
        list($response) = $this->ipamIpAddressesBulkUpdateWithHttpInfo($ip_address_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpAddressesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPAddress[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpAddressesBulkUpdateWithHttpInfo($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkUpdate'][0])
    {
        $request = $this->ipamIpAddressesBulkUpdateRequest($ip_address_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPAddress[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPAddress[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPAddress[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPAddress[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpAddressesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesBulkUpdateAsync($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkUpdate'][0])
    {
        return $this->ipamIpAddressesBulkUpdateAsyncWithHttpInfo($ip_address_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpAddressesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesBulkUpdateAsyncWithHttpInfo($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPAddress[]';
        $request = $this->ipamIpAddressesBulkUpdateRequest($ip_address_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpAddressesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpAddressesBulkUpdateRequest($ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesBulkUpdate'][0])
    {

        // verify the required parameter 'ip_address_request' is set
        if ($ip_address_request === null || (is_array($ip_address_request) && count($ip_address_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_address_request when calling ipamIpAddressesBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/ip-addresses/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_address_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_address_request));
            } else {
                $httpBody = $ip_address_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpAddressesCreate
     *
     * @param  \OpenAPI\Client\Model\WritableIPAddressRequest $writable_ip_address_request writable_ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPAddress
     */
    public function ipamIpAddressesCreate($writable_ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesCreate'][0])
    {
        list($response) = $this->ipamIpAddressesCreateWithHttpInfo($writable_ip_address_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpAddressesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIPAddressRequest $writable_ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpAddressesCreateWithHttpInfo($writable_ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesCreate'][0])
    {
        $request = $this->ipamIpAddressesCreateRequest($writable_ip_address_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\IPAddress' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPAddress' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPAddress', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPAddress';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpAddressesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableIPAddressRequest $writable_ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesCreateAsync($writable_ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesCreate'][0])
    {
        return $this->ipamIpAddressesCreateAsyncWithHttpInfo($writable_ip_address_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpAddressesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIPAddressRequest $writable_ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesCreateAsyncWithHttpInfo($writable_ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPAddress';
        $request = $this->ipamIpAddressesCreateRequest($writable_ip_address_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpAddressesCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableIPAddressRequest $writable_ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpAddressesCreateRequest($writable_ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesCreate'][0])
    {

        // verify the required parameter 'writable_ip_address_request' is set
        if ($writable_ip_address_request === null || (is_array($writable_ip_address_request) && count($writable_ip_address_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ip_address_request when calling ipamIpAddressesCreate'
            );
        }


        $resourcePath = '/api/ipam/ip-addresses/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ip_address_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ip_address_request));
            } else {
                $httpBody = $writable_ip_address_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpAddressesDestroy
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamIpAddressesDestroy($id, string $contentType = self::contentTypes['ipamIpAddressesDestroy'][0])
    {
        $this->ipamIpAddressesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamIpAddressesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpAddressesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamIpAddressesDestroy'][0])
    {
        $request = $this->ipamIpAddressesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpAddressesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesDestroyAsync($id, string $contentType = self::contentTypes['ipamIpAddressesDestroy'][0])
    {
        return $this->ipamIpAddressesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpAddressesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamIpAddressesDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamIpAddressesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpAddressesDestroy'
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpAddressesDestroyRequest($id, string $contentType = self::contentTypes['ipamIpAddressesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamIpAddressesDestroy'
            );
        }


        $resourcePath = '/api/ipam/ip-addresses/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpAddressesList
     *
     * @param  string[] $address address (optional)
     * @param  bool $assigned Is assigned (optional)
     * @param  int[] $assigned_object_id assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n assigned_object_id__n (optional)
     * @param  int $assigned_object_type assigned_object_type (optional)
     * @param  int $assigned_object_type__n assigned_object_type__n (optional)
     * @param  bool $assigned_to_interface Is assigned to an interface (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $device device (optional)
     * @param  int[] $device_id device_id (optional)
     * @param  string[] $dns_name dns_name (optional)
     * @param  bool $dns_name__empty dns_name__empty (optional)
     * @param  string[] $dns_name__ic dns_name__ic (optional)
     * @param  string[] $dns_name__ie dns_name__ie (optional)
     * @param  string[] $dns_name__iew dns_name__iew (optional)
     * @param  string[] $dns_name__isw dns_name__isw (optional)
     * @param  string[] $dns_name__n dns_name__n (optional)
     * @param  string[] $dns_name__nic dns_name__nic (optional)
     * @param  string[] $dns_name__nie dns_name__nie (optional)
     * @param  string[] $dns_name__niew dns_name__niew (optional)
     * @param  string[] $dns_name__nisw dns_name__nisw (optional)
     * @param  float $family family (optional)
     * @param  int[] $fhrpgroup_id FHRP group (ID) (optional)
     * @param  int[] $fhrpgroup_id__n FHRP group (ID) (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $mask_length mask_length (optional)
     * @param  float $mask_length__gte mask_length__gte (optional)
     * @param  float $mask_length__lte mask_length__lte (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int[] $nat_inside_id NAT inside IP address (ID) (optional)
     * @param  int[] $nat_inside_id__n NAT inside IP address (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent parent (optional)
     * @param  string $present_in_vrf present_in_vrf (optional)
     * @param  string $present_in_vrf_id present_in_vrf_id (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role The functional role of this IP (optional)
     * @param  string[] $role__n The functional role of this IP (optional)
     * @param  int[] $service_id Service (ID) (optional)
     * @param  int[] $service_id__n Service (ID) (optional)
     * @param  string[] $status The operational status of this IP (optional)
     * @param  string[] $status__n The operational status of this IP (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string[] $virtual_machine virtual_machine (optional)
     * @param  int[] $virtual_machine_id virtual_machine_id (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM interface (ID) (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedIPAddressList
     */
    public function ipamIpAddressesList($address = null, $assigned = null, $assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $assigned_to_interface = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device = null, $device_id = null, $dns_name = null, $dns_name__empty = null, $dns_name__ic = null, $dns_name__ie = null, $dns_name__iew = null, $dns_name__isw = null, $dns_name__n = null, $dns_name__nic = null, $dns_name__nie = null, $dns_name__niew = null, $dns_name__nisw = null, $family = null, $fhrpgroup_id = null, $fhrpgroup_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mask_length = null, $mask_length__gte = null, $mask_length__lte = null, $modified_by_request = null, $nat_inside_id = null, $nat_inside_id__n = null, $offset = null, $ordering = null, $parent = null, $present_in_vrf = null, $present_in_vrf_id = null, $q = null, $role = null, $role__n = null, $service_id = null, $service_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine_id = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, string $contentType = self::contentTypes['ipamIpAddressesList'][0])
    {
        list($response) = $this->ipamIpAddressesListWithHttpInfo($address, $assigned, $assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $assigned_to_interface, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device, $device_id, $dns_name, $dns_name__empty, $dns_name__ic, $dns_name__ie, $dns_name__iew, $dns_name__isw, $dns_name__n, $dns_name__nic, $dns_name__nie, $dns_name__niew, $dns_name__nisw, $family, $fhrpgroup_id, $fhrpgroup_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mask_length, $mask_length__gte, $mask_length__lte, $modified_by_request, $nat_inside_id, $nat_inside_id__n, $offset, $ordering, $parent, $present_in_vrf, $present_in_vrf_id, $q, $role, $role__n, $service_id, $service_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $virtual_machine, $virtual_machine_id, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpAddressesListWithHttpInfo
     *
     * @param  string[] $address (optional)
     * @param  bool $assigned Is assigned (optional)
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  int $assigned_object_type (optional)
     * @param  int $assigned_object_type__n (optional)
     * @param  bool $assigned_to_interface Is assigned to an interface (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device (optional)
     * @param  int[] $device_id (optional)
     * @param  string[] $dns_name (optional)
     * @param  bool $dns_name__empty (optional)
     * @param  string[] $dns_name__ic (optional)
     * @param  string[] $dns_name__ie (optional)
     * @param  string[] $dns_name__iew (optional)
     * @param  string[] $dns_name__isw (optional)
     * @param  string[] $dns_name__n (optional)
     * @param  string[] $dns_name__nic (optional)
     * @param  string[] $dns_name__nie (optional)
     * @param  string[] $dns_name__niew (optional)
     * @param  string[] $dns_name__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $fhrpgroup_id FHRP group (ID) (optional)
     * @param  int[] $fhrpgroup_id__n FHRP group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $mask_length (optional)
     * @param  float $mask_length__gte (optional)
     * @param  float $mask_length__lte (optional)
     * @param  string $modified_by_request (optional)
     * @param  int[] $nat_inside_id NAT inside IP address (ID) (optional)
     * @param  int[] $nat_inside_id__n NAT inside IP address (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string $present_in_vrf (optional)
     * @param  string $present_in_vrf_id (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role The functional role of this IP (optional)
     * @param  string[] $role__n The functional role of this IP (optional)
     * @param  int[] $service_id Service (ID) (optional)
     * @param  int[] $service_id__n Service (ID) (optional)
     * @param  string[] $status The operational status of this IP (optional)
     * @param  string[] $status__n The operational status of this IP (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine (optional)
     * @param  int[] $virtual_machine_id (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM interface (ID) (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedIPAddressList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpAddressesListWithHttpInfo($address = null, $assigned = null, $assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $assigned_to_interface = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device = null, $device_id = null, $dns_name = null, $dns_name__empty = null, $dns_name__ic = null, $dns_name__ie = null, $dns_name__iew = null, $dns_name__isw = null, $dns_name__n = null, $dns_name__nic = null, $dns_name__nie = null, $dns_name__niew = null, $dns_name__nisw = null, $family = null, $fhrpgroup_id = null, $fhrpgroup_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mask_length = null, $mask_length__gte = null, $mask_length__lte = null, $modified_by_request = null, $nat_inside_id = null, $nat_inside_id__n = null, $offset = null, $ordering = null, $parent = null, $present_in_vrf = null, $present_in_vrf_id = null, $q = null, $role = null, $role__n = null, $service_id = null, $service_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine_id = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, string $contentType = self::contentTypes['ipamIpAddressesList'][0])
    {
        $request = $this->ipamIpAddressesListRequest($address, $assigned, $assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $assigned_to_interface, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device, $device_id, $dns_name, $dns_name__empty, $dns_name__ic, $dns_name__ie, $dns_name__iew, $dns_name__isw, $dns_name__n, $dns_name__nic, $dns_name__nie, $dns_name__niew, $dns_name__nisw, $family, $fhrpgroup_id, $fhrpgroup_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mask_length, $mask_length__gte, $mask_length__lte, $modified_by_request, $nat_inside_id, $nat_inside_id__n, $offset, $ordering, $parent, $present_in_vrf, $present_in_vrf_id, $q, $role, $role__n, $service_id, $service_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $virtual_machine, $virtual_machine_id, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedIPAddressList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedIPAddressList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedIPAddressList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedIPAddressList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedIPAddressList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpAddressesListAsync
     *
     * @param  string[] $address (optional)
     * @param  bool $assigned Is assigned (optional)
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  int $assigned_object_type (optional)
     * @param  int $assigned_object_type__n (optional)
     * @param  bool $assigned_to_interface Is assigned to an interface (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device (optional)
     * @param  int[] $device_id (optional)
     * @param  string[] $dns_name (optional)
     * @param  bool $dns_name__empty (optional)
     * @param  string[] $dns_name__ic (optional)
     * @param  string[] $dns_name__ie (optional)
     * @param  string[] $dns_name__iew (optional)
     * @param  string[] $dns_name__isw (optional)
     * @param  string[] $dns_name__n (optional)
     * @param  string[] $dns_name__nic (optional)
     * @param  string[] $dns_name__nie (optional)
     * @param  string[] $dns_name__niew (optional)
     * @param  string[] $dns_name__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $fhrpgroup_id FHRP group (ID) (optional)
     * @param  int[] $fhrpgroup_id__n FHRP group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $mask_length (optional)
     * @param  float $mask_length__gte (optional)
     * @param  float $mask_length__lte (optional)
     * @param  string $modified_by_request (optional)
     * @param  int[] $nat_inside_id NAT inside IP address (ID) (optional)
     * @param  int[] $nat_inside_id__n NAT inside IP address (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string $present_in_vrf (optional)
     * @param  string $present_in_vrf_id (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role The functional role of this IP (optional)
     * @param  string[] $role__n The functional role of this IP (optional)
     * @param  int[] $service_id Service (ID) (optional)
     * @param  int[] $service_id__n Service (ID) (optional)
     * @param  string[] $status The operational status of this IP (optional)
     * @param  string[] $status__n The operational status of this IP (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine (optional)
     * @param  int[] $virtual_machine_id (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM interface (ID) (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesListAsync($address = null, $assigned = null, $assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $assigned_to_interface = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device = null, $device_id = null, $dns_name = null, $dns_name__empty = null, $dns_name__ic = null, $dns_name__ie = null, $dns_name__iew = null, $dns_name__isw = null, $dns_name__n = null, $dns_name__nic = null, $dns_name__nie = null, $dns_name__niew = null, $dns_name__nisw = null, $family = null, $fhrpgroup_id = null, $fhrpgroup_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mask_length = null, $mask_length__gte = null, $mask_length__lte = null, $modified_by_request = null, $nat_inside_id = null, $nat_inside_id__n = null, $offset = null, $ordering = null, $parent = null, $present_in_vrf = null, $present_in_vrf_id = null, $q = null, $role = null, $role__n = null, $service_id = null, $service_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine_id = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, string $contentType = self::contentTypes['ipamIpAddressesList'][0])
    {
        return $this->ipamIpAddressesListAsyncWithHttpInfo($address, $assigned, $assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $assigned_to_interface, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device, $device_id, $dns_name, $dns_name__empty, $dns_name__ic, $dns_name__ie, $dns_name__iew, $dns_name__isw, $dns_name__n, $dns_name__nic, $dns_name__nie, $dns_name__niew, $dns_name__nisw, $family, $fhrpgroup_id, $fhrpgroup_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mask_length, $mask_length__gte, $mask_length__lte, $modified_by_request, $nat_inside_id, $nat_inside_id__n, $offset, $ordering, $parent, $present_in_vrf, $present_in_vrf_id, $q, $role, $role__n, $service_id, $service_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $virtual_machine, $virtual_machine_id, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpAddressesListAsyncWithHttpInfo
     *
     * @param  string[] $address (optional)
     * @param  bool $assigned Is assigned (optional)
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  int $assigned_object_type (optional)
     * @param  int $assigned_object_type__n (optional)
     * @param  bool $assigned_to_interface Is assigned to an interface (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device (optional)
     * @param  int[] $device_id (optional)
     * @param  string[] $dns_name (optional)
     * @param  bool $dns_name__empty (optional)
     * @param  string[] $dns_name__ic (optional)
     * @param  string[] $dns_name__ie (optional)
     * @param  string[] $dns_name__iew (optional)
     * @param  string[] $dns_name__isw (optional)
     * @param  string[] $dns_name__n (optional)
     * @param  string[] $dns_name__nic (optional)
     * @param  string[] $dns_name__nie (optional)
     * @param  string[] $dns_name__niew (optional)
     * @param  string[] $dns_name__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $fhrpgroup_id FHRP group (ID) (optional)
     * @param  int[] $fhrpgroup_id__n FHRP group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $mask_length (optional)
     * @param  float $mask_length__gte (optional)
     * @param  float $mask_length__lte (optional)
     * @param  string $modified_by_request (optional)
     * @param  int[] $nat_inside_id NAT inside IP address (ID) (optional)
     * @param  int[] $nat_inside_id__n NAT inside IP address (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string $present_in_vrf (optional)
     * @param  string $present_in_vrf_id (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role The functional role of this IP (optional)
     * @param  string[] $role__n The functional role of this IP (optional)
     * @param  int[] $service_id Service (ID) (optional)
     * @param  int[] $service_id__n Service (ID) (optional)
     * @param  string[] $status The operational status of this IP (optional)
     * @param  string[] $status__n The operational status of this IP (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine (optional)
     * @param  int[] $virtual_machine_id (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM interface (ID) (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesListAsyncWithHttpInfo($address = null, $assigned = null, $assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $assigned_to_interface = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device = null, $device_id = null, $dns_name = null, $dns_name__empty = null, $dns_name__ic = null, $dns_name__ie = null, $dns_name__iew = null, $dns_name__isw = null, $dns_name__n = null, $dns_name__nic = null, $dns_name__nie = null, $dns_name__niew = null, $dns_name__nisw = null, $family = null, $fhrpgroup_id = null, $fhrpgroup_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mask_length = null, $mask_length__gte = null, $mask_length__lte = null, $modified_by_request = null, $nat_inside_id = null, $nat_inside_id__n = null, $offset = null, $ordering = null, $parent = null, $present_in_vrf = null, $present_in_vrf_id = null, $q = null, $role = null, $role__n = null, $service_id = null, $service_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine_id = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, string $contentType = self::contentTypes['ipamIpAddressesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedIPAddressList';
        $request = $this->ipamIpAddressesListRequest($address, $assigned, $assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $assigned_to_interface, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device, $device_id, $dns_name, $dns_name__empty, $dns_name__ic, $dns_name__ie, $dns_name__iew, $dns_name__isw, $dns_name__n, $dns_name__nic, $dns_name__nie, $dns_name__niew, $dns_name__nisw, $family, $fhrpgroup_id, $fhrpgroup_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mask_length, $mask_length__gte, $mask_length__lte, $modified_by_request, $nat_inside_id, $nat_inside_id__n, $offset, $ordering, $parent, $present_in_vrf, $present_in_vrf_id, $q, $role, $role__n, $service_id, $service_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $virtual_machine, $virtual_machine_id, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpAddressesList'
     *
     * @param  string[] $address (optional)
     * @param  bool $assigned Is assigned (optional)
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  int $assigned_object_type (optional)
     * @param  int $assigned_object_type__n (optional)
     * @param  bool $assigned_to_interface Is assigned to an interface (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device (optional)
     * @param  int[] $device_id (optional)
     * @param  string[] $dns_name (optional)
     * @param  bool $dns_name__empty (optional)
     * @param  string[] $dns_name__ic (optional)
     * @param  string[] $dns_name__ie (optional)
     * @param  string[] $dns_name__iew (optional)
     * @param  string[] $dns_name__isw (optional)
     * @param  string[] $dns_name__n (optional)
     * @param  string[] $dns_name__nic (optional)
     * @param  string[] $dns_name__nie (optional)
     * @param  string[] $dns_name__niew (optional)
     * @param  string[] $dns_name__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $fhrpgroup_id FHRP group (ID) (optional)
     * @param  int[] $fhrpgroup_id__n FHRP group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $mask_length (optional)
     * @param  float $mask_length__gte (optional)
     * @param  float $mask_length__lte (optional)
     * @param  string $modified_by_request (optional)
     * @param  int[] $nat_inside_id NAT inside IP address (ID) (optional)
     * @param  int[] $nat_inside_id__n NAT inside IP address (ID) (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string $present_in_vrf (optional)
     * @param  string $present_in_vrf_id (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role The functional role of this IP (optional)
     * @param  string[] $role__n The functional role of this IP (optional)
     * @param  int[] $service_id Service (ID) (optional)
     * @param  int[] $service_id__n Service (ID) (optional)
     * @param  string[] $status The operational status of this IP (optional)
     * @param  string[] $status__n The operational status of this IP (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine (optional)
     * @param  int[] $virtual_machine_id (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM interface (ID) (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpAddressesListRequest($address = null, $assigned = null, $assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $assigned_to_interface = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device = null, $device_id = null, $dns_name = null, $dns_name__empty = null, $dns_name__ic = null, $dns_name__ie = null, $dns_name__iew = null, $dns_name__isw = null, $dns_name__n = null, $dns_name__nic = null, $dns_name__nie = null, $dns_name__niew = null, $dns_name__nisw = null, $family = null, $fhrpgroup_id = null, $fhrpgroup_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mask_length = null, $mask_length__gte = null, $mask_length__lte = null, $modified_by_request = null, $nat_inside_id = null, $nat_inside_id__n = null, $offset = null, $ordering = null, $parent = null, $present_in_vrf = null, $present_in_vrf_id = null, $q = null, $role = null, $role__n = null, $service_id = null, $service_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine_id = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, string $contentType = self::contentTypes['ipamIpAddressesList'][0])
    {











































































































        $resourcePath = '/api/ipam/ip-addresses/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address,
            'address', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned,
            'assigned', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id,
            'assigned_object_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__empty,
            'assigned_object_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__gt,
            'assigned_object_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__gte,
            'assigned_object_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__lt,
            'assigned_object_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__lte,
            'assigned_object_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__n,
            'assigned_object_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_type,
            'assigned_object_type', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_type__n,
            'assigned_object_type__n', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_to_interface,
            'assigned_to_interface', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device,
            'device', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'device_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dns_name,
            'dns_name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dns_name__empty,
            'dns_name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dns_name__ic,
            'dns_name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dns_name__ie,
            'dns_name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dns_name__iew,
            'dns_name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dns_name__isw,
            'dns_name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dns_name__n,
            'dns_name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dns_name__nic,
            'dns_name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dns_name__nie,
            'dns_name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dns_name__niew,
            'dns_name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dns_name__nisw,
            'dns_name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $family,
            'family', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fhrpgroup_id,
            'fhrpgroup_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fhrpgroup_id__n,
            'fhrpgroup_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface,
            'interface', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface__n,
            'interface__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id,
            'interface_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id__n,
            'interface_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mask_length,
            'mask_length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mask_length__gte,
            'mask_length__gte', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mask_length__lte,
            'mask_length__lte', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nat_inside_id,
            'nat_inside_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nat_inside_id__n,
            'nat_inside_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent,
            'parent', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $present_in_vrf,
            'present_in_vrf', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $present_in_vrf_id,
            'present_in_vrf_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role,
            'role', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role__n,
            'role__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id,
            'service_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id__n,
            'service_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status__n,
            'status__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine,
            'virtual_machine', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine_id,
            'virtual_machine_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface,
            'vminterface', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface__n,
            'vminterface__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface_id,
            'vminterface_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface_id__n,
            'vminterface_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf,
            'vrf', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf__n,
            'vrf__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf_id,
            'vrf_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf_id__n,
            'vrf_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpAddressesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPAddressRequest $patched_writable_ip_address_request patched_writable_ip_address_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPAddress
     */
    public function ipamIpAddressesPartialUpdate($id, $patched_writable_ip_address_request = null, string $contentType = self::contentTypes['ipamIpAddressesPartialUpdate'][0])
    {
        list($response) = $this->ipamIpAddressesPartialUpdateWithHttpInfo($id, $patched_writable_ip_address_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpAddressesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPAddressRequest $patched_writable_ip_address_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpAddressesPartialUpdateWithHttpInfo($id, $patched_writable_ip_address_request = null, string $contentType = self::contentTypes['ipamIpAddressesPartialUpdate'][0])
    {
        $request = $this->ipamIpAddressesPartialUpdateRequest($id, $patched_writable_ip_address_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPAddress' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPAddress' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPAddress', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPAddress';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpAddressesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPAddressRequest $patched_writable_ip_address_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesPartialUpdateAsync($id, $patched_writable_ip_address_request = null, string $contentType = self::contentTypes['ipamIpAddressesPartialUpdate'][0])
    {
        return $this->ipamIpAddressesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ip_address_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpAddressesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPAddressRequest $patched_writable_ip_address_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ip_address_request = null, string $contentType = self::contentTypes['ipamIpAddressesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPAddress';
        $request = $this->ipamIpAddressesPartialUpdateRequest($id, $patched_writable_ip_address_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpAddressesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPAddressRequest $patched_writable_ip_address_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpAddressesPartialUpdateRequest($id, $patched_writable_ip_address_request = null, string $contentType = self::contentTypes['ipamIpAddressesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamIpAddressesPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/ip-addresses/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_ip_address_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_ip_address_request));
            } else {
                $httpBody = $patched_writable_ip_address_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpAddressesRetrieve
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPAddress
     */
    public function ipamIpAddressesRetrieve($id, string $contentType = self::contentTypes['ipamIpAddressesRetrieve'][0])
    {
        list($response) = $this->ipamIpAddressesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpAddressesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpAddressesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamIpAddressesRetrieve'][0])
    {
        $request = $this->ipamIpAddressesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPAddress' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPAddress' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPAddress', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPAddress';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpAddressesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesRetrieveAsync($id, string $contentType = self::contentTypes['ipamIpAddressesRetrieve'][0])
    {
        return $this->ipamIpAddressesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpAddressesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamIpAddressesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPAddress';
        $request = $this->ipamIpAddressesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpAddressesRetrieve'
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpAddressesRetrieveRequest($id, string $contentType = self::contentTypes['ipamIpAddressesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamIpAddressesRetrieve'
            );
        }


        $resourcePath = '/api/ipam/ip-addresses/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpAddressesUpdate
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  \OpenAPI\Client\Model\WritableIPAddressRequest $writable_ip_address_request writable_ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPAddress
     */
    public function ipamIpAddressesUpdate($id, $writable_ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesUpdate'][0])
    {
        list($response) = $this->ipamIpAddressesUpdateWithHttpInfo($id, $writable_ip_address_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpAddressesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  \OpenAPI\Client\Model\WritableIPAddressRequest $writable_ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpAddressesUpdateWithHttpInfo($id, $writable_ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesUpdate'][0])
    {
        $request = $this->ipamIpAddressesUpdateRequest($id, $writable_ip_address_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPAddress' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPAddress' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPAddress', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPAddress';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpAddressesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  \OpenAPI\Client\Model\WritableIPAddressRequest $writable_ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesUpdateAsync($id, $writable_ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesUpdate'][0])
    {
        return $this->ipamIpAddressesUpdateAsyncWithHttpInfo($id, $writable_ip_address_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpAddressesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  \OpenAPI\Client\Model\WritableIPAddressRequest $writable_ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpAddressesUpdateAsyncWithHttpInfo($id, $writable_ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPAddress';
        $request = $this->ipamIpAddressesUpdateRequest($id, $writable_ip_address_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpAddressesUpdate'
     *
     * @param  int $id A unique integer value identifying this IP address. (required)
     * @param  \OpenAPI\Client\Model\WritableIPAddressRequest $writable_ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpAddressesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpAddressesUpdateRequest($id, $writable_ip_address_request, string $contentType = self::contentTypes['ipamIpAddressesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamIpAddressesUpdate'
            );
        }

        // verify the required parameter 'writable_ip_address_request' is set
        if ($writable_ip_address_request === null || (is_array($writable_ip_address_request) && count($writable_ip_address_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ip_address_request when calling ipamIpAddressesUpdate'
            );
        }


        $resourcePath = '/api/ipam/ip-addresses/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ip_address_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ip_address_request));
            } else {
                $httpBody = $writable_ip_address_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpRangesAvailableIpsCreate
     *
     * @param  int $id id (required)
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesAvailableIpsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPAddress[]
     */
    public function ipamIpRangesAvailableIpsCreate($id, $ip_address_request, string $contentType = self::contentTypes['ipamIpRangesAvailableIpsCreate'][0])
    {
        list($response) = $this->ipamIpRangesAvailableIpsCreateWithHttpInfo($id, $ip_address_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpRangesAvailableIpsCreateWithHttpInfo
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesAvailableIpsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPAddress[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpRangesAvailableIpsCreateWithHttpInfo($id, $ip_address_request, string $contentType = self::contentTypes['ipamIpRangesAvailableIpsCreate'][0])
    {
        $request = $this->ipamIpRangesAvailableIpsCreateRequest($id, $ip_address_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\IPAddress[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPAddress[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPAddress[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPAddress[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpRangesAvailableIpsCreateAsync
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesAvailableIpsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesAvailableIpsCreateAsync($id, $ip_address_request, string $contentType = self::contentTypes['ipamIpRangesAvailableIpsCreate'][0])
    {
        return $this->ipamIpRangesAvailableIpsCreateAsyncWithHttpInfo($id, $ip_address_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpRangesAvailableIpsCreateAsyncWithHttpInfo
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesAvailableIpsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesAvailableIpsCreateAsyncWithHttpInfo($id, $ip_address_request, string $contentType = self::contentTypes['ipamIpRangesAvailableIpsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPAddress[]';
        $request = $this->ipamIpRangesAvailableIpsCreateRequest($id, $ip_address_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpRangesAvailableIpsCreate'
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesAvailableIpsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpRangesAvailableIpsCreateRequest($id, $ip_address_request, string $contentType = self::contentTypes['ipamIpRangesAvailableIpsCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamIpRangesAvailableIpsCreate'
            );
        }

        // verify the required parameter 'ip_address_request' is set
        if ($ip_address_request === null || (is_array($ip_address_request) && count($ip_address_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_address_request when calling ipamIpRangesAvailableIpsCreate'
            );
        }


        $resourcePath = '/api/ipam/ip-ranges/{id}/available-ips/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_address_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_address_request));
            } else {
                $httpBody = $ip_address_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpRangesAvailableIpsList
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesAvailableIpsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AvailableIP[]
     */
    public function ipamIpRangesAvailableIpsList($id, string $contentType = self::contentTypes['ipamIpRangesAvailableIpsList'][0])
    {
        list($response) = $this->ipamIpRangesAvailableIpsListWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpRangesAvailableIpsListWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesAvailableIpsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AvailableIP[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpRangesAvailableIpsListWithHttpInfo($id, string $contentType = self::contentTypes['ipamIpRangesAvailableIpsList'][0])
    {
        $request = $this->ipamIpRangesAvailableIpsListRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AvailableIP[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AvailableIP[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AvailableIP[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AvailableIP[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AvailableIP[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpRangesAvailableIpsListAsync
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesAvailableIpsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesAvailableIpsListAsync($id, string $contentType = self::contentTypes['ipamIpRangesAvailableIpsList'][0])
    {
        return $this->ipamIpRangesAvailableIpsListAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpRangesAvailableIpsListAsyncWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesAvailableIpsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesAvailableIpsListAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamIpRangesAvailableIpsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AvailableIP[]';
        $request = $this->ipamIpRangesAvailableIpsListRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpRangesAvailableIpsList'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesAvailableIpsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpRangesAvailableIpsListRequest($id, string $contentType = self::contentTypes['ipamIpRangesAvailableIpsList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamIpRangesAvailableIpsList'
            );
        }


        $resourcePath = '/api/ipam/ip-ranges/{id}/available-ips/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpRangesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamIpRangesBulkDestroy($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkDestroy'][0])
    {
        $this->ipamIpRangesBulkDestroyWithHttpInfo($ip_range_request, $contentType);
    }

    /**
     * Operation ipamIpRangesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpRangesBulkDestroyWithHttpInfo($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkDestroy'][0])
    {
        $request = $this->ipamIpRangesBulkDestroyRequest($ip_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpRangesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesBulkDestroyAsync($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkDestroy'][0])
    {
        return $this->ipamIpRangesBulkDestroyAsyncWithHttpInfo($ip_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpRangesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesBulkDestroyAsyncWithHttpInfo($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamIpRangesBulkDestroyRequest($ip_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpRangesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpRangesBulkDestroyRequest($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkDestroy'][0])
    {

        // verify the required parameter 'ip_range_request' is set
        if ($ip_range_request === null || (is_array($ip_range_request) && count($ip_range_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_range_request when calling ipamIpRangesBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/ip-ranges/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_range_request));
            } else {
                $httpBody = $ip_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpRangesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPRange[]
     */
    public function ipamIpRangesBulkPartialUpdate($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamIpRangesBulkPartialUpdateWithHttpInfo($ip_range_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpRangesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPRange[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpRangesBulkPartialUpdateWithHttpInfo($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkPartialUpdate'][0])
    {
        $request = $this->ipamIpRangesBulkPartialUpdateRequest($ip_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPRange[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPRange[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPRange[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPRange[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPRange[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpRangesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesBulkPartialUpdateAsync($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkPartialUpdate'][0])
    {
        return $this->ipamIpRangesBulkPartialUpdateAsyncWithHttpInfo($ip_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpRangesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesBulkPartialUpdateAsyncWithHttpInfo($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPRange[]';
        $request = $this->ipamIpRangesBulkPartialUpdateRequest($ip_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpRangesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpRangesBulkPartialUpdateRequest($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'ip_range_request' is set
        if ($ip_range_request === null || (is_array($ip_range_request) && count($ip_range_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_range_request when calling ipamIpRangesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/ip-ranges/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_range_request));
            } else {
                $httpBody = $ip_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpRangesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPRange[]
     */
    public function ipamIpRangesBulkUpdate($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkUpdate'][0])
    {
        list($response) = $this->ipamIpRangesBulkUpdateWithHttpInfo($ip_range_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpRangesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPRange[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpRangesBulkUpdateWithHttpInfo($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkUpdate'][0])
    {
        $request = $this->ipamIpRangesBulkUpdateRequest($ip_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPRange[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPRange[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPRange[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPRange[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPRange[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpRangesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesBulkUpdateAsync($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkUpdate'][0])
    {
        return $this->ipamIpRangesBulkUpdateAsyncWithHttpInfo($ip_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpRangesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesBulkUpdateAsyncWithHttpInfo($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPRange[]';
        $request = $this->ipamIpRangesBulkUpdateRequest($ip_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpRangesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\IPRangeRequest[] $ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpRangesBulkUpdateRequest($ip_range_request, string $contentType = self::contentTypes['ipamIpRangesBulkUpdate'][0])
    {

        // verify the required parameter 'ip_range_request' is set
        if ($ip_range_request === null || (is_array($ip_range_request) && count($ip_range_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_range_request when calling ipamIpRangesBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/ip-ranges/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_range_request));
            } else {
                $httpBody = $ip_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpRangesCreate
     *
     * @param  \OpenAPI\Client\Model\WritableIPRangeRequest $writable_ip_range_request writable_ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPRange
     */
    public function ipamIpRangesCreate($writable_ip_range_request, string $contentType = self::contentTypes['ipamIpRangesCreate'][0])
    {
        list($response) = $this->ipamIpRangesCreateWithHttpInfo($writable_ip_range_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpRangesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIPRangeRequest $writable_ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpRangesCreateWithHttpInfo($writable_ip_range_request, string $contentType = self::contentTypes['ipamIpRangesCreate'][0])
    {
        $request = $this->ipamIpRangesCreateRequest($writable_ip_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\IPRange' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPRange' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPRange', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPRange';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPRange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpRangesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableIPRangeRequest $writable_ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesCreateAsync($writable_ip_range_request, string $contentType = self::contentTypes['ipamIpRangesCreate'][0])
    {
        return $this->ipamIpRangesCreateAsyncWithHttpInfo($writable_ip_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpRangesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIPRangeRequest $writable_ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesCreateAsyncWithHttpInfo($writable_ip_range_request, string $contentType = self::contentTypes['ipamIpRangesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPRange';
        $request = $this->ipamIpRangesCreateRequest($writable_ip_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpRangesCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableIPRangeRequest $writable_ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpRangesCreateRequest($writable_ip_range_request, string $contentType = self::contentTypes['ipamIpRangesCreate'][0])
    {

        // verify the required parameter 'writable_ip_range_request' is set
        if ($writable_ip_range_request === null || (is_array($writable_ip_range_request) && count($writable_ip_range_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ip_range_request when calling ipamIpRangesCreate'
            );
        }


        $resourcePath = '/api/ipam/ip-ranges/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ip_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ip_range_request));
            } else {
                $httpBody = $writable_ip_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpRangesDestroy
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamIpRangesDestroy($id, string $contentType = self::contentTypes['ipamIpRangesDestroy'][0])
    {
        $this->ipamIpRangesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamIpRangesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpRangesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamIpRangesDestroy'][0])
    {
        $request = $this->ipamIpRangesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpRangesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesDestroyAsync($id, string $contentType = self::contentTypes['ipamIpRangesDestroy'][0])
    {
        return $this->ipamIpRangesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpRangesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamIpRangesDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamIpRangesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpRangesDestroy'
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpRangesDestroyRequest($id, string $contentType = self::contentTypes['ipamIpRangesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamIpRangesDestroy'
            );
        }


        $resourcePath = '/api/ipam/ip-ranges/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpRangesList
     *
     * @param  string $contains Ranges which contain this prefix or IP (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $end_address end_address (optional)
     * @param  float $family family (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_utilized mark_utilized (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent parent (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  int[] $size size (optional)
     * @param  bool $size__empty size__empty (optional)
     * @param  int[] $size__gt size__gt (optional)
     * @param  int[] $size__gte size__gte (optional)
     * @param  int[] $size__lt size__lt (optional)
     * @param  int[] $size__lte size__lte (optional)
     * @param  int[] $size__n size__n (optional)
     * @param  string[] $start_address start_address (optional)
     * @param  string[] $status Operational status of this range (optional)
     * @param  string[] $status__n Operational status of this range (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedIPRangeList
     */
    public function ipamIpRangesList($contains = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $end_address = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_utilized = null, $modified_by_request = null, $offset = null, $ordering = null, $parent = null, $q = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $size = null, $size__empty = null, $size__gt = null, $size__gte = null, $size__lt = null, $size__lte = null, $size__n = null, $start_address = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, string $contentType = self::contentTypes['ipamIpRangesList'][0])
    {
        list($response) = $this->ipamIpRangesListWithHttpInfo($contains, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $end_address, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_utilized, $modified_by_request, $offset, $ordering, $parent, $q, $role, $role__n, $role_id, $role_id__n, $size, $size__empty, $size__gt, $size__gte, $size__lt, $size__lte, $size__n, $start_address, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpRangesListWithHttpInfo
     *
     * @param  string $contains Ranges which contain this prefix or IP (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $end_address (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_utilized (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  int[] $size (optional)
     * @param  bool $size__empty (optional)
     * @param  int[] $size__gt (optional)
     * @param  int[] $size__gte (optional)
     * @param  int[] $size__lt (optional)
     * @param  int[] $size__lte (optional)
     * @param  int[] $size__n (optional)
     * @param  string[] $start_address (optional)
     * @param  string[] $status Operational status of this range (optional)
     * @param  string[] $status__n Operational status of this range (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedIPRangeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpRangesListWithHttpInfo($contains = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $end_address = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_utilized = null, $modified_by_request = null, $offset = null, $ordering = null, $parent = null, $q = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $size = null, $size__empty = null, $size__gt = null, $size__gte = null, $size__lt = null, $size__lte = null, $size__n = null, $start_address = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, string $contentType = self::contentTypes['ipamIpRangesList'][0])
    {
        $request = $this->ipamIpRangesListRequest($contains, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $end_address, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_utilized, $modified_by_request, $offset, $ordering, $parent, $q, $role, $role__n, $role_id, $role_id__n, $size, $size__empty, $size__gt, $size__gte, $size__lt, $size__lte, $size__n, $start_address, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedIPRangeList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedIPRangeList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedIPRangeList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedIPRangeList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedIPRangeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpRangesListAsync
     *
     * @param  string $contains Ranges which contain this prefix or IP (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $end_address (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_utilized (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  int[] $size (optional)
     * @param  bool $size__empty (optional)
     * @param  int[] $size__gt (optional)
     * @param  int[] $size__gte (optional)
     * @param  int[] $size__lt (optional)
     * @param  int[] $size__lte (optional)
     * @param  int[] $size__n (optional)
     * @param  string[] $start_address (optional)
     * @param  string[] $status Operational status of this range (optional)
     * @param  string[] $status__n Operational status of this range (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesListAsync($contains = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $end_address = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_utilized = null, $modified_by_request = null, $offset = null, $ordering = null, $parent = null, $q = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $size = null, $size__empty = null, $size__gt = null, $size__gte = null, $size__lt = null, $size__lte = null, $size__n = null, $start_address = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, string $contentType = self::contentTypes['ipamIpRangesList'][0])
    {
        return $this->ipamIpRangesListAsyncWithHttpInfo($contains, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $end_address, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_utilized, $modified_by_request, $offset, $ordering, $parent, $q, $role, $role__n, $role_id, $role_id__n, $size, $size__empty, $size__gt, $size__gte, $size__lt, $size__lte, $size__n, $start_address, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpRangesListAsyncWithHttpInfo
     *
     * @param  string $contains Ranges which contain this prefix or IP (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $end_address (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_utilized (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  int[] $size (optional)
     * @param  bool $size__empty (optional)
     * @param  int[] $size__gt (optional)
     * @param  int[] $size__gte (optional)
     * @param  int[] $size__lt (optional)
     * @param  int[] $size__lte (optional)
     * @param  int[] $size__n (optional)
     * @param  string[] $start_address (optional)
     * @param  string[] $status Operational status of this range (optional)
     * @param  string[] $status__n Operational status of this range (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesListAsyncWithHttpInfo($contains = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $end_address = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_utilized = null, $modified_by_request = null, $offset = null, $ordering = null, $parent = null, $q = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $size = null, $size__empty = null, $size__gt = null, $size__gte = null, $size__lt = null, $size__lte = null, $size__n = null, $start_address = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, string $contentType = self::contentTypes['ipamIpRangesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedIPRangeList';
        $request = $this->ipamIpRangesListRequest($contains, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $end_address, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_utilized, $modified_by_request, $offset, $ordering, $parent, $q, $role, $role__n, $role_id, $role_id__n, $size, $size__empty, $size__gt, $size__gte, $size__lt, $size__lte, $size__n, $start_address, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpRangesList'
     *
     * @param  string $contains Ranges which contain this prefix or IP (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $end_address (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_utilized (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  int[] $size (optional)
     * @param  bool $size__empty (optional)
     * @param  int[] $size__gt (optional)
     * @param  int[] $size__gte (optional)
     * @param  int[] $size__lt (optional)
     * @param  int[] $size__lte (optional)
     * @param  int[] $size__n (optional)
     * @param  string[] $start_address (optional)
     * @param  string[] $status Operational status of this range (optional)
     * @param  string[] $status__n Operational status of this range (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpRangesListRequest($contains = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $end_address = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_utilized = null, $modified_by_request = null, $offset = null, $ordering = null, $parent = null, $q = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $size = null, $size__empty = null, $size__gt = null, $size__gte = null, $size__lt = null, $size__lte = null, $size__n = null, $start_address = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, string $contentType = self::contentTypes['ipamIpRangesList'][0])
    {










































































        $resourcePath = '/api/ipam/ip-ranges/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contains,
            'contains', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_address,
            'end_address', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $family,
            'family', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mark_utilized,
            'mark_utilized', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent,
            'parent', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role,
            'role', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role__n,
            'role__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role_id,
            'role_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role_id__n,
            'role_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size__empty,
            'size__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size__gt,
            'size__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size__gte,
            'size__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size__lt,
            'size__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size__lte,
            'size__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size__n,
            'size__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_address,
            'start_address', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status__n,
            'status__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf,
            'vrf', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf__n,
            'vrf__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf_id,
            'vrf_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf_id__n,
            'vrf_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpRangesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPRangeRequest $patched_writable_ip_range_request patched_writable_ip_range_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPRange
     */
    public function ipamIpRangesPartialUpdate($id, $patched_writable_ip_range_request = null, string $contentType = self::contentTypes['ipamIpRangesPartialUpdate'][0])
    {
        list($response) = $this->ipamIpRangesPartialUpdateWithHttpInfo($id, $patched_writable_ip_range_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpRangesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPRangeRequest $patched_writable_ip_range_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpRangesPartialUpdateWithHttpInfo($id, $patched_writable_ip_range_request = null, string $contentType = self::contentTypes['ipamIpRangesPartialUpdate'][0])
    {
        $request = $this->ipamIpRangesPartialUpdateRequest($id, $patched_writable_ip_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPRange' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPRange' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPRange', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPRange';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPRange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpRangesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPRangeRequest $patched_writable_ip_range_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesPartialUpdateAsync($id, $patched_writable_ip_range_request = null, string $contentType = self::contentTypes['ipamIpRangesPartialUpdate'][0])
    {
        return $this->ipamIpRangesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ip_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpRangesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPRangeRequest $patched_writable_ip_range_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ip_range_request = null, string $contentType = self::contentTypes['ipamIpRangesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPRange';
        $request = $this->ipamIpRangesPartialUpdateRequest($id, $patched_writable_ip_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpRangesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPRangeRequest $patched_writable_ip_range_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpRangesPartialUpdateRequest($id, $patched_writable_ip_range_request = null, string $contentType = self::contentTypes['ipamIpRangesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamIpRangesPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/ip-ranges/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_ip_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_ip_range_request));
            } else {
                $httpBody = $patched_writable_ip_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpRangesRetrieve
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPRange
     */
    public function ipamIpRangesRetrieve($id, string $contentType = self::contentTypes['ipamIpRangesRetrieve'][0])
    {
        list($response) = $this->ipamIpRangesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpRangesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpRangesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamIpRangesRetrieve'][0])
    {
        $request = $this->ipamIpRangesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPRange' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPRange' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPRange', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPRange';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPRange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpRangesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesRetrieveAsync($id, string $contentType = self::contentTypes['ipamIpRangesRetrieve'][0])
    {
        return $this->ipamIpRangesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpRangesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamIpRangesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPRange';
        $request = $this->ipamIpRangesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpRangesRetrieve'
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpRangesRetrieveRequest($id, string $contentType = self::contentTypes['ipamIpRangesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamIpRangesRetrieve'
            );
        }


        $resourcePath = '/api/ipam/ip-ranges/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamIpRangesUpdate
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  \OpenAPI\Client\Model\WritableIPRangeRequest $writable_ip_range_request writable_ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPRange
     */
    public function ipamIpRangesUpdate($id, $writable_ip_range_request, string $contentType = self::contentTypes['ipamIpRangesUpdate'][0])
    {
        list($response) = $this->ipamIpRangesUpdateWithHttpInfo($id, $writable_ip_range_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamIpRangesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  \OpenAPI\Client\Model\WritableIPRangeRequest $writable_ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPRange, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamIpRangesUpdateWithHttpInfo($id, $writable_ip_range_request, string $contentType = self::contentTypes['ipamIpRangesUpdate'][0])
    {
        $request = $this->ipamIpRangesUpdateRequest($id, $writable_ip_range_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPRange' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPRange' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPRange', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPRange';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPRange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamIpRangesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  \OpenAPI\Client\Model\WritableIPRangeRequest $writable_ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesUpdateAsync($id, $writable_ip_range_request, string $contentType = self::contentTypes['ipamIpRangesUpdate'][0])
    {
        return $this->ipamIpRangesUpdateAsyncWithHttpInfo($id, $writable_ip_range_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamIpRangesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  \OpenAPI\Client\Model\WritableIPRangeRequest $writable_ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamIpRangesUpdateAsyncWithHttpInfo($id, $writable_ip_range_request, string $contentType = self::contentTypes['ipamIpRangesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPRange';
        $request = $this->ipamIpRangesUpdateRequest($id, $writable_ip_range_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamIpRangesUpdate'
     *
     * @param  int $id A unique integer value identifying this IP range. (required)
     * @param  \OpenAPI\Client\Model\WritableIPRangeRequest $writable_ip_range_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamIpRangesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamIpRangesUpdateRequest($id, $writable_ip_range_request, string $contentType = self::contentTypes['ipamIpRangesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamIpRangesUpdate'
            );
        }

        // verify the required parameter 'writable_ip_range_request' is set
        if ($writable_ip_range_request === null || (is_array($writable_ip_range_request) && count($writable_ip_range_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ip_range_request when calling ipamIpRangesUpdate'
            );
        }


        $resourcePath = '/api/ipam/ip-ranges/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ip_range_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ip_range_request));
            } else {
                $httpBody = $writable_ip_range_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesAvailableIpsCreate
     *
     * @param  int $id id (required)
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailableIpsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPAddress[]
     */
    public function ipamPrefixesAvailableIpsCreate($id, $ip_address_request, string $contentType = self::contentTypes['ipamPrefixesAvailableIpsCreate'][0])
    {
        list($response) = $this->ipamPrefixesAvailableIpsCreateWithHttpInfo($id, $ip_address_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamPrefixesAvailableIpsCreateWithHttpInfo
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailableIpsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPAddress[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesAvailableIpsCreateWithHttpInfo($id, $ip_address_request, string $contentType = self::contentTypes['ipamPrefixesAvailableIpsCreate'][0])
    {
        $request = $this->ipamPrefixesAvailableIpsCreateRequest($id, $ip_address_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\IPAddress[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPAddress[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPAddress[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPAddress[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesAvailableIpsCreateAsync
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailableIpsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesAvailableIpsCreateAsync($id, $ip_address_request, string $contentType = self::contentTypes['ipamPrefixesAvailableIpsCreate'][0])
    {
        return $this->ipamPrefixesAvailableIpsCreateAsyncWithHttpInfo($id, $ip_address_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesAvailableIpsCreateAsyncWithHttpInfo
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailableIpsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesAvailableIpsCreateAsyncWithHttpInfo($id, $ip_address_request, string $contentType = self::contentTypes['ipamPrefixesAvailableIpsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPAddress[]';
        $request = $this->ipamPrefixesAvailableIpsCreateRequest($id, $ip_address_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesAvailableIpsCreate'
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\IPAddressRequest[] $ip_address_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailableIpsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesAvailableIpsCreateRequest($id, $ip_address_request, string $contentType = self::contentTypes['ipamPrefixesAvailableIpsCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamPrefixesAvailableIpsCreate'
            );
        }

        // verify the required parameter 'ip_address_request' is set
        if ($ip_address_request === null || (is_array($ip_address_request) && count($ip_address_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_address_request when calling ipamPrefixesAvailableIpsCreate'
            );
        }


        $resourcePath = '/api/ipam/prefixes/{id}/available-ips/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_address_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_address_request));
            } else {
                $httpBody = $ip_address_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesAvailableIpsList
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailableIpsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AvailableIP[]
     */
    public function ipamPrefixesAvailableIpsList($id, string $contentType = self::contentTypes['ipamPrefixesAvailableIpsList'][0])
    {
        list($response) = $this->ipamPrefixesAvailableIpsListWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamPrefixesAvailableIpsListWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailableIpsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AvailableIP[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesAvailableIpsListWithHttpInfo($id, string $contentType = self::contentTypes['ipamPrefixesAvailableIpsList'][0])
    {
        $request = $this->ipamPrefixesAvailableIpsListRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AvailableIP[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AvailableIP[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AvailableIP[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AvailableIP[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AvailableIP[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesAvailableIpsListAsync
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailableIpsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesAvailableIpsListAsync($id, string $contentType = self::contentTypes['ipamPrefixesAvailableIpsList'][0])
    {
        return $this->ipamPrefixesAvailableIpsListAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesAvailableIpsListAsyncWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailableIpsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesAvailableIpsListAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamPrefixesAvailableIpsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AvailableIP[]';
        $request = $this->ipamPrefixesAvailableIpsListRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesAvailableIpsList'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailableIpsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesAvailableIpsListRequest($id, string $contentType = self::contentTypes['ipamPrefixesAvailableIpsList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamPrefixesAvailableIpsList'
            );
        }


        $resourcePath = '/api/ipam/prefixes/{id}/available-ips/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesAvailablePrefixesCreate
     *
     * @param  int $id id (required)
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailablePrefixesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Prefix[]
     */
    public function ipamPrefixesAvailablePrefixesCreate($id, $prefix_request, string $contentType = self::contentTypes['ipamPrefixesAvailablePrefixesCreate'][0])
    {
        list($response) = $this->ipamPrefixesAvailablePrefixesCreateWithHttpInfo($id, $prefix_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamPrefixesAvailablePrefixesCreateWithHttpInfo
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailablePrefixesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Prefix[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesAvailablePrefixesCreateWithHttpInfo($id, $prefix_request, string $contentType = self::contentTypes['ipamPrefixesAvailablePrefixesCreate'][0])
    {
        $request = $this->ipamPrefixesAvailablePrefixesCreateRequest($id, $prefix_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Prefix[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Prefix[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Prefix[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Prefix[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Prefix[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesAvailablePrefixesCreateAsync
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailablePrefixesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesAvailablePrefixesCreateAsync($id, $prefix_request, string $contentType = self::contentTypes['ipamPrefixesAvailablePrefixesCreate'][0])
    {
        return $this->ipamPrefixesAvailablePrefixesCreateAsyncWithHttpInfo($id, $prefix_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesAvailablePrefixesCreateAsyncWithHttpInfo
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailablePrefixesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesAvailablePrefixesCreateAsyncWithHttpInfo($id, $prefix_request, string $contentType = self::contentTypes['ipamPrefixesAvailablePrefixesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Prefix[]';
        $request = $this->ipamPrefixesAvailablePrefixesCreateRequest($id, $prefix_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesAvailablePrefixesCreate'
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailablePrefixesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesAvailablePrefixesCreateRequest($id, $prefix_request, string $contentType = self::contentTypes['ipamPrefixesAvailablePrefixesCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamPrefixesAvailablePrefixesCreate'
            );
        }

        // verify the required parameter 'prefix_request' is set
        if ($prefix_request === null || (is_array($prefix_request) && count($prefix_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prefix_request when calling ipamPrefixesAvailablePrefixesCreate'
            );
        }


        $resourcePath = '/api/ipam/prefixes/{id}/available-prefixes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($prefix_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($prefix_request));
            } else {
                $httpBody = $prefix_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesAvailablePrefixesList
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailablePrefixesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AvailablePrefix[]
     */
    public function ipamPrefixesAvailablePrefixesList($id, string $contentType = self::contentTypes['ipamPrefixesAvailablePrefixesList'][0])
    {
        list($response) = $this->ipamPrefixesAvailablePrefixesListWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamPrefixesAvailablePrefixesListWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailablePrefixesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AvailablePrefix[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesAvailablePrefixesListWithHttpInfo($id, string $contentType = self::contentTypes['ipamPrefixesAvailablePrefixesList'][0])
    {
        $request = $this->ipamPrefixesAvailablePrefixesListRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AvailablePrefix[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AvailablePrefix[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AvailablePrefix[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AvailablePrefix[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AvailablePrefix[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesAvailablePrefixesListAsync
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailablePrefixesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesAvailablePrefixesListAsync($id, string $contentType = self::contentTypes['ipamPrefixesAvailablePrefixesList'][0])
    {
        return $this->ipamPrefixesAvailablePrefixesListAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesAvailablePrefixesListAsyncWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailablePrefixesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesAvailablePrefixesListAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamPrefixesAvailablePrefixesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AvailablePrefix[]';
        $request = $this->ipamPrefixesAvailablePrefixesListRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesAvailablePrefixesList'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesAvailablePrefixesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesAvailablePrefixesListRequest($id, string $contentType = self::contentTypes['ipamPrefixesAvailablePrefixesList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamPrefixesAvailablePrefixesList'
            );
        }


        $resourcePath = '/api/ipam/prefixes/{id}/available-prefixes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamPrefixesBulkDestroy($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkDestroy'][0])
    {
        $this->ipamPrefixesBulkDestroyWithHttpInfo($prefix_request, $contentType);
    }

    /**
     * Operation ipamPrefixesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesBulkDestroyWithHttpInfo($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkDestroy'][0])
    {
        $request = $this->ipamPrefixesBulkDestroyRequest($prefix_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesBulkDestroyAsync($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkDestroy'][0])
    {
        return $this->ipamPrefixesBulkDestroyAsyncWithHttpInfo($prefix_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesBulkDestroyAsyncWithHttpInfo($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamPrefixesBulkDestroyRequest($prefix_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesBulkDestroyRequest($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkDestroy'][0])
    {

        // verify the required parameter 'prefix_request' is set
        if ($prefix_request === null || (is_array($prefix_request) && count($prefix_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prefix_request when calling ipamPrefixesBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/prefixes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($prefix_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($prefix_request));
            } else {
                $httpBody = $prefix_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Prefix[]
     */
    public function ipamPrefixesBulkPartialUpdate($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamPrefixesBulkPartialUpdateWithHttpInfo($prefix_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamPrefixesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Prefix[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesBulkPartialUpdateWithHttpInfo($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkPartialUpdate'][0])
    {
        $request = $this->ipamPrefixesBulkPartialUpdateRequest($prefix_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Prefix[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Prefix[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Prefix[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Prefix[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Prefix[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesBulkPartialUpdateAsync($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkPartialUpdate'][0])
    {
        return $this->ipamPrefixesBulkPartialUpdateAsyncWithHttpInfo($prefix_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesBulkPartialUpdateAsyncWithHttpInfo($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Prefix[]';
        $request = $this->ipamPrefixesBulkPartialUpdateRequest($prefix_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesBulkPartialUpdateRequest($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'prefix_request' is set
        if ($prefix_request === null || (is_array($prefix_request) && count($prefix_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prefix_request when calling ipamPrefixesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/prefixes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($prefix_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($prefix_request));
            } else {
                $httpBody = $prefix_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Prefix[]
     */
    public function ipamPrefixesBulkUpdate($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkUpdate'][0])
    {
        list($response) = $this->ipamPrefixesBulkUpdateWithHttpInfo($prefix_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamPrefixesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Prefix[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesBulkUpdateWithHttpInfo($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkUpdate'][0])
    {
        $request = $this->ipamPrefixesBulkUpdateRequest($prefix_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Prefix[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Prefix[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Prefix[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Prefix[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Prefix[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesBulkUpdateAsync($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkUpdate'][0])
    {
        return $this->ipamPrefixesBulkUpdateAsyncWithHttpInfo($prefix_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesBulkUpdateAsyncWithHttpInfo($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Prefix[]';
        $request = $this->ipamPrefixesBulkUpdateRequest($prefix_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\PrefixRequest[] $prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesBulkUpdateRequest($prefix_request, string $contentType = self::contentTypes['ipamPrefixesBulkUpdate'][0])
    {

        // verify the required parameter 'prefix_request' is set
        if ($prefix_request === null || (is_array($prefix_request) && count($prefix_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prefix_request when calling ipamPrefixesBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/prefixes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($prefix_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($prefix_request));
            } else {
                $httpBody = $prefix_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesCreate
     *
     * @param  \OpenAPI\Client\Model\WritablePrefixRequest $writable_prefix_request writable_prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Prefix
     */
    public function ipamPrefixesCreate($writable_prefix_request, string $contentType = self::contentTypes['ipamPrefixesCreate'][0])
    {
        list($response) = $this->ipamPrefixesCreateWithHttpInfo($writable_prefix_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamPrefixesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritablePrefixRequest $writable_prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Prefix, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesCreateWithHttpInfo($writable_prefix_request, string $contentType = self::contentTypes['ipamPrefixesCreate'][0])
    {
        $request = $this->ipamPrefixesCreateRequest($writable_prefix_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Prefix' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Prefix' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Prefix', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Prefix';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Prefix',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritablePrefixRequest $writable_prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesCreateAsync($writable_prefix_request, string $contentType = self::contentTypes['ipamPrefixesCreate'][0])
    {
        return $this->ipamPrefixesCreateAsyncWithHttpInfo($writable_prefix_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritablePrefixRequest $writable_prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesCreateAsyncWithHttpInfo($writable_prefix_request, string $contentType = self::contentTypes['ipamPrefixesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Prefix';
        $request = $this->ipamPrefixesCreateRequest($writable_prefix_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesCreate'
     *
     * @param  \OpenAPI\Client\Model\WritablePrefixRequest $writable_prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesCreateRequest($writable_prefix_request, string $contentType = self::contentTypes['ipamPrefixesCreate'][0])
    {

        // verify the required parameter 'writable_prefix_request' is set
        if ($writable_prefix_request === null || (is_array($writable_prefix_request) && count($writable_prefix_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_prefix_request when calling ipamPrefixesCreate'
            );
        }


        $resourcePath = '/api/ipam/prefixes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_prefix_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_prefix_request));
            } else {
                $httpBody = $writable_prefix_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesDestroy
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamPrefixesDestroy($id, string $contentType = self::contentTypes['ipamPrefixesDestroy'][0])
    {
        $this->ipamPrefixesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamPrefixesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamPrefixesDestroy'][0])
    {
        $request = $this->ipamPrefixesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesDestroyAsync($id, string $contentType = self::contentTypes['ipamPrefixesDestroy'][0])
    {
        return $this->ipamPrefixesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamPrefixesDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamPrefixesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesDestroy'
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesDestroyRequest($id, string $contentType = self::contentTypes['ipamPrefixesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamPrefixesDestroy'
            );
        }


        $resourcePath = '/api/ipam/prefixes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesList
     *
     * @param  int[] $children children (optional)
     * @param  int[] $children__empty children__empty (optional)
     * @param  int[] $children__gt children__gt (optional)
     * @param  int[] $children__gte children__gte (optional)
     * @param  int[] $children__lt children__lt (optional)
     * @param  int[] $children__lte children__lte (optional)
     * @param  int[] $children__n children__n (optional)
     * @param  string $contains Prefixes which contain this prefix or IP (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  int[] $depth depth (optional)
     * @param  int[] $depth__empty depth__empty (optional)
     * @param  int[] $depth__gt depth__gt (optional)
     * @param  int[] $depth__gte depth__gte (optional)
     * @param  int[] $depth__lt depth__lt (optional)
     * @param  int[] $depth__lte depth__lte (optional)
     * @param  int[] $depth__n depth__n (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  float $family family (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  bool $is_pool is_pool (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_utilized mark_utilized (optional)
     * @param  int[] $mask_length mask_length (optional)
     * @param  float $mask_length__gte mask_length__gte (optional)
     * @param  float $mask_length__lte mask_length__lte (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $prefix prefix (optional)
     * @param  string $present_in_vrf present_in_vrf (optional)
     * @param  string $present_in_vrf_id present_in_vrf_id (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status Operational status of this prefix (optional)
     * @param  string[] $status__n Operational status of this prefix (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  int[] $vlan_id VLAN (ID) (optional)
     * @param  int[] $vlan_id__n VLAN (ID) (optional)
     * @param  int $vlan_vid VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__empty VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__n VLAN number (1-4094) (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $within Within prefix (optional)
     * @param  string $within_include Within and including prefix (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedPrefixList
     */
    public function ipamPrefixesList($children = null, $children__empty = null, $children__gt = null, $children__gte = null, $children__lt = null, $children__lte = null, $children__n = null, $contains = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $depth = null, $depth__empty = null, $depth__gt = null, $depth__gte = null, $depth__lt = null, $depth__lte = null, $depth__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_pool = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_utilized = null, $mask_length = null, $mask_length__gte = null, $mask_length__lte = null, $modified_by_request = null, $offset = null, $ordering = null, $prefix = null, $present_in_vrf = null, $present_in_vrf_id = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vlan_id = null, $vlan_id__n = null, $vlan_vid = null, $vlan_vid__empty = null, $vlan_vid__gt = null, $vlan_vid__gte = null, $vlan_vid__lt = null, $vlan_vid__lte = null, $vlan_vid__n = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, $within = null, $within_include = null, string $contentType = self::contentTypes['ipamPrefixesList'][0])
    {
        list($response) = $this->ipamPrefixesListWithHttpInfo($children, $children__empty, $children__gt, $children__gte, $children__lt, $children__lte, $children__n, $contains, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $depth, $depth__empty, $depth__gt, $depth__gte, $depth__lt, $depth__lte, $depth__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_pool, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_utilized, $mask_length, $mask_length__gte, $mask_length__lte, $modified_by_request, $offset, $ordering, $prefix, $present_in_vrf, $present_in_vrf_id, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vlan_id, $vlan_id__n, $vlan_vid, $vlan_vid__empty, $vlan_vid__gt, $vlan_vid__gte, $vlan_vid__lt, $vlan_vid__lte, $vlan_vid__n, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $within, $within_include, $contentType);
        return $response;
    }

    /**
     * Operation ipamPrefixesListWithHttpInfo
     *
     * @param  int[] $children (optional)
     * @param  int[] $children__empty (optional)
     * @param  int[] $children__gt (optional)
     * @param  int[] $children__gte (optional)
     * @param  int[] $children__lt (optional)
     * @param  int[] $children__lte (optional)
     * @param  int[] $children__n (optional)
     * @param  string $contains Prefixes which contain this prefix or IP (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $depth (optional)
     * @param  int[] $depth__empty (optional)
     * @param  int[] $depth__gt (optional)
     * @param  int[] $depth__gte (optional)
     * @param  int[] $depth__lt (optional)
     * @param  int[] $depth__lte (optional)
     * @param  int[] $depth__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_pool (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_utilized (optional)
     * @param  int[] $mask_length (optional)
     * @param  float $mask_length__gte (optional)
     * @param  float $mask_length__lte (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $prefix (optional)
     * @param  string $present_in_vrf (optional)
     * @param  string $present_in_vrf_id (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status Operational status of this prefix (optional)
     * @param  string[] $status__n Operational status of this prefix (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vlan_id VLAN (ID) (optional)
     * @param  int[] $vlan_id__n VLAN (ID) (optional)
     * @param  int $vlan_vid VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__empty VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__n VLAN number (1-4094) (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $within Within prefix (optional)
     * @param  string $within_include Within and including prefix (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedPrefixList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesListWithHttpInfo($children = null, $children__empty = null, $children__gt = null, $children__gte = null, $children__lt = null, $children__lte = null, $children__n = null, $contains = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $depth = null, $depth__empty = null, $depth__gt = null, $depth__gte = null, $depth__lt = null, $depth__lte = null, $depth__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_pool = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_utilized = null, $mask_length = null, $mask_length__gte = null, $mask_length__lte = null, $modified_by_request = null, $offset = null, $ordering = null, $prefix = null, $present_in_vrf = null, $present_in_vrf_id = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vlan_id = null, $vlan_id__n = null, $vlan_vid = null, $vlan_vid__empty = null, $vlan_vid__gt = null, $vlan_vid__gte = null, $vlan_vid__lt = null, $vlan_vid__lte = null, $vlan_vid__n = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, $within = null, $within_include = null, string $contentType = self::contentTypes['ipamPrefixesList'][0])
    {
        $request = $this->ipamPrefixesListRequest($children, $children__empty, $children__gt, $children__gte, $children__lt, $children__lte, $children__n, $contains, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $depth, $depth__empty, $depth__gt, $depth__gte, $depth__lt, $depth__lte, $depth__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_pool, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_utilized, $mask_length, $mask_length__gte, $mask_length__lte, $modified_by_request, $offset, $ordering, $prefix, $present_in_vrf, $present_in_vrf_id, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vlan_id, $vlan_id__n, $vlan_vid, $vlan_vid__empty, $vlan_vid__gt, $vlan_vid__gte, $vlan_vid__lt, $vlan_vid__lte, $vlan_vid__n, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $within, $within_include, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedPrefixList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedPrefixList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedPrefixList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedPrefixList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedPrefixList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesListAsync
     *
     * @param  int[] $children (optional)
     * @param  int[] $children__empty (optional)
     * @param  int[] $children__gt (optional)
     * @param  int[] $children__gte (optional)
     * @param  int[] $children__lt (optional)
     * @param  int[] $children__lte (optional)
     * @param  int[] $children__n (optional)
     * @param  string $contains Prefixes which contain this prefix or IP (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $depth (optional)
     * @param  int[] $depth__empty (optional)
     * @param  int[] $depth__gt (optional)
     * @param  int[] $depth__gte (optional)
     * @param  int[] $depth__lt (optional)
     * @param  int[] $depth__lte (optional)
     * @param  int[] $depth__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_pool (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_utilized (optional)
     * @param  int[] $mask_length (optional)
     * @param  float $mask_length__gte (optional)
     * @param  float $mask_length__lte (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $prefix (optional)
     * @param  string $present_in_vrf (optional)
     * @param  string $present_in_vrf_id (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status Operational status of this prefix (optional)
     * @param  string[] $status__n Operational status of this prefix (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vlan_id VLAN (ID) (optional)
     * @param  int[] $vlan_id__n VLAN (ID) (optional)
     * @param  int $vlan_vid VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__empty VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__n VLAN number (1-4094) (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $within Within prefix (optional)
     * @param  string $within_include Within and including prefix (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesListAsync($children = null, $children__empty = null, $children__gt = null, $children__gte = null, $children__lt = null, $children__lte = null, $children__n = null, $contains = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $depth = null, $depth__empty = null, $depth__gt = null, $depth__gte = null, $depth__lt = null, $depth__lte = null, $depth__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_pool = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_utilized = null, $mask_length = null, $mask_length__gte = null, $mask_length__lte = null, $modified_by_request = null, $offset = null, $ordering = null, $prefix = null, $present_in_vrf = null, $present_in_vrf_id = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vlan_id = null, $vlan_id__n = null, $vlan_vid = null, $vlan_vid__empty = null, $vlan_vid__gt = null, $vlan_vid__gte = null, $vlan_vid__lt = null, $vlan_vid__lte = null, $vlan_vid__n = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, $within = null, $within_include = null, string $contentType = self::contentTypes['ipamPrefixesList'][0])
    {
        return $this->ipamPrefixesListAsyncWithHttpInfo($children, $children__empty, $children__gt, $children__gte, $children__lt, $children__lte, $children__n, $contains, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $depth, $depth__empty, $depth__gt, $depth__gte, $depth__lt, $depth__lte, $depth__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_pool, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_utilized, $mask_length, $mask_length__gte, $mask_length__lte, $modified_by_request, $offset, $ordering, $prefix, $present_in_vrf, $present_in_vrf_id, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vlan_id, $vlan_id__n, $vlan_vid, $vlan_vid__empty, $vlan_vid__gt, $vlan_vid__gte, $vlan_vid__lt, $vlan_vid__lte, $vlan_vid__n, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $within, $within_include, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesListAsyncWithHttpInfo
     *
     * @param  int[] $children (optional)
     * @param  int[] $children__empty (optional)
     * @param  int[] $children__gt (optional)
     * @param  int[] $children__gte (optional)
     * @param  int[] $children__lt (optional)
     * @param  int[] $children__lte (optional)
     * @param  int[] $children__n (optional)
     * @param  string $contains Prefixes which contain this prefix or IP (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $depth (optional)
     * @param  int[] $depth__empty (optional)
     * @param  int[] $depth__gt (optional)
     * @param  int[] $depth__gte (optional)
     * @param  int[] $depth__lt (optional)
     * @param  int[] $depth__lte (optional)
     * @param  int[] $depth__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_pool (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_utilized (optional)
     * @param  int[] $mask_length (optional)
     * @param  float $mask_length__gte (optional)
     * @param  float $mask_length__lte (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $prefix (optional)
     * @param  string $present_in_vrf (optional)
     * @param  string $present_in_vrf_id (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status Operational status of this prefix (optional)
     * @param  string[] $status__n Operational status of this prefix (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vlan_id VLAN (ID) (optional)
     * @param  int[] $vlan_id__n VLAN (ID) (optional)
     * @param  int $vlan_vid VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__empty VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__n VLAN number (1-4094) (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $within Within prefix (optional)
     * @param  string $within_include Within and including prefix (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesListAsyncWithHttpInfo($children = null, $children__empty = null, $children__gt = null, $children__gte = null, $children__lt = null, $children__lte = null, $children__n = null, $contains = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $depth = null, $depth__empty = null, $depth__gt = null, $depth__gte = null, $depth__lt = null, $depth__lte = null, $depth__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_pool = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_utilized = null, $mask_length = null, $mask_length__gte = null, $mask_length__lte = null, $modified_by_request = null, $offset = null, $ordering = null, $prefix = null, $present_in_vrf = null, $present_in_vrf_id = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vlan_id = null, $vlan_id__n = null, $vlan_vid = null, $vlan_vid__empty = null, $vlan_vid__gt = null, $vlan_vid__gte = null, $vlan_vid__lt = null, $vlan_vid__lte = null, $vlan_vid__n = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, $within = null, $within_include = null, string $contentType = self::contentTypes['ipamPrefixesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedPrefixList';
        $request = $this->ipamPrefixesListRequest($children, $children__empty, $children__gt, $children__gte, $children__lt, $children__lte, $children__n, $contains, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $depth, $depth__empty, $depth__gt, $depth__gte, $depth__lt, $depth__lte, $depth__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $family, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_pool, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_utilized, $mask_length, $mask_length__gte, $mask_length__lte, $modified_by_request, $offset, $ordering, $prefix, $present_in_vrf, $present_in_vrf_id, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vlan_id, $vlan_id__n, $vlan_vid, $vlan_vid__empty, $vlan_vid__gt, $vlan_vid__gte, $vlan_vid__lt, $vlan_vid__lte, $vlan_vid__n, $vrf, $vrf__n, $vrf_id, $vrf_id__n, $within, $within_include, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesList'
     *
     * @param  int[] $children (optional)
     * @param  int[] $children__empty (optional)
     * @param  int[] $children__gt (optional)
     * @param  int[] $children__gte (optional)
     * @param  int[] $children__lt (optional)
     * @param  int[] $children__lte (optional)
     * @param  int[] $children__n (optional)
     * @param  string $contains Prefixes which contain this prefix or IP (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $depth (optional)
     * @param  int[] $depth__empty (optional)
     * @param  int[] $depth__gt (optional)
     * @param  int[] $depth__gte (optional)
     * @param  int[] $depth__lt (optional)
     * @param  int[] $depth__lte (optional)
     * @param  int[] $depth__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float $family (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_pool (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_utilized (optional)
     * @param  int[] $mask_length (optional)
     * @param  float $mask_length__gte (optional)
     * @param  float $mask_length__lte (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $prefix (optional)
     * @param  string $present_in_vrf (optional)
     * @param  string $present_in_vrf_id (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status Operational status of this prefix (optional)
     * @param  string[] $status__n Operational status of this prefix (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vlan_id VLAN (ID) (optional)
     * @param  int[] $vlan_id__n VLAN (ID) (optional)
     * @param  int $vlan_vid VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__empty VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__n VLAN number (1-4094) (optional)
     * @param  string[] $vrf VRF (RD) (optional)
     * @param  string[] $vrf__n VRF (RD) (optional)
     * @param  int[] $vrf_id VRF (optional)
     * @param  int[] $vrf_id__n VRF (optional)
     * @param  string $within Within prefix (optional)
     * @param  string $within_include Within and including prefix (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesListRequest($children = null, $children__empty = null, $children__gt = null, $children__gte = null, $children__lt = null, $children__lte = null, $children__n = null, $contains = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $depth = null, $depth__empty = null, $depth__gt = null, $depth__gte = null, $depth__lt = null, $depth__lte = null, $depth__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $family = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_pool = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_utilized = null, $mask_length = null, $mask_length__gte = null, $mask_length__lte = null, $modified_by_request = null, $offset = null, $ordering = null, $prefix = null, $present_in_vrf = null, $present_in_vrf_id = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vlan_id = null, $vlan_id__n = null, $vlan_vid = null, $vlan_vid__empty = null, $vlan_vid__gt = null, $vlan_vid__gte = null, $vlan_vid__lt = null, $vlan_vid__lte = null, $vlan_vid__n = null, $vrf = null, $vrf__n = null, $vrf_id = null, $vrf_id__n = null, $within = null, $within_include = null, string $contentType = self::contentTypes['ipamPrefixesList'][0])
    {












































































































        $resourcePath = '/api/ipam/prefixes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $children,
            'children', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $children__empty,
            'children__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $children__gt,
            'children__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $children__gte,
            'children__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $children__lt,
            'children__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $children__lte,
            'children__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $children__n,
            'children__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contains,
            'contains', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $depth,
            'depth', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $depth__empty,
            'depth__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $depth__gt,
            'depth__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $depth__gte,
            'depth__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $depth__lt,
            'depth__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $depth__lte,
            'depth__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $depth__n,
            'depth__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $family,
            'family', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_pool,
            'is_pool', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mark_utilized,
            'mark_utilized', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mask_length,
            'mask_length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mask_length__gte,
            'mask_length__gte', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mask_length__lte,
            'mask_length__lte', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $prefix,
            'prefix', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $present_in_vrf,
            'present_in_vrf', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $present_in_vrf_id,
            'present_in_vrf_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region,
            'region', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region__n,
            'region__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region_id,
            'region_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region_id__n,
            'region_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role,
            'role', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role__n,
            'role__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role_id,
            'role_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role_id__n,
            'role_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site,
            'site', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site__n,
            'site__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group,
            'site_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group__n,
            'site_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group_id,
            'site_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group_id__n,
            'site_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id,
            'site_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id__n,
            'site_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status__n,
            'status__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_id,
            'vlan_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_id__n,
            'vlan_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid,
            'vlan_vid', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__empty,
            'vlan_vid__empty', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__gt,
            'vlan_vid__gt', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__gte,
            'vlan_vid__gte', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__lt,
            'vlan_vid__lt', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__lte,
            'vlan_vid__lte', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__n,
            'vlan_vid__n', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf,
            'vrf', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf__n,
            'vrf__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf_id,
            'vrf_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vrf_id__n,
            'vrf_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $within,
            'within', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $within_include,
            'within_include', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritablePrefixRequest $patched_writable_prefix_request patched_writable_prefix_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Prefix
     */
    public function ipamPrefixesPartialUpdate($id, $patched_writable_prefix_request = null, string $contentType = self::contentTypes['ipamPrefixesPartialUpdate'][0])
    {
        list($response) = $this->ipamPrefixesPartialUpdateWithHttpInfo($id, $patched_writable_prefix_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamPrefixesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritablePrefixRequest $patched_writable_prefix_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Prefix, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesPartialUpdateWithHttpInfo($id, $patched_writable_prefix_request = null, string $contentType = self::contentTypes['ipamPrefixesPartialUpdate'][0])
    {
        $request = $this->ipamPrefixesPartialUpdateRequest($id, $patched_writable_prefix_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Prefix' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Prefix' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Prefix', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Prefix';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Prefix',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritablePrefixRequest $patched_writable_prefix_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesPartialUpdateAsync($id, $patched_writable_prefix_request = null, string $contentType = self::contentTypes['ipamPrefixesPartialUpdate'][0])
    {
        return $this->ipamPrefixesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_prefix_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritablePrefixRequest $patched_writable_prefix_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_prefix_request = null, string $contentType = self::contentTypes['ipamPrefixesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Prefix';
        $request = $this->ipamPrefixesPartialUpdateRequest($id, $patched_writable_prefix_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritablePrefixRequest $patched_writable_prefix_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesPartialUpdateRequest($id, $patched_writable_prefix_request = null, string $contentType = self::contentTypes['ipamPrefixesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamPrefixesPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/prefixes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_prefix_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_prefix_request));
            } else {
                $httpBody = $patched_writable_prefix_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesRetrieve
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Prefix
     */
    public function ipamPrefixesRetrieve($id, string $contentType = self::contentTypes['ipamPrefixesRetrieve'][0])
    {
        list($response) = $this->ipamPrefixesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamPrefixesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Prefix, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamPrefixesRetrieve'][0])
    {
        $request = $this->ipamPrefixesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Prefix' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Prefix' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Prefix', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Prefix';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Prefix',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesRetrieveAsync($id, string $contentType = self::contentTypes['ipamPrefixesRetrieve'][0])
    {
        return $this->ipamPrefixesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamPrefixesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Prefix';
        $request = $this->ipamPrefixesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesRetrieve'
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesRetrieveRequest($id, string $contentType = self::contentTypes['ipamPrefixesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamPrefixesRetrieve'
            );
        }


        $resourcePath = '/api/ipam/prefixes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamPrefixesUpdate
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  \OpenAPI\Client\Model\WritablePrefixRequest $writable_prefix_request writable_prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Prefix
     */
    public function ipamPrefixesUpdate($id, $writable_prefix_request, string $contentType = self::contentTypes['ipamPrefixesUpdate'][0])
    {
        list($response) = $this->ipamPrefixesUpdateWithHttpInfo($id, $writable_prefix_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamPrefixesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  \OpenAPI\Client\Model\WritablePrefixRequest $writable_prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Prefix, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamPrefixesUpdateWithHttpInfo($id, $writable_prefix_request, string $contentType = self::contentTypes['ipamPrefixesUpdate'][0])
    {
        $request = $this->ipamPrefixesUpdateRequest($id, $writable_prefix_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Prefix' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Prefix' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Prefix', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Prefix';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Prefix',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamPrefixesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  \OpenAPI\Client\Model\WritablePrefixRequest $writable_prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesUpdateAsync($id, $writable_prefix_request, string $contentType = self::contentTypes['ipamPrefixesUpdate'][0])
    {
        return $this->ipamPrefixesUpdateAsyncWithHttpInfo($id, $writable_prefix_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamPrefixesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  \OpenAPI\Client\Model\WritablePrefixRequest $writable_prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamPrefixesUpdateAsyncWithHttpInfo($id, $writable_prefix_request, string $contentType = self::contentTypes['ipamPrefixesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Prefix';
        $request = $this->ipamPrefixesUpdateRequest($id, $writable_prefix_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamPrefixesUpdate'
     *
     * @param  int $id A unique integer value identifying this prefix. (required)
     * @param  \OpenAPI\Client\Model\WritablePrefixRequest $writable_prefix_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamPrefixesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamPrefixesUpdateRequest($id, $writable_prefix_request, string $contentType = self::contentTypes['ipamPrefixesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamPrefixesUpdate'
            );
        }

        // verify the required parameter 'writable_prefix_request' is set
        if ($writable_prefix_request === null || (is_array($writable_prefix_request) && count($writable_prefix_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_prefix_request when calling ipamPrefixesUpdate'
            );
        }


        $resourcePath = '/api/ipam/prefixes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_prefix_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_prefix_request));
            } else {
                $httpBody = $writable_prefix_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRirsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamRirsBulkDestroy($rir_request, string $contentType = self::contentTypes['ipamRirsBulkDestroy'][0])
    {
        $this->ipamRirsBulkDestroyWithHttpInfo($rir_request, $contentType);
    }

    /**
     * Operation ipamRirsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRirsBulkDestroyWithHttpInfo($rir_request, string $contentType = self::contentTypes['ipamRirsBulkDestroy'][0])
    {
        $request = $this->ipamRirsBulkDestroyRequest($rir_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRirsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsBulkDestroyAsync($rir_request, string $contentType = self::contentTypes['ipamRirsBulkDestroy'][0])
    {
        return $this->ipamRirsBulkDestroyAsyncWithHttpInfo($rir_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRirsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsBulkDestroyAsyncWithHttpInfo($rir_request, string $contentType = self::contentTypes['ipamRirsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamRirsBulkDestroyRequest($rir_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRirsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRirsBulkDestroyRequest($rir_request, string $contentType = self::contentTypes['ipamRirsBulkDestroy'][0])
    {

        // verify the required parameter 'rir_request' is set
        if ($rir_request === null || (is_array($rir_request) && count($rir_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rir_request when calling ipamRirsBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/rirs/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rir_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rir_request));
            } else {
                $httpBody = $rir_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRirsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RIR[]
     */
    public function ipamRirsBulkPartialUpdate($rir_request, string $contentType = self::contentTypes['ipamRirsBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamRirsBulkPartialUpdateWithHttpInfo($rir_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRirsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RIR[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRirsBulkPartialUpdateWithHttpInfo($rir_request, string $contentType = self::contentTypes['ipamRirsBulkPartialUpdate'][0])
    {
        $request = $this->ipamRirsBulkPartialUpdateRequest($rir_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RIR[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RIR[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RIR[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RIR[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RIR[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRirsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsBulkPartialUpdateAsync($rir_request, string $contentType = self::contentTypes['ipamRirsBulkPartialUpdate'][0])
    {
        return $this->ipamRirsBulkPartialUpdateAsyncWithHttpInfo($rir_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRirsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsBulkPartialUpdateAsyncWithHttpInfo($rir_request, string $contentType = self::contentTypes['ipamRirsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RIR[]';
        $request = $this->ipamRirsBulkPartialUpdateRequest($rir_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRirsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRirsBulkPartialUpdateRequest($rir_request, string $contentType = self::contentTypes['ipamRirsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'rir_request' is set
        if ($rir_request === null || (is_array($rir_request) && count($rir_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rir_request when calling ipamRirsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/rirs/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rir_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rir_request));
            } else {
                $httpBody = $rir_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRirsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RIR[]
     */
    public function ipamRirsBulkUpdate($rir_request, string $contentType = self::contentTypes['ipamRirsBulkUpdate'][0])
    {
        list($response) = $this->ipamRirsBulkUpdateWithHttpInfo($rir_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRirsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RIR[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRirsBulkUpdateWithHttpInfo($rir_request, string $contentType = self::contentTypes['ipamRirsBulkUpdate'][0])
    {
        $request = $this->ipamRirsBulkUpdateRequest($rir_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RIR[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RIR[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RIR[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RIR[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RIR[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRirsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsBulkUpdateAsync($rir_request, string $contentType = self::contentTypes['ipamRirsBulkUpdate'][0])
    {
        return $this->ipamRirsBulkUpdateAsyncWithHttpInfo($rir_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRirsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsBulkUpdateAsyncWithHttpInfo($rir_request, string $contentType = self::contentTypes['ipamRirsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RIR[]';
        $request = $this->ipamRirsBulkUpdateRequest($rir_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRirsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\RIRRequest[] $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRirsBulkUpdateRequest($rir_request, string $contentType = self::contentTypes['ipamRirsBulkUpdate'][0])
    {

        // verify the required parameter 'rir_request' is set
        if ($rir_request === null || (is_array($rir_request) && count($rir_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rir_request when calling ipamRirsBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/rirs/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rir_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rir_request));
            } else {
                $httpBody = $rir_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRirsCreate
     *
     * @param  \OpenAPI\Client\Model\RIRRequest $rir_request rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RIR
     */
    public function ipamRirsCreate($rir_request, string $contentType = self::contentTypes['ipamRirsCreate'][0])
    {
        list($response) = $this->ipamRirsCreateWithHttpInfo($rir_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRirsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RIRRequest $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RIR, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRirsCreateWithHttpInfo($rir_request, string $contentType = self::contentTypes['ipamRirsCreate'][0])
    {
        $request = $this->ipamRirsCreateRequest($rir_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\RIR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RIR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RIR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RIR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RIR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRirsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\RIRRequest $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsCreateAsync($rir_request, string $contentType = self::contentTypes['ipamRirsCreate'][0])
    {
        return $this->ipamRirsCreateAsyncWithHttpInfo($rir_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRirsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RIRRequest $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsCreateAsyncWithHttpInfo($rir_request, string $contentType = self::contentTypes['ipamRirsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RIR';
        $request = $this->ipamRirsCreateRequest($rir_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRirsCreate'
     *
     * @param  \OpenAPI\Client\Model\RIRRequest $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRirsCreateRequest($rir_request, string $contentType = self::contentTypes['ipamRirsCreate'][0])
    {

        // verify the required parameter 'rir_request' is set
        if ($rir_request === null || (is_array($rir_request) && count($rir_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rir_request when calling ipamRirsCreate'
            );
        }


        $resourcePath = '/api/ipam/rirs/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rir_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rir_request));
            } else {
                $httpBody = $rir_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRirsDestroy
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamRirsDestroy($id, string $contentType = self::contentTypes['ipamRirsDestroy'][0])
    {
        $this->ipamRirsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamRirsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRirsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamRirsDestroy'][0])
    {
        $request = $this->ipamRirsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRirsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsDestroyAsync($id, string $contentType = self::contentTypes['ipamRirsDestroy'][0])
    {
        return $this->ipamRirsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRirsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamRirsDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamRirsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRirsDestroy'
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRirsDestroyRequest($id, string $contentType = self::contentTypes['ipamRirsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRirsDestroy'
            );
        }


        $resourcePath = '/api/ipam/rirs/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRirsList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  bool $is_private is_private (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug slug (optional)
     * @param  bool $slug__empty slug__empty (optional)
     * @param  string[] $slug__ic slug__ic (optional)
     * @param  string[] $slug__ie slug__ie (optional)
     * @param  string[] $slug__iew slug__iew (optional)
     * @param  string[] $slug__isw slug__isw (optional)
     * @param  string[] $slug__n slug__n (optional)
     * @param  string[] $slug__nic slug__nic (optional)
     * @param  string[] $slug__nie slug__nie (optional)
     * @param  string[] $slug__niew slug__niew (optional)
     * @param  string[] $slug__nisw slug__nisw (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedRIRList
     */
    public function ipamRirsList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_private = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamRirsList'][0])
    {
        list($response) = $this->ipamRirsListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_private, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRirsListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_private (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedRIRList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRirsListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_private = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamRirsList'][0])
    {
        $request = $this->ipamRirsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_private, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedRIRList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedRIRList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedRIRList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedRIRList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedRIRList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRirsListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_private (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_private = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamRirsList'][0])
    {
        return $this->ipamRirsListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_private, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRirsListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_private (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_private = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamRirsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedRIRList';
        $request = $this->ipamRirsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_private, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRirsList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_private (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRirsListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_private = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamRirsList'][0])
    {


































































        $resourcePath = '/api/ipam/rirs/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_private,
            'is_private', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__empty,
            'slug__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ic,
            'slug__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ie,
            'slug__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__iew,
            'slug__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__isw,
            'slug__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__n,
            'slug__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nic,
            'slug__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nie,
            'slug__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__niew,
            'slug__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nisw,
            'slug__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRirsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  \OpenAPI\Client\Model\PatchedRIRRequest $patched_rir_request patched_rir_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RIR
     */
    public function ipamRirsPartialUpdate($id, $patched_rir_request = null, string $contentType = self::contentTypes['ipamRirsPartialUpdate'][0])
    {
        list($response) = $this->ipamRirsPartialUpdateWithHttpInfo($id, $patched_rir_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRirsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  \OpenAPI\Client\Model\PatchedRIRRequest $patched_rir_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RIR, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRirsPartialUpdateWithHttpInfo($id, $patched_rir_request = null, string $contentType = self::contentTypes['ipamRirsPartialUpdate'][0])
    {
        $request = $this->ipamRirsPartialUpdateRequest($id, $patched_rir_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RIR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RIR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RIR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RIR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RIR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRirsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  \OpenAPI\Client\Model\PatchedRIRRequest $patched_rir_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsPartialUpdateAsync($id, $patched_rir_request = null, string $contentType = self::contentTypes['ipamRirsPartialUpdate'][0])
    {
        return $this->ipamRirsPartialUpdateAsyncWithHttpInfo($id, $patched_rir_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRirsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  \OpenAPI\Client\Model\PatchedRIRRequest $patched_rir_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsPartialUpdateAsyncWithHttpInfo($id, $patched_rir_request = null, string $contentType = self::contentTypes['ipamRirsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RIR';
        $request = $this->ipamRirsPartialUpdateRequest($id, $patched_rir_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRirsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  \OpenAPI\Client\Model\PatchedRIRRequest $patched_rir_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRirsPartialUpdateRequest($id, $patched_rir_request = null, string $contentType = self::contentTypes['ipamRirsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRirsPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/rirs/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_rir_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_rir_request));
            } else {
                $httpBody = $patched_rir_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRirsRetrieve
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RIR
     */
    public function ipamRirsRetrieve($id, string $contentType = self::contentTypes['ipamRirsRetrieve'][0])
    {
        list($response) = $this->ipamRirsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamRirsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RIR, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRirsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamRirsRetrieve'][0])
    {
        $request = $this->ipamRirsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RIR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RIR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RIR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RIR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RIR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRirsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsRetrieveAsync($id, string $contentType = self::contentTypes['ipamRirsRetrieve'][0])
    {
        return $this->ipamRirsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRirsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamRirsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RIR';
        $request = $this->ipamRirsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRirsRetrieve'
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRirsRetrieveRequest($id, string $contentType = self::contentTypes['ipamRirsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRirsRetrieve'
            );
        }


        $resourcePath = '/api/ipam/rirs/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRirsUpdate
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  \OpenAPI\Client\Model\RIRRequest $rir_request rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RIR
     */
    public function ipamRirsUpdate($id, $rir_request, string $contentType = self::contentTypes['ipamRirsUpdate'][0])
    {
        list($response) = $this->ipamRirsUpdateWithHttpInfo($id, $rir_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRirsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  \OpenAPI\Client\Model\RIRRequest $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RIR, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRirsUpdateWithHttpInfo($id, $rir_request, string $contentType = self::contentTypes['ipamRirsUpdate'][0])
    {
        $request = $this->ipamRirsUpdateRequest($id, $rir_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RIR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RIR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RIR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RIR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RIR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRirsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  \OpenAPI\Client\Model\RIRRequest $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsUpdateAsync($id, $rir_request, string $contentType = self::contentTypes['ipamRirsUpdate'][0])
    {
        return $this->ipamRirsUpdateAsyncWithHttpInfo($id, $rir_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRirsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  \OpenAPI\Client\Model\RIRRequest $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRirsUpdateAsyncWithHttpInfo($id, $rir_request, string $contentType = self::contentTypes['ipamRirsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RIR';
        $request = $this->ipamRirsUpdateRequest($id, $rir_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRirsUpdate'
     *
     * @param  int $id A unique integer value identifying this RIR. (required)
     * @param  \OpenAPI\Client\Model\RIRRequest $rir_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRirsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRirsUpdateRequest($id, $rir_request, string $contentType = self::contentTypes['ipamRirsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRirsUpdate'
            );
        }

        // verify the required parameter 'rir_request' is set
        if ($rir_request === null || (is_array($rir_request) && count($rir_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rir_request when calling ipamRirsUpdate'
            );
        }


        $resourcePath = '/api/ipam/rirs/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rir_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rir_request));
            } else {
                $httpBody = $rir_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRolesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamRolesBulkDestroy($role_request, string $contentType = self::contentTypes['ipamRolesBulkDestroy'][0])
    {
        $this->ipamRolesBulkDestroyWithHttpInfo($role_request, $contentType);
    }

    /**
     * Operation ipamRolesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRolesBulkDestroyWithHttpInfo($role_request, string $contentType = self::contentTypes['ipamRolesBulkDestroy'][0])
    {
        $request = $this->ipamRolesBulkDestroyRequest($role_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRolesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesBulkDestroyAsync($role_request, string $contentType = self::contentTypes['ipamRolesBulkDestroy'][0])
    {
        return $this->ipamRolesBulkDestroyAsyncWithHttpInfo($role_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRolesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesBulkDestroyAsyncWithHttpInfo($role_request, string $contentType = self::contentTypes['ipamRolesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamRolesBulkDestroyRequest($role_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRolesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRolesBulkDestroyRequest($role_request, string $contentType = self::contentTypes['ipamRolesBulkDestroy'][0])
    {

        // verify the required parameter 'role_request' is set
        if ($role_request === null || (is_array($role_request) && count($role_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $role_request when calling ipamRolesBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/roles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($role_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($role_request));
            } else {
                $httpBody = $role_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRolesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Role[]
     */
    public function ipamRolesBulkPartialUpdate($role_request, string $contentType = self::contentTypes['ipamRolesBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamRolesBulkPartialUpdateWithHttpInfo($role_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRolesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Role[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRolesBulkPartialUpdateWithHttpInfo($role_request, string $contentType = self::contentTypes['ipamRolesBulkPartialUpdate'][0])
    {
        $request = $this->ipamRolesBulkPartialUpdateRequest($role_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Role[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Role[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Role[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Role[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Role[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRolesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesBulkPartialUpdateAsync($role_request, string $contentType = self::contentTypes['ipamRolesBulkPartialUpdate'][0])
    {
        return $this->ipamRolesBulkPartialUpdateAsyncWithHttpInfo($role_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRolesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesBulkPartialUpdateAsyncWithHttpInfo($role_request, string $contentType = self::contentTypes['ipamRolesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Role[]';
        $request = $this->ipamRolesBulkPartialUpdateRequest($role_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRolesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRolesBulkPartialUpdateRequest($role_request, string $contentType = self::contentTypes['ipamRolesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'role_request' is set
        if ($role_request === null || (is_array($role_request) && count($role_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $role_request when calling ipamRolesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/roles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($role_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($role_request));
            } else {
                $httpBody = $role_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRolesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Role[]
     */
    public function ipamRolesBulkUpdate($role_request, string $contentType = self::contentTypes['ipamRolesBulkUpdate'][0])
    {
        list($response) = $this->ipamRolesBulkUpdateWithHttpInfo($role_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRolesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Role[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRolesBulkUpdateWithHttpInfo($role_request, string $contentType = self::contentTypes['ipamRolesBulkUpdate'][0])
    {
        $request = $this->ipamRolesBulkUpdateRequest($role_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Role[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Role[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Role[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Role[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Role[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRolesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesBulkUpdateAsync($role_request, string $contentType = self::contentTypes['ipamRolesBulkUpdate'][0])
    {
        return $this->ipamRolesBulkUpdateAsyncWithHttpInfo($role_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRolesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesBulkUpdateAsyncWithHttpInfo($role_request, string $contentType = self::contentTypes['ipamRolesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Role[]';
        $request = $this->ipamRolesBulkUpdateRequest($role_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRolesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\RoleRequest[] $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRolesBulkUpdateRequest($role_request, string $contentType = self::contentTypes['ipamRolesBulkUpdate'][0])
    {

        // verify the required parameter 'role_request' is set
        if ($role_request === null || (is_array($role_request) && count($role_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $role_request when calling ipamRolesBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/roles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($role_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($role_request));
            } else {
                $httpBody = $role_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRolesCreate
     *
     * @param  \OpenAPI\Client\Model\RoleRequest $role_request role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Role
     */
    public function ipamRolesCreate($role_request, string $contentType = self::contentTypes['ipamRolesCreate'][0])
    {
        list($response) = $this->ipamRolesCreateWithHttpInfo($role_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRolesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RoleRequest $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Role, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRolesCreateWithHttpInfo($role_request, string $contentType = self::contentTypes['ipamRolesCreate'][0])
    {
        $request = $this->ipamRolesCreateRequest($role_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Role' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Role' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Role', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Role';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Role',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRolesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\RoleRequest $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesCreateAsync($role_request, string $contentType = self::contentTypes['ipamRolesCreate'][0])
    {
        return $this->ipamRolesCreateAsyncWithHttpInfo($role_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRolesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RoleRequest $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesCreateAsyncWithHttpInfo($role_request, string $contentType = self::contentTypes['ipamRolesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Role';
        $request = $this->ipamRolesCreateRequest($role_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRolesCreate'
     *
     * @param  \OpenAPI\Client\Model\RoleRequest $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRolesCreateRequest($role_request, string $contentType = self::contentTypes['ipamRolesCreate'][0])
    {

        // verify the required parameter 'role_request' is set
        if ($role_request === null || (is_array($role_request) && count($role_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $role_request when calling ipamRolesCreate'
            );
        }


        $resourcePath = '/api/ipam/roles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($role_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($role_request));
            } else {
                $httpBody = $role_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRolesDestroy
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamRolesDestroy($id, string $contentType = self::contentTypes['ipamRolesDestroy'][0])
    {
        $this->ipamRolesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamRolesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRolesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamRolesDestroy'][0])
    {
        $request = $this->ipamRolesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRolesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesDestroyAsync($id, string $contentType = self::contentTypes['ipamRolesDestroy'][0])
    {
        return $this->ipamRolesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRolesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamRolesDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamRolesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRolesDestroy'
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRolesDestroyRequest($id, string $contentType = self::contentTypes['ipamRolesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRolesDestroy'
            );
        }


        $resourcePath = '/api/ipam/roles/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRolesList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug slug (optional)
     * @param  bool $slug__empty slug__empty (optional)
     * @param  string[] $slug__ic slug__ic (optional)
     * @param  string[] $slug__ie slug__ie (optional)
     * @param  string[] $slug__iew slug__iew (optional)
     * @param  string[] $slug__isw slug__isw (optional)
     * @param  string[] $slug__n slug__n (optional)
     * @param  string[] $slug__nic slug__nic (optional)
     * @param  string[] $slug__nie slug__nie (optional)
     * @param  string[] $slug__niew slug__niew (optional)
     * @param  string[] $slug__nisw slug__nisw (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  int[] $weight weight (optional)
     * @param  bool $weight__empty weight__empty (optional)
     * @param  int[] $weight__gt weight__gt (optional)
     * @param  int[] $weight__gte weight__gte (optional)
     * @param  int[] $weight__lt weight__lt (optional)
     * @param  int[] $weight__lte weight__lte (optional)
     * @param  int[] $weight__n weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedRoleList
     */
    public function ipamRolesList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['ipamRolesList'][0])
    {
        list($response) = $this->ipamRolesListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);
        return $response;
    }

    /**
     * Operation ipamRolesListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedRoleList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRolesListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['ipamRolesList'][0])
    {
        $request = $this->ipamRolesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedRoleList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedRoleList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedRoleList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedRoleList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedRoleList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRolesListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['ipamRolesList'][0])
    {
        return $this->ipamRolesListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRolesListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['ipamRolesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedRoleList';
        $request = $this->ipamRolesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRolesList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRolesListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['ipamRolesList'][0])
    {








































































        $resourcePath = '/api/ipam/roles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__empty,
            'slug__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ic,
            'slug__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ie,
            'slug__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__iew,
            'slug__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__isw,
            'slug__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__n,
            'slug__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nic,
            'slug__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nie,
            'slug__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__niew,
            'slug__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nisw,
            'slug__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight,
            'weight', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__empty,
            'weight__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__gt,
            'weight__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__gte,
            'weight__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__lt,
            'weight__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__lte,
            'weight__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__n,
            'weight__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRolesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  \OpenAPI\Client\Model\PatchedRoleRequest $patched_role_request patched_role_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Role
     */
    public function ipamRolesPartialUpdate($id, $patched_role_request = null, string $contentType = self::contentTypes['ipamRolesPartialUpdate'][0])
    {
        list($response) = $this->ipamRolesPartialUpdateWithHttpInfo($id, $patched_role_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRolesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  \OpenAPI\Client\Model\PatchedRoleRequest $patched_role_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Role, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRolesPartialUpdateWithHttpInfo($id, $patched_role_request = null, string $contentType = self::contentTypes['ipamRolesPartialUpdate'][0])
    {
        $request = $this->ipamRolesPartialUpdateRequest($id, $patched_role_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Role' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Role' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Role', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Role';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Role',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRolesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  \OpenAPI\Client\Model\PatchedRoleRequest $patched_role_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesPartialUpdateAsync($id, $patched_role_request = null, string $contentType = self::contentTypes['ipamRolesPartialUpdate'][0])
    {
        return $this->ipamRolesPartialUpdateAsyncWithHttpInfo($id, $patched_role_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRolesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  \OpenAPI\Client\Model\PatchedRoleRequest $patched_role_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesPartialUpdateAsyncWithHttpInfo($id, $patched_role_request = null, string $contentType = self::contentTypes['ipamRolesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Role';
        $request = $this->ipamRolesPartialUpdateRequest($id, $patched_role_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRolesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  \OpenAPI\Client\Model\PatchedRoleRequest $patched_role_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRolesPartialUpdateRequest($id, $patched_role_request = null, string $contentType = self::contentTypes['ipamRolesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRolesPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/roles/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_role_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_role_request));
            } else {
                $httpBody = $patched_role_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRolesRetrieve
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Role
     */
    public function ipamRolesRetrieve($id, string $contentType = self::contentTypes['ipamRolesRetrieve'][0])
    {
        list($response) = $this->ipamRolesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamRolesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Role, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRolesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamRolesRetrieve'][0])
    {
        $request = $this->ipamRolesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Role' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Role' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Role', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Role';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Role',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRolesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesRetrieveAsync($id, string $contentType = self::contentTypes['ipamRolesRetrieve'][0])
    {
        return $this->ipamRolesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRolesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamRolesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Role';
        $request = $this->ipamRolesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRolesRetrieve'
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRolesRetrieveRequest($id, string $contentType = self::contentTypes['ipamRolesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRolesRetrieve'
            );
        }


        $resourcePath = '/api/ipam/roles/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRolesUpdate
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  \OpenAPI\Client\Model\RoleRequest $role_request role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Role
     */
    public function ipamRolesUpdate($id, $role_request, string $contentType = self::contentTypes['ipamRolesUpdate'][0])
    {
        list($response) = $this->ipamRolesUpdateWithHttpInfo($id, $role_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRolesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  \OpenAPI\Client\Model\RoleRequest $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Role, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRolesUpdateWithHttpInfo($id, $role_request, string $contentType = self::contentTypes['ipamRolesUpdate'][0])
    {
        $request = $this->ipamRolesUpdateRequest($id, $role_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Role' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Role' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Role', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Role';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Role',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRolesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  \OpenAPI\Client\Model\RoleRequest $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesUpdateAsync($id, $role_request, string $contentType = self::contentTypes['ipamRolesUpdate'][0])
    {
        return $this->ipamRolesUpdateAsyncWithHttpInfo($id, $role_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRolesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  \OpenAPI\Client\Model\RoleRequest $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRolesUpdateAsyncWithHttpInfo($id, $role_request, string $contentType = self::contentTypes['ipamRolesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Role';
        $request = $this->ipamRolesUpdateRequest($id, $role_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRolesUpdate'
     *
     * @param  int $id A unique integer value identifying this role. (required)
     * @param  \OpenAPI\Client\Model\RoleRequest $role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRolesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRolesUpdateRequest($id, $role_request, string $contentType = self::contentTypes['ipamRolesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRolesUpdate'
            );
        }

        // verify the required parameter 'role_request' is set
        if ($role_request === null || (is_array($role_request) && count($role_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $role_request when calling ipamRolesUpdate'
            );
        }


        $resourcePath = '/api/ipam/roles/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($role_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($role_request));
            } else {
                $httpBody = $role_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRouteTargetsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamRouteTargetsBulkDestroy($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkDestroy'][0])
    {
        $this->ipamRouteTargetsBulkDestroyWithHttpInfo($route_target_request, $contentType);
    }

    /**
     * Operation ipamRouteTargetsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRouteTargetsBulkDestroyWithHttpInfo($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkDestroy'][0])
    {
        $request = $this->ipamRouteTargetsBulkDestroyRequest($route_target_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRouteTargetsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsBulkDestroyAsync($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkDestroy'][0])
    {
        return $this->ipamRouteTargetsBulkDestroyAsyncWithHttpInfo($route_target_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRouteTargetsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsBulkDestroyAsyncWithHttpInfo($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamRouteTargetsBulkDestroyRequest($route_target_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRouteTargetsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRouteTargetsBulkDestroyRequest($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkDestroy'][0])
    {

        // verify the required parameter 'route_target_request' is set
        if ($route_target_request === null || (is_array($route_target_request) && count($route_target_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $route_target_request when calling ipamRouteTargetsBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/route-targets/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($route_target_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($route_target_request));
            } else {
                $httpBody = $route_target_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRouteTargetsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RouteTarget[]
     */
    public function ipamRouteTargetsBulkPartialUpdate($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamRouteTargetsBulkPartialUpdateWithHttpInfo($route_target_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRouteTargetsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RouteTarget[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRouteTargetsBulkPartialUpdateWithHttpInfo($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkPartialUpdate'][0])
    {
        $request = $this->ipamRouteTargetsBulkPartialUpdateRequest($route_target_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RouteTarget[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RouteTarget[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RouteTarget[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RouteTarget[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RouteTarget[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRouteTargetsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsBulkPartialUpdateAsync($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkPartialUpdate'][0])
    {
        return $this->ipamRouteTargetsBulkPartialUpdateAsyncWithHttpInfo($route_target_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRouteTargetsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsBulkPartialUpdateAsyncWithHttpInfo($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RouteTarget[]';
        $request = $this->ipamRouteTargetsBulkPartialUpdateRequest($route_target_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRouteTargetsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRouteTargetsBulkPartialUpdateRequest($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'route_target_request' is set
        if ($route_target_request === null || (is_array($route_target_request) && count($route_target_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $route_target_request when calling ipamRouteTargetsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/route-targets/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($route_target_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($route_target_request));
            } else {
                $httpBody = $route_target_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRouteTargetsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RouteTarget[]
     */
    public function ipamRouteTargetsBulkUpdate($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkUpdate'][0])
    {
        list($response) = $this->ipamRouteTargetsBulkUpdateWithHttpInfo($route_target_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRouteTargetsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RouteTarget[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRouteTargetsBulkUpdateWithHttpInfo($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkUpdate'][0])
    {
        $request = $this->ipamRouteTargetsBulkUpdateRequest($route_target_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RouteTarget[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RouteTarget[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RouteTarget[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RouteTarget[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RouteTarget[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRouteTargetsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsBulkUpdateAsync($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkUpdate'][0])
    {
        return $this->ipamRouteTargetsBulkUpdateAsyncWithHttpInfo($route_target_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRouteTargetsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsBulkUpdateAsyncWithHttpInfo($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RouteTarget[]';
        $request = $this->ipamRouteTargetsBulkUpdateRequest($route_target_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRouteTargetsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest[] $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRouteTargetsBulkUpdateRequest($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsBulkUpdate'][0])
    {

        // verify the required parameter 'route_target_request' is set
        if ($route_target_request === null || (is_array($route_target_request) && count($route_target_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $route_target_request when calling ipamRouteTargetsBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/route-targets/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($route_target_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($route_target_request));
            } else {
                $httpBody = $route_target_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRouteTargetsCreate
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest $route_target_request route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RouteTarget
     */
    public function ipamRouteTargetsCreate($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsCreate'][0])
    {
        list($response) = $this->ipamRouteTargetsCreateWithHttpInfo($route_target_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRouteTargetsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RouteTarget, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRouteTargetsCreateWithHttpInfo($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsCreate'][0])
    {
        $request = $this->ipamRouteTargetsCreateRequest($route_target_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\RouteTarget' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RouteTarget' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RouteTarget', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RouteTarget';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RouteTarget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRouteTargetsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsCreateAsync($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsCreate'][0])
    {
        return $this->ipamRouteTargetsCreateAsyncWithHttpInfo($route_target_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRouteTargetsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsCreateAsyncWithHttpInfo($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RouteTarget';
        $request = $this->ipamRouteTargetsCreateRequest($route_target_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRouteTargetsCreate'
     *
     * @param  \OpenAPI\Client\Model\RouteTargetRequest $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRouteTargetsCreateRequest($route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsCreate'][0])
    {

        // verify the required parameter 'route_target_request' is set
        if ($route_target_request === null || (is_array($route_target_request) && count($route_target_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $route_target_request when calling ipamRouteTargetsCreate'
            );
        }


        $resourcePath = '/api/ipam/route-targets/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($route_target_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($route_target_request));
            } else {
                $httpBody = $route_target_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRouteTargetsDestroy
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamRouteTargetsDestroy($id, string $contentType = self::contentTypes['ipamRouteTargetsDestroy'][0])
    {
        $this->ipamRouteTargetsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamRouteTargetsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRouteTargetsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamRouteTargetsDestroy'][0])
    {
        $request = $this->ipamRouteTargetsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRouteTargetsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsDestroyAsync($id, string $contentType = self::contentTypes['ipamRouteTargetsDestroy'][0])
    {
        return $this->ipamRouteTargetsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRouteTargetsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamRouteTargetsDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamRouteTargetsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRouteTargetsDestroy'
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRouteTargetsDestroyRequest($id, string $contentType = self::contentTypes['ipamRouteTargetsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRouteTargetsDestroy'
            );
        }


        $resourcePath = '/api/ipam/route-targets/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRouteTargetsList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $exporting_l2vpn Exporting L2VPN (identifier) (optional)
     * @param  int[] $exporting_l2vpn__n Exporting L2VPN (identifier) (optional)
     * @param  int[] $exporting_l2vpn_id Exporting L2VPN (optional)
     * @param  int[] $exporting_l2vpn_id__n Exporting L2VPN (optional)
     * @param  string[] $exporting_vrf Export VRF (RD) (optional)
     * @param  string[] $exporting_vrf__n Export VRF (RD) (optional)
     * @param  int[] $exporting_vrf_id Exporting VRF (optional)
     * @param  int[] $exporting_vrf_id__n Exporting VRF (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  int[] $importing_l2vpn Importing L2VPN (identifier) (optional)
     * @param  int[] $importing_l2vpn__n Importing L2VPN (identifier) (optional)
     * @param  int[] $importing_l2vpn_id Importing L2VPN (optional)
     * @param  int[] $importing_l2vpn_id__n Importing L2VPN (optional)
     * @param  string[] $importing_vrf Import VRF (RD) (optional)
     * @param  string[] $importing_vrf__n Import VRF (RD) (optional)
     * @param  int[] $importing_vrf_id Importing VRF (optional)
     * @param  int[] $importing_vrf_id__n Importing VRF (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedRouteTargetList
     */
    public function ipamRouteTargetsList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $exporting_l2vpn = null, $exporting_l2vpn__n = null, $exporting_l2vpn_id = null, $exporting_l2vpn_id__n = null, $exporting_vrf = null, $exporting_vrf__n = null, $exporting_vrf_id = null, $exporting_vrf_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $importing_l2vpn = null, $importing_l2vpn__n = null, $importing_l2vpn_id = null, $importing_l2vpn_id__n = null, $importing_vrf = null, $importing_vrf__n = null, $importing_vrf_id = null, $importing_vrf_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamRouteTargetsList'][0])
    {
        list($response) = $this->ipamRouteTargetsListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $exporting_l2vpn, $exporting_l2vpn__n, $exporting_l2vpn_id, $exporting_l2vpn_id__n, $exporting_vrf, $exporting_vrf__n, $exporting_vrf_id, $exporting_vrf_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $importing_l2vpn, $importing_l2vpn__n, $importing_l2vpn_id, $importing_l2vpn_id__n, $importing_vrf, $importing_vrf__n, $importing_vrf_id, $importing_vrf_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRouteTargetsListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $exporting_l2vpn Exporting L2VPN (identifier) (optional)
     * @param  int[] $exporting_l2vpn__n Exporting L2VPN (identifier) (optional)
     * @param  int[] $exporting_l2vpn_id Exporting L2VPN (optional)
     * @param  int[] $exporting_l2vpn_id__n Exporting L2VPN (optional)
     * @param  string[] $exporting_vrf Export VRF (RD) (optional)
     * @param  string[] $exporting_vrf__n Export VRF (RD) (optional)
     * @param  int[] $exporting_vrf_id Exporting VRF (optional)
     * @param  int[] $exporting_vrf_id__n Exporting VRF (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $importing_l2vpn Importing L2VPN (identifier) (optional)
     * @param  int[] $importing_l2vpn__n Importing L2VPN (identifier) (optional)
     * @param  int[] $importing_l2vpn_id Importing L2VPN (optional)
     * @param  int[] $importing_l2vpn_id__n Importing L2VPN (optional)
     * @param  string[] $importing_vrf Import VRF (RD) (optional)
     * @param  string[] $importing_vrf__n Import VRF (RD) (optional)
     * @param  int[] $importing_vrf_id Importing VRF (optional)
     * @param  int[] $importing_vrf_id__n Importing VRF (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedRouteTargetList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRouteTargetsListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $exporting_l2vpn = null, $exporting_l2vpn__n = null, $exporting_l2vpn_id = null, $exporting_l2vpn_id__n = null, $exporting_vrf = null, $exporting_vrf__n = null, $exporting_vrf_id = null, $exporting_vrf_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $importing_l2vpn = null, $importing_l2vpn__n = null, $importing_l2vpn_id = null, $importing_l2vpn_id__n = null, $importing_vrf = null, $importing_vrf__n = null, $importing_vrf_id = null, $importing_vrf_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamRouteTargetsList'][0])
    {
        $request = $this->ipamRouteTargetsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $exporting_l2vpn, $exporting_l2vpn__n, $exporting_l2vpn_id, $exporting_l2vpn_id__n, $exporting_vrf, $exporting_vrf__n, $exporting_vrf_id, $exporting_vrf_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $importing_l2vpn, $importing_l2vpn__n, $importing_l2vpn_id, $importing_l2vpn_id__n, $importing_vrf, $importing_vrf__n, $importing_vrf_id, $importing_vrf_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedRouteTargetList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedRouteTargetList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedRouteTargetList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedRouteTargetList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedRouteTargetList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRouteTargetsListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $exporting_l2vpn Exporting L2VPN (identifier) (optional)
     * @param  int[] $exporting_l2vpn__n Exporting L2VPN (identifier) (optional)
     * @param  int[] $exporting_l2vpn_id Exporting L2VPN (optional)
     * @param  int[] $exporting_l2vpn_id__n Exporting L2VPN (optional)
     * @param  string[] $exporting_vrf Export VRF (RD) (optional)
     * @param  string[] $exporting_vrf__n Export VRF (RD) (optional)
     * @param  int[] $exporting_vrf_id Exporting VRF (optional)
     * @param  int[] $exporting_vrf_id__n Exporting VRF (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $importing_l2vpn Importing L2VPN (identifier) (optional)
     * @param  int[] $importing_l2vpn__n Importing L2VPN (identifier) (optional)
     * @param  int[] $importing_l2vpn_id Importing L2VPN (optional)
     * @param  int[] $importing_l2vpn_id__n Importing L2VPN (optional)
     * @param  string[] $importing_vrf Import VRF (RD) (optional)
     * @param  string[] $importing_vrf__n Import VRF (RD) (optional)
     * @param  int[] $importing_vrf_id Importing VRF (optional)
     * @param  int[] $importing_vrf_id__n Importing VRF (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $exporting_l2vpn = null, $exporting_l2vpn__n = null, $exporting_l2vpn_id = null, $exporting_l2vpn_id__n = null, $exporting_vrf = null, $exporting_vrf__n = null, $exporting_vrf_id = null, $exporting_vrf_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $importing_l2vpn = null, $importing_l2vpn__n = null, $importing_l2vpn_id = null, $importing_l2vpn_id__n = null, $importing_vrf = null, $importing_vrf__n = null, $importing_vrf_id = null, $importing_vrf_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamRouteTargetsList'][0])
    {
        return $this->ipamRouteTargetsListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $exporting_l2vpn, $exporting_l2vpn__n, $exporting_l2vpn_id, $exporting_l2vpn_id__n, $exporting_vrf, $exporting_vrf__n, $exporting_vrf_id, $exporting_vrf_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $importing_l2vpn, $importing_l2vpn__n, $importing_l2vpn_id, $importing_l2vpn_id__n, $importing_vrf, $importing_vrf__n, $importing_vrf_id, $importing_vrf_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRouteTargetsListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $exporting_l2vpn Exporting L2VPN (identifier) (optional)
     * @param  int[] $exporting_l2vpn__n Exporting L2VPN (identifier) (optional)
     * @param  int[] $exporting_l2vpn_id Exporting L2VPN (optional)
     * @param  int[] $exporting_l2vpn_id__n Exporting L2VPN (optional)
     * @param  string[] $exporting_vrf Export VRF (RD) (optional)
     * @param  string[] $exporting_vrf__n Export VRF (RD) (optional)
     * @param  int[] $exporting_vrf_id Exporting VRF (optional)
     * @param  int[] $exporting_vrf_id__n Exporting VRF (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $importing_l2vpn Importing L2VPN (identifier) (optional)
     * @param  int[] $importing_l2vpn__n Importing L2VPN (identifier) (optional)
     * @param  int[] $importing_l2vpn_id Importing L2VPN (optional)
     * @param  int[] $importing_l2vpn_id__n Importing L2VPN (optional)
     * @param  string[] $importing_vrf Import VRF (RD) (optional)
     * @param  string[] $importing_vrf__n Import VRF (RD) (optional)
     * @param  int[] $importing_vrf_id Importing VRF (optional)
     * @param  int[] $importing_vrf_id__n Importing VRF (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $exporting_l2vpn = null, $exporting_l2vpn__n = null, $exporting_l2vpn_id = null, $exporting_l2vpn_id__n = null, $exporting_vrf = null, $exporting_vrf__n = null, $exporting_vrf_id = null, $exporting_vrf_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $importing_l2vpn = null, $importing_l2vpn__n = null, $importing_l2vpn_id = null, $importing_l2vpn_id__n = null, $importing_vrf = null, $importing_vrf__n = null, $importing_vrf_id = null, $importing_vrf_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamRouteTargetsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedRouteTargetList';
        $request = $this->ipamRouteTargetsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $exporting_l2vpn, $exporting_l2vpn__n, $exporting_l2vpn_id, $exporting_l2vpn_id__n, $exporting_vrf, $exporting_vrf__n, $exporting_vrf_id, $exporting_vrf_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $importing_l2vpn, $importing_l2vpn__n, $importing_l2vpn_id, $importing_l2vpn_id__n, $importing_vrf, $importing_vrf__n, $importing_vrf_id, $importing_vrf_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRouteTargetsList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $exporting_l2vpn Exporting L2VPN (identifier) (optional)
     * @param  int[] $exporting_l2vpn__n Exporting L2VPN (identifier) (optional)
     * @param  int[] $exporting_l2vpn_id Exporting L2VPN (optional)
     * @param  int[] $exporting_l2vpn_id__n Exporting L2VPN (optional)
     * @param  string[] $exporting_vrf Export VRF (RD) (optional)
     * @param  string[] $exporting_vrf__n Export VRF (RD) (optional)
     * @param  int[] $exporting_vrf_id Exporting VRF (optional)
     * @param  int[] $exporting_vrf_id__n Exporting VRF (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $importing_l2vpn Importing L2VPN (identifier) (optional)
     * @param  int[] $importing_l2vpn__n Importing L2VPN (identifier) (optional)
     * @param  int[] $importing_l2vpn_id Importing L2VPN (optional)
     * @param  int[] $importing_l2vpn_id__n Importing L2VPN (optional)
     * @param  string[] $importing_vrf Import VRF (RD) (optional)
     * @param  string[] $importing_vrf__n Import VRF (RD) (optional)
     * @param  int[] $importing_vrf_id Importing VRF (optional)
     * @param  int[] $importing_vrf_id__n Importing VRF (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRouteTargetsListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $exporting_l2vpn = null, $exporting_l2vpn__n = null, $exporting_l2vpn_id = null, $exporting_l2vpn_id__n = null, $exporting_vrf = null, $exporting_vrf__n = null, $exporting_vrf_id = null, $exporting_vrf_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $importing_l2vpn = null, $importing_l2vpn__n = null, $importing_l2vpn_id = null, $importing_l2vpn_id__n = null, $importing_vrf = null, $importing_vrf__n = null, $importing_vrf_id = null, $importing_vrf_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamRouteTargetsList'][0])
    {














































































        $resourcePath = '/api/ipam/route-targets/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exporting_l2vpn,
            'exporting_l2vpn', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exporting_l2vpn__n,
            'exporting_l2vpn__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exporting_l2vpn_id,
            'exporting_l2vpn_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exporting_l2vpn_id__n,
            'exporting_l2vpn_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exporting_vrf,
            'exporting_vrf', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exporting_vrf__n,
            'exporting_vrf__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exporting_vrf_id,
            'exporting_vrf_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exporting_vrf_id__n,
            'exporting_vrf_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $importing_l2vpn,
            'importing_l2vpn', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $importing_l2vpn__n,
            'importing_l2vpn__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $importing_l2vpn_id,
            'importing_l2vpn_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $importing_l2vpn_id__n,
            'importing_l2vpn_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $importing_vrf,
            'importing_vrf', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $importing_vrf__n,
            'importing_vrf__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $importing_vrf_id,
            'importing_vrf_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $importing_vrf_id__n,
            'importing_vrf_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRouteTargetsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  \OpenAPI\Client\Model\PatchedRouteTargetRequest $patched_route_target_request patched_route_target_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RouteTarget
     */
    public function ipamRouteTargetsPartialUpdate($id, $patched_route_target_request = null, string $contentType = self::contentTypes['ipamRouteTargetsPartialUpdate'][0])
    {
        list($response) = $this->ipamRouteTargetsPartialUpdateWithHttpInfo($id, $patched_route_target_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRouteTargetsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  \OpenAPI\Client\Model\PatchedRouteTargetRequest $patched_route_target_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RouteTarget, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRouteTargetsPartialUpdateWithHttpInfo($id, $patched_route_target_request = null, string $contentType = self::contentTypes['ipamRouteTargetsPartialUpdate'][0])
    {
        $request = $this->ipamRouteTargetsPartialUpdateRequest($id, $patched_route_target_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RouteTarget' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RouteTarget' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RouteTarget', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RouteTarget';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RouteTarget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRouteTargetsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  \OpenAPI\Client\Model\PatchedRouteTargetRequest $patched_route_target_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsPartialUpdateAsync($id, $patched_route_target_request = null, string $contentType = self::contentTypes['ipamRouteTargetsPartialUpdate'][0])
    {
        return $this->ipamRouteTargetsPartialUpdateAsyncWithHttpInfo($id, $patched_route_target_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRouteTargetsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  \OpenAPI\Client\Model\PatchedRouteTargetRequest $patched_route_target_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsPartialUpdateAsyncWithHttpInfo($id, $patched_route_target_request = null, string $contentType = self::contentTypes['ipamRouteTargetsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RouteTarget';
        $request = $this->ipamRouteTargetsPartialUpdateRequest($id, $patched_route_target_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRouteTargetsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  \OpenAPI\Client\Model\PatchedRouteTargetRequest $patched_route_target_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRouteTargetsPartialUpdateRequest($id, $patched_route_target_request = null, string $contentType = self::contentTypes['ipamRouteTargetsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRouteTargetsPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/route-targets/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_route_target_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_route_target_request));
            } else {
                $httpBody = $patched_route_target_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRouteTargetsRetrieve
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RouteTarget
     */
    public function ipamRouteTargetsRetrieve($id, string $contentType = self::contentTypes['ipamRouteTargetsRetrieve'][0])
    {
        list($response) = $this->ipamRouteTargetsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamRouteTargetsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RouteTarget, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRouteTargetsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamRouteTargetsRetrieve'][0])
    {
        $request = $this->ipamRouteTargetsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RouteTarget' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RouteTarget' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RouteTarget', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RouteTarget';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RouteTarget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRouteTargetsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsRetrieveAsync($id, string $contentType = self::contentTypes['ipamRouteTargetsRetrieve'][0])
    {
        return $this->ipamRouteTargetsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRouteTargetsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamRouteTargetsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RouteTarget';
        $request = $this->ipamRouteTargetsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRouteTargetsRetrieve'
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRouteTargetsRetrieveRequest($id, string $contentType = self::contentTypes['ipamRouteTargetsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRouteTargetsRetrieve'
            );
        }


        $resourcePath = '/api/ipam/route-targets/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamRouteTargetsUpdate
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  \OpenAPI\Client\Model\RouteTargetRequest $route_target_request route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RouteTarget
     */
    public function ipamRouteTargetsUpdate($id, $route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsUpdate'][0])
    {
        list($response) = $this->ipamRouteTargetsUpdateWithHttpInfo($id, $route_target_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamRouteTargetsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  \OpenAPI\Client\Model\RouteTargetRequest $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RouteTarget, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamRouteTargetsUpdateWithHttpInfo($id, $route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsUpdate'][0])
    {
        $request = $this->ipamRouteTargetsUpdateRequest($id, $route_target_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RouteTarget' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RouteTarget' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RouteTarget', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RouteTarget';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RouteTarget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamRouteTargetsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  \OpenAPI\Client\Model\RouteTargetRequest $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsUpdateAsync($id, $route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsUpdate'][0])
    {
        return $this->ipamRouteTargetsUpdateAsyncWithHttpInfo($id, $route_target_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamRouteTargetsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  \OpenAPI\Client\Model\RouteTargetRequest $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamRouteTargetsUpdateAsyncWithHttpInfo($id, $route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RouteTarget';
        $request = $this->ipamRouteTargetsUpdateRequest($id, $route_target_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamRouteTargetsUpdate'
     *
     * @param  int $id A unique integer value identifying this route target. (required)
     * @param  \OpenAPI\Client\Model\RouteTargetRequest $route_target_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamRouteTargetsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamRouteTargetsUpdateRequest($id, $route_target_request, string $contentType = self::contentTypes['ipamRouteTargetsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamRouteTargetsUpdate'
            );
        }

        // verify the required parameter 'route_target_request' is set
        if ($route_target_request === null || (is_array($route_target_request) && count($route_target_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $route_target_request when calling ipamRouteTargetsUpdate'
            );
        }


        $resourcePath = '/api/ipam/route-targets/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($route_target_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($route_target_request));
            } else {
                $httpBody = $route_target_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServiceTemplatesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamServiceTemplatesBulkDestroy($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkDestroy'][0])
    {
        $this->ipamServiceTemplatesBulkDestroyWithHttpInfo($service_template_request, $contentType);
    }

    /**
     * Operation ipamServiceTemplatesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServiceTemplatesBulkDestroyWithHttpInfo($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkDestroy'][0])
    {
        $request = $this->ipamServiceTemplatesBulkDestroyRequest($service_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServiceTemplatesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesBulkDestroyAsync($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkDestroy'][0])
    {
        return $this->ipamServiceTemplatesBulkDestroyAsyncWithHttpInfo($service_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServiceTemplatesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesBulkDestroyAsyncWithHttpInfo($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamServiceTemplatesBulkDestroyRequest($service_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServiceTemplatesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServiceTemplatesBulkDestroyRequest($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkDestroy'][0])
    {

        // verify the required parameter 'service_template_request' is set
        if ($service_template_request === null || (is_array($service_template_request) && count($service_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_template_request when calling ipamServiceTemplatesBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/service-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($service_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($service_template_request));
            } else {
                $httpBody = $service_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServiceTemplatesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServiceTemplate[]
     */
    public function ipamServiceTemplatesBulkPartialUpdate($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamServiceTemplatesBulkPartialUpdateWithHttpInfo($service_template_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamServiceTemplatesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServiceTemplate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServiceTemplatesBulkPartialUpdateWithHttpInfo($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkPartialUpdate'][0])
    {
        $request = $this->ipamServiceTemplatesBulkPartialUpdateRequest($service_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ServiceTemplate[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ServiceTemplate[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ServiceTemplate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ServiceTemplate[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServiceTemplate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServiceTemplatesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesBulkPartialUpdateAsync($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkPartialUpdate'][0])
    {
        return $this->ipamServiceTemplatesBulkPartialUpdateAsyncWithHttpInfo($service_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServiceTemplatesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesBulkPartialUpdateAsyncWithHttpInfo($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServiceTemplate[]';
        $request = $this->ipamServiceTemplatesBulkPartialUpdateRequest($service_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServiceTemplatesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServiceTemplatesBulkPartialUpdateRequest($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'service_template_request' is set
        if ($service_template_request === null || (is_array($service_template_request) && count($service_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_template_request when calling ipamServiceTemplatesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/service-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($service_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($service_template_request));
            } else {
                $httpBody = $service_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServiceTemplatesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServiceTemplate[]
     */
    public function ipamServiceTemplatesBulkUpdate($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkUpdate'][0])
    {
        list($response) = $this->ipamServiceTemplatesBulkUpdateWithHttpInfo($service_template_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamServiceTemplatesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServiceTemplate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServiceTemplatesBulkUpdateWithHttpInfo($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkUpdate'][0])
    {
        $request = $this->ipamServiceTemplatesBulkUpdateRequest($service_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ServiceTemplate[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ServiceTemplate[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ServiceTemplate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ServiceTemplate[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServiceTemplate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServiceTemplatesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesBulkUpdateAsync($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkUpdate'][0])
    {
        return $this->ipamServiceTemplatesBulkUpdateAsyncWithHttpInfo($service_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServiceTemplatesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesBulkUpdateAsyncWithHttpInfo($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServiceTemplate[]';
        $request = $this->ipamServiceTemplatesBulkUpdateRequest($service_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServiceTemplatesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ServiceTemplateRequest[] $service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServiceTemplatesBulkUpdateRequest($service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesBulkUpdate'][0])
    {

        // verify the required parameter 'service_template_request' is set
        if ($service_template_request === null || (is_array($service_template_request) && count($service_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_template_request when calling ipamServiceTemplatesBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/service-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($service_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($service_template_request));
            } else {
                $httpBody = $service_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServiceTemplatesCreate
     *
     * @param  \OpenAPI\Client\Model\WritableServiceTemplateRequest $writable_service_template_request writable_service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServiceTemplate
     */
    public function ipamServiceTemplatesCreate($writable_service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesCreate'][0])
    {
        list($response) = $this->ipamServiceTemplatesCreateWithHttpInfo($writable_service_template_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamServiceTemplatesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableServiceTemplateRequest $writable_service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServiceTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServiceTemplatesCreateWithHttpInfo($writable_service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesCreate'][0])
    {
        $request = $this->ipamServiceTemplatesCreateRequest($writable_service_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ServiceTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ServiceTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ServiceTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ServiceTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServiceTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServiceTemplatesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableServiceTemplateRequest $writable_service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesCreateAsync($writable_service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesCreate'][0])
    {
        return $this->ipamServiceTemplatesCreateAsyncWithHttpInfo($writable_service_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServiceTemplatesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableServiceTemplateRequest $writable_service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesCreateAsyncWithHttpInfo($writable_service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServiceTemplate';
        $request = $this->ipamServiceTemplatesCreateRequest($writable_service_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServiceTemplatesCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableServiceTemplateRequest $writable_service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServiceTemplatesCreateRequest($writable_service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesCreate'][0])
    {

        // verify the required parameter 'writable_service_template_request' is set
        if ($writable_service_template_request === null || (is_array($writable_service_template_request) && count($writable_service_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_service_template_request when calling ipamServiceTemplatesCreate'
            );
        }


        $resourcePath = '/api/ipam/service-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_service_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_service_template_request));
            } else {
                $httpBody = $writable_service_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServiceTemplatesDestroy
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamServiceTemplatesDestroy($id, string $contentType = self::contentTypes['ipamServiceTemplatesDestroy'][0])
    {
        $this->ipamServiceTemplatesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamServiceTemplatesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServiceTemplatesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamServiceTemplatesDestroy'][0])
    {
        $request = $this->ipamServiceTemplatesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServiceTemplatesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesDestroyAsync($id, string $contentType = self::contentTypes['ipamServiceTemplatesDestroy'][0])
    {
        return $this->ipamServiceTemplatesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServiceTemplatesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamServiceTemplatesDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamServiceTemplatesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServiceTemplatesDestroy'
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServiceTemplatesDestroyRequest($id, string $contentType = self::contentTypes['ipamServiceTemplatesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamServiceTemplatesDestroy'
            );
        }


        $resourcePath = '/api/ipam/service-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServiceTemplatesList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  float $port port (optional)
     * @param  string $protocol * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $protocol__n * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedServiceTemplateList
     */
    public function ipamServiceTemplatesList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $port = null, $protocol = null, $protocol__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamServiceTemplatesList'][0])
    {
        list($response) = $this->ipamServiceTemplatesListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $port, $protocol, $protocol__n, $q, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamServiceTemplatesListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  float $port (optional)
     * @param  string $protocol * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $protocol__n * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedServiceTemplateList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServiceTemplatesListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $port = null, $protocol = null, $protocol__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamServiceTemplatesList'][0])
    {
        $request = $this->ipamServiceTemplatesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $port, $protocol, $protocol__n, $q, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedServiceTemplateList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedServiceTemplateList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedServiceTemplateList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedServiceTemplateList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedServiceTemplateList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServiceTemplatesListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  float $port (optional)
     * @param  string $protocol * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $protocol__n * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $port = null, $protocol = null, $protocol__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamServiceTemplatesList'][0])
    {
        return $this->ipamServiceTemplatesListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $port, $protocol, $protocol__n, $q, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServiceTemplatesListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  float $port (optional)
     * @param  string $protocol * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $protocol__n * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $port = null, $protocol = null, $protocol__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamServiceTemplatesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedServiceTemplateList';
        $request = $this->ipamServiceTemplatesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $port, $protocol, $protocol__n, $q, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServiceTemplatesList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  float $port (optional)
     * @param  string $protocol * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $protocol__n * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServiceTemplatesListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $port = null, $protocol = null, $protocol__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamServiceTemplatesList'][0])
    {

























































        $resourcePath = '/api/ipam/service-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $port,
            'port', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $protocol,
            'protocol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $protocol__n,
            'protocol__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServiceTemplatesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableServiceTemplateRequest $patched_writable_service_template_request patched_writable_service_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServiceTemplate
     */
    public function ipamServiceTemplatesPartialUpdate($id, $patched_writable_service_template_request = null, string $contentType = self::contentTypes['ipamServiceTemplatesPartialUpdate'][0])
    {
        list($response) = $this->ipamServiceTemplatesPartialUpdateWithHttpInfo($id, $patched_writable_service_template_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamServiceTemplatesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableServiceTemplateRequest $patched_writable_service_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServiceTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServiceTemplatesPartialUpdateWithHttpInfo($id, $patched_writable_service_template_request = null, string $contentType = self::contentTypes['ipamServiceTemplatesPartialUpdate'][0])
    {
        $request = $this->ipamServiceTemplatesPartialUpdateRequest($id, $patched_writable_service_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ServiceTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ServiceTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ServiceTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ServiceTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServiceTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServiceTemplatesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableServiceTemplateRequest $patched_writable_service_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesPartialUpdateAsync($id, $patched_writable_service_template_request = null, string $contentType = self::contentTypes['ipamServiceTemplatesPartialUpdate'][0])
    {
        return $this->ipamServiceTemplatesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_service_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServiceTemplatesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableServiceTemplateRequest $patched_writable_service_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_service_template_request = null, string $contentType = self::contentTypes['ipamServiceTemplatesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServiceTemplate';
        $request = $this->ipamServiceTemplatesPartialUpdateRequest($id, $patched_writable_service_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServiceTemplatesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableServiceTemplateRequest $patched_writable_service_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServiceTemplatesPartialUpdateRequest($id, $patched_writable_service_template_request = null, string $contentType = self::contentTypes['ipamServiceTemplatesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamServiceTemplatesPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/service-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_service_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_service_template_request));
            } else {
                $httpBody = $patched_writable_service_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServiceTemplatesRetrieve
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServiceTemplate
     */
    public function ipamServiceTemplatesRetrieve($id, string $contentType = self::contentTypes['ipamServiceTemplatesRetrieve'][0])
    {
        list($response) = $this->ipamServiceTemplatesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamServiceTemplatesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServiceTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServiceTemplatesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamServiceTemplatesRetrieve'][0])
    {
        $request = $this->ipamServiceTemplatesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ServiceTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ServiceTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ServiceTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ServiceTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServiceTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServiceTemplatesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesRetrieveAsync($id, string $contentType = self::contentTypes['ipamServiceTemplatesRetrieve'][0])
    {
        return $this->ipamServiceTemplatesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServiceTemplatesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamServiceTemplatesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServiceTemplate';
        $request = $this->ipamServiceTemplatesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServiceTemplatesRetrieve'
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServiceTemplatesRetrieveRequest($id, string $contentType = self::contentTypes['ipamServiceTemplatesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamServiceTemplatesRetrieve'
            );
        }


        $resourcePath = '/api/ipam/service-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServiceTemplatesUpdate
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  \OpenAPI\Client\Model\WritableServiceTemplateRequest $writable_service_template_request writable_service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServiceTemplate
     */
    public function ipamServiceTemplatesUpdate($id, $writable_service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesUpdate'][0])
    {
        list($response) = $this->ipamServiceTemplatesUpdateWithHttpInfo($id, $writable_service_template_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamServiceTemplatesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  \OpenAPI\Client\Model\WritableServiceTemplateRequest $writable_service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServiceTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServiceTemplatesUpdateWithHttpInfo($id, $writable_service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesUpdate'][0])
    {
        $request = $this->ipamServiceTemplatesUpdateRequest($id, $writable_service_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ServiceTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ServiceTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ServiceTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ServiceTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServiceTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServiceTemplatesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  \OpenAPI\Client\Model\WritableServiceTemplateRequest $writable_service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesUpdateAsync($id, $writable_service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesUpdate'][0])
    {
        return $this->ipamServiceTemplatesUpdateAsyncWithHttpInfo($id, $writable_service_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServiceTemplatesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  \OpenAPI\Client\Model\WritableServiceTemplateRequest $writable_service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServiceTemplatesUpdateAsyncWithHttpInfo($id, $writable_service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServiceTemplate';
        $request = $this->ipamServiceTemplatesUpdateRequest($id, $writable_service_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServiceTemplatesUpdate'
     *
     * @param  int $id A unique integer value identifying this service template. (required)
     * @param  \OpenAPI\Client\Model\WritableServiceTemplateRequest $writable_service_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServiceTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServiceTemplatesUpdateRequest($id, $writable_service_template_request, string $contentType = self::contentTypes['ipamServiceTemplatesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamServiceTemplatesUpdate'
            );
        }

        // verify the required parameter 'writable_service_template_request' is set
        if ($writable_service_template_request === null || (is_array($writable_service_template_request) && count($writable_service_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_service_template_request when calling ipamServiceTemplatesUpdate'
            );
        }


        $resourcePath = '/api/ipam/service-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_service_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_service_template_request));
            } else {
                $httpBody = $writable_service_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServicesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamServicesBulkDestroy($service_request, string $contentType = self::contentTypes['ipamServicesBulkDestroy'][0])
    {
        $this->ipamServicesBulkDestroyWithHttpInfo($service_request, $contentType);
    }

    /**
     * Operation ipamServicesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServicesBulkDestroyWithHttpInfo($service_request, string $contentType = self::contentTypes['ipamServicesBulkDestroy'][0])
    {
        $request = $this->ipamServicesBulkDestroyRequest($service_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServicesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesBulkDestroyAsync($service_request, string $contentType = self::contentTypes['ipamServicesBulkDestroy'][0])
    {
        return $this->ipamServicesBulkDestroyAsyncWithHttpInfo($service_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServicesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesBulkDestroyAsyncWithHttpInfo($service_request, string $contentType = self::contentTypes['ipamServicesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamServicesBulkDestroyRequest($service_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServicesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServicesBulkDestroyRequest($service_request, string $contentType = self::contentTypes['ipamServicesBulkDestroy'][0])
    {

        // verify the required parameter 'service_request' is set
        if ($service_request === null || (is_array($service_request) && count($service_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_request when calling ipamServicesBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/services/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($service_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($service_request));
            } else {
                $httpBody = $service_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServicesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Service[]
     */
    public function ipamServicesBulkPartialUpdate($service_request, string $contentType = self::contentTypes['ipamServicesBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamServicesBulkPartialUpdateWithHttpInfo($service_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamServicesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Service[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServicesBulkPartialUpdateWithHttpInfo($service_request, string $contentType = self::contentTypes['ipamServicesBulkPartialUpdate'][0])
    {
        $request = $this->ipamServicesBulkPartialUpdateRequest($service_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Service[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Service[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Service[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Service[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Service[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServicesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesBulkPartialUpdateAsync($service_request, string $contentType = self::contentTypes['ipamServicesBulkPartialUpdate'][0])
    {
        return $this->ipamServicesBulkPartialUpdateAsyncWithHttpInfo($service_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServicesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesBulkPartialUpdateAsyncWithHttpInfo($service_request, string $contentType = self::contentTypes['ipamServicesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Service[]';
        $request = $this->ipamServicesBulkPartialUpdateRequest($service_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServicesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServicesBulkPartialUpdateRequest($service_request, string $contentType = self::contentTypes['ipamServicesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'service_request' is set
        if ($service_request === null || (is_array($service_request) && count($service_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_request when calling ipamServicesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/services/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($service_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($service_request));
            } else {
                $httpBody = $service_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServicesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Service[]
     */
    public function ipamServicesBulkUpdate($service_request, string $contentType = self::contentTypes['ipamServicesBulkUpdate'][0])
    {
        list($response) = $this->ipamServicesBulkUpdateWithHttpInfo($service_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamServicesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Service[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServicesBulkUpdateWithHttpInfo($service_request, string $contentType = self::contentTypes['ipamServicesBulkUpdate'][0])
    {
        $request = $this->ipamServicesBulkUpdateRequest($service_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Service[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Service[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Service[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Service[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Service[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServicesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesBulkUpdateAsync($service_request, string $contentType = self::contentTypes['ipamServicesBulkUpdate'][0])
    {
        return $this->ipamServicesBulkUpdateAsyncWithHttpInfo($service_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServicesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesBulkUpdateAsyncWithHttpInfo($service_request, string $contentType = self::contentTypes['ipamServicesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Service[]';
        $request = $this->ipamServicesBulkUpdateRequest($service_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServicesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ServiceRequest[] $service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServicesBulkUpdateRequest($service_request, string $contentType = self::contentTypes['ipamServicesBulkUpdate'][0])
    {

        // verify the required parameter 'service_request' is set
        if ($service_request === null || (is_array($service_request) && count($service_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_request when calling ipamServicesBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/services/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($service_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($service_request));
            } else {
                $httpBody = $service_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServicesCreate
     *
     * @param  \OpenAPI\Client\Model\WritableServiceRequest $writable_service_request writable_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Service
     */
    public function ipamServicesCreate($writable_service_request, string $contentType = self::contentTypes['ipamServicesCreate'][0])
    {
        list($response) = $this->ipamServicesCreateWithHttpInfo($writable_service_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamServicesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableServiceRequest $writable_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServicesCreateWithHttpInfo($writable_service_request, string $contentType = self::contentTypes['ipamServicesCreate'][0])
    {
        $request = $this->ipamServicesCreateRequest($writable_service_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Service' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Service' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Service', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Service';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Service',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServicesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableServiceRequest $writable_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesCreateAsync($writable_service_request, string $contentType = self::contentTypes['ipamServicesCreate'][0])
    {
        return $this->ipamServicesCreateAsyncWithHttpInfo($writable_service_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServicesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableServiceRequest $writable_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesCreateAsyncWithHttpInfo($writable_service_request, string $contentType = self::contentTypes['ipamServicesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Service';
        $request = $this->ipamServicesCreateRequest($writable_service_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServicesCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableServiceRequest $writable_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServicesCreateRequest($writable_service_request, string $contentType = self::contentTypes['ipamServicesCreate'][0])
    {

        // verify the required parameter 'writable_service_request' is set
        if ($writable_service_request === null || (is_array($writable_service_request) && count($writable_service_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_service_request when calling ipamServicesCreate'
            );
        }


        $resourcePath = '/api/ipam/services/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_service_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_service_request));
            } else {
                $httpBody = $writable_service_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServicesDestroy
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamServicesDestroy($id, string $contentType = self::contentTypes['ipamServicesDestroy'][0])
    {
        $this->ipamServicesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamServicesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServicesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamServicesDestroy'][0])
    {
        $request = $this->ipamServicesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServicesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesDestroyAsync($id, string $contentType = self::contentTypes['ipamServicesDestroy'][0])
    {
        return $this->ipamServicesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServicesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamServicesDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamServicesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServicesDestroy'
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServicesDestroyRequest($id, string $contentType = self::contentTypes['ipamServicesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamServicesDestroy'
            );
        }


        $resourcePath = '/api/ipam/services/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServicesList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $device Device (name) (optional)
     * @param  string[] $device__n Device (name) (optional)
     * @param  int[] $device_id Device (ID) (optional)
     * @param  int[] $device_id__n Device (ID) (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $ip_address IP address (optional)
     * @param  string[] $ip_address__n IP address (optional)
     * @param  int[] $ip_address_id IP address (ID) (optional)
     * @param  int[] $ip_address_id__n IP address (ID) (optional)
     * @param  string[] $ipaddress IP address (optional)
     * @param  string[] $ipaddress__n IP address (optional)
     * @param  int[] $ipaddress_id IP address (ID) (optional)
     * @param  int[] $ipaddress_id__n IP address (ID) (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  float $port port (optional)
     * @param  string $protocol * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $protocol__n * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string[] $virtual_machine Virtual machine (name) (optional)
     * @param  string[] $virtual_machine__n Virtual machine (name) (optional)
     * @param  int[] $virtual_machine_id Virtual machine (ID) (optional)
     * @param  int[] $virtual_machine_id__n Virtual machine (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedServiceList
     */
    public function ipamServicesList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device = null, $device__n = null, $device_id = null, $device_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ip_address = null, $ip_address__n = null, $ip_address_id = null, $ip_address_id__n = null, $ipaddress = null, $ipaddress__n = null, $ipaddress_id = null, $ipaddress_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $port = null, $protocol = null, $protocol__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine__n = null, $virtual_machine_id = null, $virtual_machine_id__n = null, string $contentType = self::contentTypes['ipamServicesList'][0])
    {
        list($response) = $this->ipamServicesListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device, $device__n, $device_id, $device_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ip_address, $ip_address__n, $ip_address_id, $ip_address_id__n, $ipaddress, $ipaddress__n, $ipaddress_id, $ipaddress_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $port, $protocol, $protocol__n, $q, $tag, $tag__n, $updated_by_request, $virtual_machine, $virtual_machine__n, $virtual_machine_id, $virtual_machine_id__n, $contentType);
        return $response;
    }

    /**
     * Operation ipamServicesListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device Device (name) (optional)
     * @param  string[] $device__n Device (name) (optional)
     * @param  int[] $device_id Device (ID) (optional)
     * @param  int[] $device_id__n Device (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ip_address IP address (optional)
     * @param  string[] $ip_address__n IP address (optional)
     * @param  int[] $ip_address_id IP address (ID) (optional)
     * @param  int[] $ip_address_id__n IP address (ID) (optional)
     * @param  string[] $ipaddress IP address (optional)
     * @param  string[] $ipaddress__n IP address (optional)
     * @param  int[] $ipaddress_id IP address (ID) (optional)
     * @param  int[] $ipaddress_id__n IP address (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  float $port (optional)
     * @param  string $protocol * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $protocol__n * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine Virtual machine (name) (optional)
     * @param  string[] $virtual_machine__n Virtual machine (name) (optional)
     * @param  int[] $virtual_machine_id Virtual machine (ID) (optional)
     * @param  int[] $virtual_machine_id__n Virtual machine (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedServiceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServicesListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device = null, $device__n = null, $device_id = null, $device_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ip_address = null, $ip_address__n = null, $ip_address_id = null, $ip_address_id__n = null, $ipaddress = null, $ipaddress__n = null, $ipaddress_id = null, $ipaddress_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $port = null, $protocol = null, $protocol__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine__n = null, $virtual_machine_id = null, $virtual_machine_id__n = null, string $contentType = self::contentTypes['ipamServicesList'][0])
    {
        $request = $this->ipamServicesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device, $device__n, $device_id, $device_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ip_address, $ip_address__n, $ip_address_id, $ip_address_id__n, $ipaddress, $ipaddress__n, $ipaddress_id, $ipaddress_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $port, $protocol, $protocol__n, $q, $tag, $tag__n, $updated_by_request, $virtual_machine, $virtual_machine__n, $virtual_machine_id, $virtual_machine_id__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedServiceList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedServiceList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedServiceList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedServiceList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedServiceList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServicesListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device Device (name) (optional)
     * @param  string[] $device__n Device (name) (optional)
     * @param  int[] $device_id Device (ID) (optional)
     * @param  int[] $device_id__n Device (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ip_address IP address (optional)
     * @param  string[] $ip_address__n IP address (optional)
     * @param  int[] $ip_address_id IP address (ID) (optional)
     * @param  int[] $ip_address_id__n IP address (ID) (optional)
     * @param  string[] $ipaddress IP address (optional)
     * @param  string[] $ipaddress__n IP address (optional)
     * @param  int[] $ipaddress_id IP address (ID) (optional)
     * @param  int[] $ipaddress_id__n IP address (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  float $port (optional)
     * @param  string $protocol * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $protocol__n * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine Virtual machine (name) (optional)
     * @param  string[] $virtual_machine__n Virtual machine (name) (optional)
     * @param  int[] $virtual_machine_id Virtual machine (ID) (optional)
     * @param  int[] $virtual_machine_id__n Virtual machine (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device = null, $device__n = null, $device_id = null, $device_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ip_address = null, $ip_address__n = null, $ip_address_id = null, $ip_address_id__n = null, $ipaddress = null, $ipaddress__n = null, $ipaddress_id = null, $ipaddress_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $port = null, $protocol = null, $protocol__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine__n = null, $virtual_machine_id = null, $virtual_machine_id__n = null, string $contentType = self::contentTypes['ipamServicesList'][0])
    {
        return $this->ipamServicesListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device, $device__n, $device_id, $device_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ip_address, $ip_address__n, $ip_address_id, $ip_address_id__n, $ipaddress, $ipaddress__n, $ipaddress_id, $ipaddress_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $port, $protocol, $protocol__n, $q, $tag, $tag__n, $updated_by_request, $virtual_machine, $virtual_machine__n, $virtual_machine_id, $virtual_machine_id__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServicesListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device Device (name) (optional)
     * @param  string[] $device__n Device (name) (optional)
     * @param  int[] $device_id Device (ID) (optional)
     * @param  int[] $device_id__n Device (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ip_address IP address (optional)
     * @param  string[] $ip_address__n IP address (optional)
     * @param  int[] $ip_address_id IP address (ID) (optional)
     * @param  int[] $ip_address_id__n IP address (ID) (optional)
     * @param  string[] $ipaddress IP address (optional)
     * @param  string[] $ipaddress__n IP address (optional)
     * @param  int[] $ipaddress_id IP address (ID) (optional)
     * @param  int[] $ipaddress_id__n IP address (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  float $port (optional)
     * @param  string $protocol * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $protocol__n * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine Virtual machine (name) (optional)
     * @param  string[] $virtual_machine__n Virtual machine (name) (optional)
     * @param  int[] $virtual_machine_id Virtual machine (ID) (optional)
     * @param  int[] $virtual_machine_id__n Virtual machine (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device = null, $device__n = null, $device_id = null, $device_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ip_address = null, $ip_address__n = null, $ip_address_id = null, $ip_address_id__n = null, $ipaddress = null, $ipaddress__n = null, $ipaddress_id = null, $ipaddress_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $port = null, $protocol = null, $protocol__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine__n = null, $virtual_machine_id = null, $virtual_machine_id__n = null, string $contentType = self::contentTypes['ipamServicesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedServiceList';
        $request = $this->ipamServicesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device, $device__n, $device_id, $device_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ip_address, $ip_address__n, $ip_address_id, $ip_address_id__n, $ipaddress, $ipaddress__n, $ipaddress_id, $ipaddress_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $port, $protocol, $protocol__n, $q, $tag, $tag__n, $updated_by_request, $virtual_machine, $virtual_machine__n, $virtual_machine_id, $virtual_machine_id__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServicesList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device Device (name) (optional)
     * @param  string[] $device__n Device (name) (optional)
     * @param  int[] $device_id Device (ID) (optional)
     * @param  int[] $device_id__n Device (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ip_address IP address (optional)
     * @param  string[] $ip_address__n IP address (optional)
     * @param  int[] $ip_address_id IP address (ID) (optional)
     * @param  int[] $ip_address_id__n IP address (ID) (optional)
     * @param  string[] $ipaddress IP address (optional)
     * @param  string[] $ipaddress__n IP address (optional)
     * @param  int[] $ipaddress_id IP address (ID) (optional)
     * @param  int[] $ipaddress_id__n IP address (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  float $port (optional)
     * @param  string $protocol * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $protocol__n * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine Virtual machine (name) (optional)
     * @param  string[] $virtual_machine__n Virtual machine (name) (optional)
     * @param  int[] $virtual_machine_id Virtual machine (ID) (optional)
     * @param  int[] $virtual_machine_id__n Virtual machine (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServicesListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device = null, $device__n = null, $device_id = null, $device_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ip_address = null, $ip_address__n = null, $ip_address_id = null, $ip_address_id__n = null, $ipaddress = null, $ipaddress__n = null, $ipaddress_id = null, $ipaddress_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $port = null, $protocol = null, $protocol__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine__n = null, $virtual_machine_id = null, $virtual_machine_id__n = null, string $contentType = self::contentTypes['ipamServicesList'][0])
    {









































































        $resourcePath = '/api/ipam/services/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device,
            'device', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device__n,
            'device__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'device_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id__n,
            'device_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip_address,
            'ip_address', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip_address__n,
            'ip_address__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip_address_id,
            'ip_address_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip_address_id__n,
            'ip_address_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipaddress,
            'ipaddress', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipaddress__n,
            'ipaddress__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipaddress_id,
            'ipaddress_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipaddress_id__n,
            'ipaddress_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $port,
            'port', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $protocol,
            'protocol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $protocol__n,
            'protocol__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine,
            'virtual_machine', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine__n,
            'virtual_machine__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine_id,
            'virtual_machine_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine_id__n,
            'virtual_machine_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServicesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableServiceRequest $patched_writable_service_request patched_writable_service_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Service
     */
    public function ipamServicesPartialUpdate($id, $patched_writable_service_request = null, string $contentType = self::contentTypes['ipamServicesPartialUpdate'][0])
    {
        list($response) = $this->ipamServicesPartialUpdateWithHttpInfo($id, $patched_writable_service_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamServicesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableServiceRequest $patched_writable_service_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServicesPartialUpdateWithHttpInfo($id, $patched_writable_service_request = null, string $contentType = self::contentTypes['ipamServicesPartialUpdate'][0])
    {
        $request = $this->ipamServicesPartialUpdateRequest($id, $patched_writable_service_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Service' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Service' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Service', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Service';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Service',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServicesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableServiceRequest $patched_writable_service_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesPartialUpdateAsync($id, $patched_writable_service_request = null, string $contentType = self::contentTypes['ipamServicesPartialUpdate'][0])
    {
        return $this->ipamServicesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_service_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServicesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableServiceRequest $patched_writable_service_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_service_request = null, string $contentType = self::contentTypes['ipamServicesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Service';
        $request = $this->ipamServicesPartialUpdateRequest($id, $patched_writable_service_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServicesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableServiceRequest $patched_writable_service_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServicesPartialUpdateRequest($id, $patched_writable_service_request = null, string $contentType = self::contentTypes['ipamServicesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamServicesPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/services/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_service_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_service_request));
            } else {
                $httpBody = $patched_writable_service_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServicesRetrieve
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Service
     */
    public function ipamServicesRetrieve($id, string $contentType = self::contentTypes['ipamServicesRetrieve'][0])
    {
        list($response) = $this->ipamServicesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamServicesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServicesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamServicesRetrieve'][0])
    {
        $request = $this->ipamServicesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Service' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Service' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Service', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Service';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Service',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServicesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesRetrieveAsync($id, string $contentType = self::contentTypes['ipamServicesRetrieve'][0])
    {
        return $this->ipamServicesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServicesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamServicesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Service';
        $request = $this->ipamServicesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServicesRetrieve'
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServicesRetrieveRequest($id, string $contentType = self::contentTypes['ipamServicesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamServicesRetrieve'
            );
        }


        $resourcePath = '/api/ipam/services/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamServicesUpdate
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  \OpenAPI\Client\Model\WritableServiceRequest $writable_service_request writable_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Service
     */
    public function ipamServicesUpdate($id, $writable_service_request, string $contentType = self::contentTypes['ipamServicesUpdate'][0])
    {
        list($response) = $this->ipamServicesUpdateWithHttpInfo($id, $writable_service_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamServicesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  \OpenAPI\Client\Model\WritableServiceRequest $writable_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Service, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamServicesUpdateWithHttpInfo($id, $writable_service_request, string $contentType = self::contentTypes['ipamServicesUpdate'][0])
    {
        $request = $this->ipamServicesUpdateRequest($id, $writable_service_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Service' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Service' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Service', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Service';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Service',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamServicesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  \OpenAPI\Client\Model\WritableServiceRequest $writable_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesUpdateAsync($id, $writable_service_request, string $contentType = self::contentTypes['ipamServicesUpdate'][0])
    {
        return $this->ipamServicesUpdateAsyncWithHttpInfo($id, $writable_service_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamServicesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  \OpenAPI\Client\Model\WritableServiceRequest $writable_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamServicesUpdateAsyncWithHttpInfo($id, $writable_service_request, string $contentType = self::contentTypes['ipamServicesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Service';
        $request = $this->ipamServicesUpdateRequest($id, $writable_service_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamServicesUpdate'
     *
     * @param  int $id A unique integer value identifying this service. (required)
     * @param  \OpenAPI\Client\Model\WritableServiceRequest $writable_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamServicesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamServicesUpdateRequest($id, $writable_service_request, string $contentType = self::contentTypes['ipamServicesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamServicesUpdate'
            );
        }

        // verify the required parameter 'writable_service_request' is set
        if ($writable_service_request === null || (is_array($writable_service_request) && count($writable_service_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_service_request when calling ipamServicesUpdate'
            );
        }


        $resourcePath = '/api/ipam/services/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_service_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_service_request));
            } else {
                $httpBody = $writable_service_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlanGroupsAvailableVlansCreate
     *
     * @param  int $id id (required)
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsAvailableVlansCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLAN[]
     */
    public function ipamVlanGroupsAvailableVlansCreate($id, $vlan_request, string $contentType = self::contentTypes['ipamVlanGroupsAvailableVlansCreate'][0])
    {
        list($response) = $this->ipamVlanGroupsAvailableVlansCreateWithHttpInfo($id, $vlan_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlanGroupsAvailableVlansCreateWithHttpInfo
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsAvailableVlansCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLAN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlanGroupsAvailableVlansCreateWithHttpInfo($id, $vlan_request, string $contentType = self::contentTypes['ipamVlanGroupsAvailableVlansCreate'][0])
    {
        $request = $this->ipamVlanGroupsAvailableVlansCreateRequest($id, $vlan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\VLAN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLAN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLAN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLAN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLAN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlanGroupsAvailableVlansCreateAsync
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsAvailableVlansCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsAvailableVlansCreateAsync($id, $vlan_request, string $contentType = self::contentTypes['ipamVlanGroupsAvailableVlansCreate'][0])
    {
        return $this->ipamVlanGroupsAvailableVlansCreateAsyncWithHttpInfo($id, $vlan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlanGroupsAvailableVlansCreateAsyncWithHttpInfo
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsAvailableVlansCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsAvailableVlansCreateAsyncWithHttpInfo($id, $vlan_request, string $contentType = self::contentTypes['ipamVlanGroupsAvailableVlansCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLAN[]';
        $request = $this->ipamVlanGroupsAvailableVlansCreateRequest($id, $vlan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlanGroupsAvailableVlansCreate'
     *
     * @param  int $id (required)
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsAvailableVlansCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlanGroupsAvailableVlansCreateRequest($id, $vlan_request, string $contentType = self::contentTypes['ipamVlanGroupsAvailableVlansCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVlanGroupsAvailableVlansCreate'
            );
        }

        // verify the required parameter 'vlan_request' is set
        if ($vlan_request === null || (is_array($vlan_request) && count($vlan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_request when calling ipamVlanGroupsAvailableVlansCreate'
            );
        }


        $resourcePath = '/api/ipam/vlan-groups/{id}/available-vlans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vlan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vlan_request));
            } else {
                $httpBody = $vlan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlanGroupsAvailableVlansList
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsAvailableVlansList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AvailableVLAN[]
     */
    public function ipamVlanGroupsAvailableVlansList($id, string $contentType = self::contentTypes['ipamVlanGroupsAvailableVlansList'][0])
    {
        list($response) = $this->ipamVlanGroupsAvailableVlansListWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlanGroupsAvailableVlansListWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsAvailableVlansList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AvailableVLAN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlanGroupsAvailableVlansListWithHttpInfo($id, string $contentType = self::contentTypes['ipamVlanGroupsAvailableVlansList'][0])
    {
        $request = $this->ipamVlanGroupsAvailableVlansListRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AvailableVLAN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AvailableVLAN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AvailableVLAN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AvailableVLAN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AvailableVLAN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlanGroupsAvailableVlansListAsync
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsAvailableVlansList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsAvailableVlansListAsync($id, string $contentType = self::contentTypes['ipamVlanGroupsAvailableVlansList'][0])
    {
        return $this->ipamVlanGroupsAvailableVlansListAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlanGroupsAvailableVlansListAsyncWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsAvailableVlansList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsAvailableVlansListAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamVlanGroupsAvailableVlansList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AvailableVLAN[]';
        $request = $this->ipamVlanGroupsAvailableVlansListRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlanGroupsAvailableVlansList'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsAvailableVlansList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlanGroupsAvailableVlansListRequest($id, string $contentType = self::contentTypes['ipamVlanGroupsAvailableVlansList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVlanGroupsAvailableVlansList'
            );
        }


        $resourcePath = '/api/ipam/vlan-groups/{id}/available-vlans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlanGroupsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamVlanGroupsBulkDestroy($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkDestroy'][0])
    {
        $this->ipamVlanGroupsBulkDestroyWithHttpInfo($vlan_group_request, $contentType);
    }

    /**
     * Operation ipamVlanGroupsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlanGroupsBulkDestroyWithHttpInfo($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkDestroy'][0])
    {
        $request = $this->ipamVlanGroupsBulkDestroyRequest($vlan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlanGroupsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsBulkDestroyAsync($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkDestroy'][0])
    {
        return $this->ipamVlanGroupsBulkDestroyAsyncWithHttpInfo($vlan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlanGroupsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsBulkDestroyAsyncWithHttpInfo($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamVlanGroupsBulkDestroyRequest($vlan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlanGroupsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlanGroupsBulkDestroyRequest($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkDestroy'][0])
    {

        // verify the required parameter 'vlan_group_request' is set
        if ($vlan_group_request === null || (is_array($vlan_group_request) && count($vlan_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_group_request when calling ipamVlanGroupsBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/vlan-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vlan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vlan_group_request));
            } else {
                $httpBody = $vlan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlanGroupsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLANGroup[]
     */
    public function ipamVlanGroupsBulkPartialUpdate($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamVlanGroupsBulkPartialUpdateWithHttpInfo($vlan_group_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlanGroupsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLANGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlanGroupsBulkPartialUpdateWithHttpInfo($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkPartialUpdate'][0])
    {
        $request = $this->ipamVlanGroupsBulkPartialUpdateRequest($vlan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VLANGroup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLANGroup[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLANGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLANGroup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLANGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlanGroupsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsBulkPartialUpdateAsync($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkPartialUpdate'][0])
    {
        return $this->ipamVlanGroupsBulkPartialUpdateAsyncWithHttpInfo($vlan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlanGroupsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsBulkPartialUpdateAsyncWithHttpInfo($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLANGroup[]';
        $request = $this->ipamVlanGroupsBulkPartialUpdateRequest($vlan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlanGroupsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlanGroupsBulkPartialUpdateRequest($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'vlan_group_request' is set
        if ($vlan_group_request === null || (is_array($vlan_group_request) && count($vlan_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_group_request when calling ipamVlanGroupsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/vlan-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vlan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vlan_group_request));
            } else {
                $httpBody = $vlan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlanGroupsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLANGroup[]
     */
    public function ipamVlanGroupsBulkUpdate($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkUpdate'][0])
    {
        list($response) = $this->ipamVlanGroupsBulkUpdateWithHttpInfo($vlan_group_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlanGroupsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLANGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlanGroupsBulkUpdateWithHttpInfo($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkUpdate'][0])
    {
        $request = $this->ipamVlanGroupsBulkUpdateRequest($vlan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VLANGroup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLANGroup[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLANGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLANGroup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLANGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlanGroupsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsBulkUpdateAsync($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkUpdate'][0])
    {
        return $this->ipamVlanGroupsBulkUpdateAsyncWithHttpInfo($vlan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlanGroupsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsBulkUpdateAsyncWithHttpInfo($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLANGroup[]';
        $request = $this->ipamVlanGroupsBulkUpdateRequest($vlan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlanGroupsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest[] $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlanGroupsBulkUpdateRequest($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsBulkUpdate'][0])
    {

        // verify the required parameter 'vlan_group_request' is set
        if ($vlan_group_request === null || (is_array($vlan_group_request) && count($vlan_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_group_request when calling ipamVlanGroupsBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/vlan-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vlan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vlan_group_request));
            } else {
                $httpBody = $vlan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlanGroupsCreate
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest $vlan_group_request vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLANGroup
     */
    public function ipamVlanGroupsCreate($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsCreate'][0])
    {
        list($response) = $this->ipamVlanGroupsCreateWithHttpInfo($vlan_group_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlanGroupsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLANGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlanGroupsCreateWithHttpInfo($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsCreate'][0])
    {
        $request = $this->ipamVlanGroupsCreateRequest($vlan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\VLANGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLANGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLANGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLANGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLANGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlanGroupsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsCreateAsync($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsCreate'][0])
    {
        return $this->ipamVlanGroupsCreateAsyncWithHttpInfo($vlan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlanGroupsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsCreateAsyncWithHttpInfo($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLANGroup';
        $request = $this->ipamVlanGroupsCreateRequest($vlan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlanGroupsCreate'
     *
     * @param  \OpenAPI\Client\Model\VLANGroupRequest $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlanGroupsCreateRequest($vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsCreate'][0])
    {

        // verify the required parameter 'vlan_group_request' is set
        if ($vlan_group_request === null || (is_array($vlan_group_request) && count($vlan_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_group_request when calling ipamVlanGroupsCreate'
            );
        }


        $resourcePath = '/api/ipam/vlan-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vlan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vlan_group_request));
            } else {
                $httpBody = $vlan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlanGroupsDestroy
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamVlanGroupsDestroy($id, string $contentType = self::contentTypes['ipamVlanGroupsDestroy'][0])
    {
        $this->ipamVlanGroupsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamVlanGroupsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlanGroupsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamVlanGroupsDestroy'][0])
    {
        $request = $this->ipamVlanGroupsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlanGroupsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsDestroyAsync($id, string $contentType = self::contentTypes['ipamVlanGroupsDestroy'][0])
    {
        return $this->ipamVlanGroupsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlanGroupsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamVlanGroupsDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamVlanGroupsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlanGroupsDestroy'
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlanGroupsDestroyRequest($id, string $contentType = self::contentTypes['ipamVlanGroupsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVlanGroupsDestroy'
            );
        }


        $resourcePath = '/api/ipam/vlan-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlanGroupsList
     *
     * @param  int $cluster cluster (optional)
     * @param  int $cluster_group cluster_group (optional)
     * @param  int $clustergroup clustergroup (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int $location location (optional)
     * @param  int[] $max_vid max_vid (optional)
     * @param  bool $max_vid__empty max_vid__empty (optional)
     * @param  int[] $max_vid__gt max_vid__gt (optional)
     * @param  int[] $max_vid__gte max_vid__gte (optional)
     * @param  int[] $max_vid__lt max_vid__lt (optional)
     * @param  int[] $max_vid__lte max_vid__lte (optional)
     * @param  int[] $max_vid__n max_vid__n (optional)
     * @param  int[] $min_vid min_vid (optional)
     * @param  bool $min_vid__empty min_vid__empty (optional)
     * @param  int[] $min_vid__gt min_vid__gt (optional)
     * @param  int[] $min_vid__gte min_vid__gte (optional)
     * @param  int[] $min_vid__lt min_vid__lt (optional)
     * @param  int[] $min_vid__lte min_vid__lte (optional)
     * @param  int[] $min_vid__n min_vid__n (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int $rack rack (optional)
     * @param  int $region region (optional)
     * @param  int[] $scope_id scope_id (optional)
     * @param  bool $scope_id__empty scope_id__empty (optional)
     * @param  int[] $scope_id__gt scope_id__gt (optional)
     * @param  int[] $scope_id__gte scope_id__gte (optional)
     * @param  int[] $scope_id__lt scope_id__lt (optional)
     * @param  int[] $scope_id__lte scope_id__lte (optional)
     * @param  int[] $scope_id__n scope_id__n (optional)
     * @param  string $scope_type scope_type (optional)
     * @param  string $scope_type__n scope_type__n (optional)
     * @param  int $site site (optional)
     * @param  int $site_group site_group (optional)
     * @param  int $sitegroup sitegroup (optional)
     * @param  string[] $slug slug (optional)
     * @param  bool $slug__empty slug__empty (optional)
     * @param  string[] $slug__ic slug__ic (optional)
     * @param  string[] $slug__ie slug__ie (optional)
     * @param  string[] $slug__iew slug__iew (optional)
     * @param  string[] $slug__isw slug__isw (optional)
     * @param  string[] $slug__n slug__n (optional)
     * @param  string[] $slug__nic slug__nic (optional)
     * @param  string[] $slug__nie slug__nie (optional)
     * @param  string[] $slug__niew slug__niew (optional)
     * @param  string[] $slug__nisw slug__nisw (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedVLANGroupList
     */
    public function ipamVlanGroupsList($cluster = null, $cluster_group = null, $clustergroup = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $location = null, $max_vid = null, $max_vid__empty = null, $max_vid__gt = null, $max_vid__gte = null, $max_vid__lt = null, $max_vid__lte = null, $max_vid__n = null, $min_vid = null, $min_vid__empty = null, $min_vid__gt = null, $min_vid__gte = null, $min_vid__lt = null, $min_vid__lte = null, $min_vid__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rack = null, $region = null, $scope_id = null, $scope_id__empty = null, $scope_id__gt = null, $scope_id__gte = null, $scope_id__lt = null, $scope_id__lte = null, $scope_id__n = null, $scope_type = null, $scope_type__n = null, $site = null, $site_group = null, $sitegroup = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamVlanGroupsList'][0])
    {
        list($response) = $this->ipamVlanGroupsListWithHttpInfo($cluster, $cluster_group, $clustergroup, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $location, $max_vid, $max_vid__empty, $max_vid__gt, $max_vid__gte, $max_vid__lt, $max_vid__lte, $max_vid__n, $min_vid, $min_vid__empty, $min_vid__gt, $min_vid__gte, $min_vid__lt, $min_vid__lte, $min_vid__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rack, $region, $scope_id, $scope_id__empty, $scope_id__gt, $scope_id__gte, $scope_id__lt, $scope_id__lte, $scope_id__n, $scope_type, $scope_type__n, $site, $site_group, $sitegroup, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlanGroupsListWithHttpInfo
     *
     * @param  int $cluster (optional)
     * @param  int $cluster_group (optional)
     * @param  int $clustergroup (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int $location (optional)
     * @param  int[] $max_vid (optional)
     * @param  bool $max_vid__empty (optional)
     * @param  int[] $max_vid__gt (optional)
     * @param  int[] $max_vid__gte (optional)
     * @param  int[] $max_vid__lt (optional)
     * @param  int[] $max_vid__lte (optional)
     * @param  int[] $max_vid__n (optional)
     * @param  int[] $min_vid (optional)
     * @param  bool $min_vid__empty (optional)
     * @param  int[] $min_vid__gt (optional)
     * @param  int[] $min_vid__gte (optional)
     * @param  int[] $min_vid__lt (optional)
     * @param  int[] $min_vid__lte (optional)
     * @param  int[] $min_vid__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int $rack (optional)
     * @param  int $region (optional)
     * @param  int[] $scope_id (optional)
     * @param  bool $scope_id__empty (optional)
     * @param  int[] $scope_id__gt (optional)
     * @param  int[] $scope_id__gte (optional)
     * @param  int[] $scope_id__lt (optional)
     * @param  int[] $scope_id__lte (optional)
     * @param  int[] $scope_id__n (optional)
     * @param  string $scope_type (optional)
     * @param  string $scope_type__n (optional)
     * @param  int $site (optional)
     * @param  int $site_group (optional)
     * @param  int $sitegroup (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedVLANGroupList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlanGroupsListWithHttpInfo($cluster = null, $cluster_group = null, $clustergroup = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $location = null, $max_vid = null, $max_vid__empty = null, $max_vid__gt = null, $max_vid__gte = null, $max_vid__lt = null, $max_vid__lte = null, $max_vid__n = null, $min_vid = null, $min_vid__empty = null, $min_vid__gt = null, $min_vid__gte = null, $min_vid__lt = null, $min_vid__lte = null, $min_vid__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rack = null, $region = null, $scope_id = null, $scope_id__empty = null, $scope_id__gt = null, $scope_id__gte = null, $scope_id__lt = null, $scope_id__lte = null, $scope_id__n = null, $scope_type = null, $scope_type__n = null, $site = null, $site_group = null, $sitegroup = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamVlanGroupsList'][0])
    {
        $request = $this->ipamVlanGroupsListRequest($cluster, $cluster_group, $clustergroup, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $location, $max_vid, $max_vid__empty, $max_vid__gt, $max_vid__gte, $max_vid__lt, $max_vid__lte, $max_vid__n, $min_vid, $min_vid__empty, $min_vid__gt, $min_vid__gte, $min_vid__lt, $min_vid__lte, $min_vid__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rack, $region, $scope_id, $scope_id__empty, $scope_id__gt, $scope_id__gte, $scope_id__lt, $scope_id__lte, $scope_id__n, $scope_type, $scope_type__n, $site, $site_group, $sitegroup, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedVLANGroupList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedVLANGroupList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedVLANGroupList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedVLANGroupList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedVLANGroupList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlanGroupsListAsync
     *
     * @param  int $cluster (optional)
     * @param  int $cluster_group (optional)
     * @param  int $clustergroup (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int $location (optional)
     * @param  int[] $max_vid (optional)
     * @param  bool $max_vid__empty (optional)
     * @param  int[] $max_vid__gt (optional)
     * @param  int[] $max_vid__gte (optional)
     * @param  int[] $max_vid__lt (optional)
     * @param  int[] $max_vid__lte (optional)
     * @param  int[] $max_vid__n (optional)
     * @param  int[] $min_vid (optional)
     * @param  bool $min_vid__empty (optional)
     * @param  int[] $min_vid__gt (optional)
     * @param  int[] $min_vid__gte (optional)
     * @param  int[] $min_vid__lt (optional)
     * @param  int[] $min_vid__lte (optional)
     * @param  int[] $min_vid__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int $rack (optional)
     * @param  int $region (optional)
     * @param  int[] $scope_id (optional)
     * @param  bool $scope_id__empty (optional)
     * @param  int[] $scope_id__gt (optional)
     * @param  int[] $scope_id__gte (optional)
     * @param  int[] $scope_id__lt (optional)
     * @param  int[] $scope_id__lte (optional)
     * @param  int[] $scope_id__n (optional)
     * @param  string $scope_type (optional)
     * @param  string $scope_type__n (optional)
     * @param  int $site (optional)
     * @param  int $site_group (optional)
     * @param  int $sitegroup (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsListAsync($cluster = null, $cluster_group = null, $clustergroup = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $location = null, $max_vid = null, $max_vid__empty = null, $max_vid__gt = null, $max_vid__gte = null, $max_vid__lt = null, $max_vid__lte = null, $max_vid__n = null, $min_vid = null, $min_vid__empty = null, $min_vid__gt = null, $min_vid__gte = null, $min_vid__lt = null, $min_vid__lte = null, $min_vid__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rack = null, $region = null, $scope_id = null, $scope_id__empty = null, $scope_id__gt = null, $scope_id__gte = null, $scope_id__lt = null, $scope_id__lte = null, $scope_id__n = null, $scope_type = null, $scope_type__n = null, $site = null, $site_group = null, $sitegroup = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamVlanGroupsList'][0])
    {
        return $this->ipamVlanGroupsListAsyncWithHttpInfo($cluster, $cluster_group, $clustergroup, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $location, $max_vid, $max_vid__empty, $max_vid__gt, $max_vid__gte, $max_vid__lt, $max_vid__lte, $max_vid__n, $min_vid, $min_vid__empty, $min_vid__gt, $min_vid__gte, $min_vid__lt, $min_vid__lte, $min_vid__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rack, $region, $scope_id, $scope_id__empty, $scope_id__gt, $scope_id__gte, $scope_id__lt, $scope_id__lte, $scope_id__n, $scope_type, $scope_type__n, $site, $site_group, $sitegroup, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlanGroupsListAsyncWithHttpInfo
     *
     * @param  int $cluster (optional)
     * @param  int $cluster_group (optional)
     * @param  int $clustergroup (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int $location (optional)
     * @param  int[] $max_vid (optional)
     * @param  bool $max_vid__empty (optional)
     * @param  int[] $max_vid__gt (optional)
     * @param  int[] $max_vid__gte (optional)
     * @param  int[] $max_vid__lt (optional)
     * @param  int[] $max_vid__lte (optional)
     * @param  int[] $max_vid__n (optional)
     * @param  int[] $min_vid (optional)
     * @param  bool $min_vid__empty (optional)
     * @param  int[] $min_vid__gt (optional)
     * @param  int[] $min_vid__gte (optional)
     * @param  int[] $min_vid__lt (optional)
     * @param  int[] $min_vid__lte (optional)
     * @param  int[] $min_vid__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int $rack (optional)
     * @param  int $region (optional)
     * @param  int[] $scope_id (optional)
     * @param  bool $scope_id__empty (optional)
     * @param  int[] $scope_id__gt (optional)
     * @param  int[] $scope_id__gte (optional)
     * @param  int[] $scope_id__lt (optional)
     * @param  int[] $scope_id__lte (optional)
     * @param  int[] $scope_id__n (optional)
     * @param  string $scope_type (optional)
     * @param  string $scope_type__n (optional)
     * @param  int $site (optional)
     * @param  int $site_group (optional)
     * @param  int $sitegroup (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsListAsyncWithHttpInfo($cluster = null, $cluster_group = null, $clustergroup = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $location = null, $max_vid = null, $max_vid__empty = null, $max_vid__gt = null, $max_vid__gte = null, $max_vid__lt = null, $max_vid__lte = null, $max_vid__n = null, $min_vid = null, $min_vid__empty = null, $min_vid__gt = null, $min_vid__gte = null, $min_vid__lt = null, $min_vid__lte = null, $min_vid__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rack = null, $region = null, $scope_id = null, $scope_id__empty = null, $scope_id__gt = null, $scope_id__gte = null, $scope_id__lt = null, $scope_id__lte = null, $scope_id__n = null, $scope_type = null, $scope_type__n = null, $site = null, $site_group = null, $sitegroup = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamVlanGroupsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedVLANGroupList';
        $request = $this->ipamVlanGroupsListRequest($cluster, $cluster_group, $clustergroup, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $location, $max_vid, $max_vid__empty, $max_vid__gt, $max_vid__gte, $max_vid__lt, $max_vid__lte, $max_vid__n, $min_vid, $min_vid__empty, $min_vid__gt, $min_vid__gte, $min_vid__lt, $min_vid__lte, $min_vid__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rack, $region, $scope_id, $scope_id__empty, $scope_id__gt, $scope_id__gte, $scope_id__lt, $scope_id__lte, $scope_id__n, $scope_type, $scope_type__n, $site, $site_group, $sitegroup, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlanGroupsList'
     *
     * @param  int $cluster (optional)
     * @param  int $cluster_group (optional)
     * @param  int $clustergroup (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int $location (optional)
     * @param  int[] $max_vid (optional)
     * @param  bool $max_vid__empty (optional)
     * @param  int[] $max_vid__gt (optional)
     * @param  int[] $max_vid__gte (optional)
     * @param  int[] $max_vid__lt (optional)
     * @param  int[] $max_vid__lte (optional)
     * @param  int[] $max_vid__n (optional)
     * @param  int[] $min_vid (optional)
     * @param  bool $min_vid__empty (optional)
     * @param  int[] $min_vid__gt (optional)
     * @param  int[] $min_vid__gte (optional)
     * @param  int[] $min_vid__lt (optional)
     * @param  int[] $min_vid__lte (optional)
     * @param  int[] $min_vid__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int $rack (optional)
     * @param  int $region (optional)
     * @param  int[] $scope_id (optional)
     * @param  bool $scope_id__empty (optional)
     * @param  int[] $scope_id__gt (optional)
     * @param  int[] $scope_id__gte (optional)
     * @param  int[] $scope_id__lt (optional)
     * @param  int[] $scope_id__lte (optional)
     * @param  int[] $scope_id__n (optional)
     * @param  string $scope_type (optional)
     * @param  string $scope_type__n (optional)
     * @param  int $site (optional)
     * @param  int $site_group (optional)
     * @param  int $sitegroup (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlanGroupsListRequest($cluster = null, $cluster_group = null, $clustergroup = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $location = null, $max_vid = null, $max_vid__empty = null, $max_vid__gt = null, $max_vid__gte = null, $max_vid__lt = null, $max_vid__lte = null, $max_vid__n = null, $min_vid = null, $min_vid__empty = null, $min_vid__gt = null, $min_vid__gte = null, $min_vid__lt = null, $min_vid__lte = null, $min_vid__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rack = null, $region = null, $scope_id = null, $scope_id__empty = null, $scope_id__gt = null, $scope_id__gte = null, $scope_id__lt = null, $scope_id__lte = null, $scope_id__n = null, $scope_type = null, $scope_type__n = null, $site = null, $site_group = null, $sitegroup = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamVlanGroupsList'][0])
    {

































































































        $resourcePath = '/api/ipam/vlan-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster,
            'cluster', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_group,
            'cluster_group', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clustergroup,
            'clustergroup', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $location,
            'location', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vid,
            'max_vid', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vid__empty,
            'max_vid__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vid__gt,
            'max_vid__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vid__gte,
            'max_vid__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vid__lt,
            'max_vid__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vid__lte,
            'max_vid__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vid__n,
            'max_vid__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vid,
            'min_vid', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vid__empty,
            'min_vid__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vid__gt,
            'min_vid__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vid__gte,
            'min_vid__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vid__lt,
            'min_vid__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vid__lte,
            'min_vid__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vid__n,
            'min_vid__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rack,
            'rack', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region,
            'region', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope_id,
            'scope_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope_id__empty,
            'scope_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope_id__gt,
            'scope_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope_id__gte,
            'scope_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope_id__lt,
            'scope_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope_id__lte,
            'scope_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope_id__n,
            'scope_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope_type,
            'scope_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope_type__n,
            'scope_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site,
            'site', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group,
            'site_group', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sitegroup,
            'sitegroup', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__empty,
            'slug__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ic,
            'slug__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ie,
            'slug__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__iew,
            'slug__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__isw,
            'slug__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__n,
            'slug__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nic,
            'slug__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nie,
            'slug__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__niew,
            'slug__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nisw,
            'slug__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlanGroupsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  \OpenAPI\Client\Model\PatchedVLANGroupRequest $patched_vlan_group_request patched_vlan_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLANGroup
     */
    public function ipamVlanGroupsPartialUpdate($id, $patched_vlan_group_request = null, string $contentType = self::contentTypes['ipamVlanGroupsPartialUpdate'][0])
    {
        list($response) = $this->ipamVlanGroupsPartialUpdateWithHttpInfo($id, $patched_vlan_group_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlanGroupsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  \OpenAPI\Client\Model\PatchedVLANGroupRequest $patched_vlan_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLANGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlanGroupsPartialUpdateWithHttpInfo($id, $patched_vlan_group_request = null, string $contentType = self::contentTypes['ipamVlanGroupsPartialUpdate'][0])
    {
        $request = $this->ipamVlanGroupsPartialUpdateRequest($id, $patched_vlan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VLANGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLANGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLANGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLANGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLANGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlanGroupsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  \OpenAPI\Client\Model\PatchedVLANGroupRequest $patched_vlan_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsPartialUpdateAsync($id, $patched_vlan_group_request = null, string $contentType = self::contentTypes['ipamVlanGroupsPartialUpdate'][0])
    {
        return $this->ipamVlanGroupsPartialUpdateAsyncWithHttpInfo($id, $patched_vlan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlanGroupsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  \OpenAPI\Client\Model\PatchedVLANGroupRequest $patched_vlan_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsPartialUpdateAsyncWithHttpInfo($id, $patched_vlan_group_request = null, string $contentType = self::contentTypes['ipamVlanGroupsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLANGroup';
        $request = $this->ipamVlanGroupsPartialUpdateRequest($id, $patched_vlan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlanGroupsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  \OpenAPI\Client\Model\PatchedVLANGroupRequest $patched_vlan_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlanGroupsPartialUpdateRequest($id, $patched_vlan_group_request = null, string $contentType = self::contentTypes['ipamVlanGroupsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVlanGroupsPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/vlan-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_vlan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_vlan_group_request));
            } else {
                $httpBody = $patched_vlan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlanGroupsRetrieve
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLANGroup
     */
    public function ipamVlanGroupsRetrieve($id, string $contentType = self::contentTypes['ipamVlanGroupsRetrieve'][0])
    {
        list($response) = $this->ipamVlanGroupsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlanGroupsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLANGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlanGroupsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamVlanGroupsRetrieve'][0])
    {
        $request = $this->ipamVlanGroupsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VLANGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLANGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLANGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLANGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLANGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlanGroupsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsRetrieveAsync($id, string $contentType = self::contentTypes['ipamVlanGroupsRetrieve'][0])
    {
        return $this->ipamVlanGroupsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlanGroupsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamVlanGroupsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLANGroup';
        $request = $this->ipamVlanGroupsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlanGroupsRetrieve'
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlanGroupsRetrieveRequest($id, string $contentType = self::contentTypes['ipamVlanGroupsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVlanGroupsRetrieve'
            );
        }


        $resourcePath = '/api/ipam/vlan-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlanGroupsUpdate
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  \OpenAPI\Client\Model\VLANGroupRequest $vlan_group_request vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLANGroup
     */
    public function ipamVlanGroupsUpdate($id, $vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsUpdate'][0])
    {
        list($response) = $this->ipamVlanGroupsUpdateWithHttpInfo($id, $vlan_group_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlanGroupsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  \OpenAPI\Client\Model\VLANGroupRequest $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLANGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlanGroupsUpdateWithHttpInfo($id, $vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsUpdate'][0])
    {
        $request = $this->ipamVlanGroupsUpdateRequest($id, $vlan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VLANGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLANGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLANGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLANGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLANGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlanGroupsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  \OpenAPI\Client\Model\VLANGroupRequest $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsUpdateAsync($id, $vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsUpdate'][0])
    {
        return $this->ipamVlanGroupsUpdateAsyncWithHttpInfo($id, $vlan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlanGroupsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  \OpenAPI\Client\Model\VLANGroupRequest $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlanGroupsUpdateAsyncWithHttpInfo($id, $vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLANGroup';
        $request = $this->ipamVlanGroupsUpdateRequest($id, $vlan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlanGroupsUpdate'
     *
     * @param  int $id A unique integer value identifying this VLAN group. (required)
     * @param  \OpenAPI\Client\Model\VLANGroupRequest $vlan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlanGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlanGroupsUpdateRequest($id, $vlan_group_request, string $contentType = self::contentTypes['ipamVlanGroupsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVlanGroupsUpdate'
            );
        }

        // verify the required parameter 'vlan_group_request' is set
        if ($vlan_group_request === null || (is_array($vlan_group_request) && count($vlan_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_group_request when calling ipamVlanGroupsUpdate'
            );
        }


        $resourcePath = '/api/ipam/vlan-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vlan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vlan_group_request));
            } else {
                $httpBody = $vlan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlansBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamVlansBulkDestroy($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkDestroy'][0])
    {
        $this->ipamVlansBulkDestroyWithHttpInfo($vlan_request, $contentType);
    }

    /**
     * Operation ipamVlansBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlansBulkDestroyWithHttpInfo($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkDestroy'][0])
    {
        $request = $this->ipamVlansBulkDestroyRequest($vlan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlansBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansBulkDestroyAsync($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkDestroy'][0])
    {
        return $this->ipamVlansBulkDestroyAsyncWithHttpInfo($vlan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlansBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansBulkDestroyAsyncWithHttpInfo($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamVlansBulkDestroyRequest($vlan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlansBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlansBulkDestroyRequest($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkDestroy'][0])
    {

        // verify the required parameter 'vlan_request' is set
        if ($vlan_request === null || (is_array($vlan_request) && count($vlan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_request when calling ipamVlansBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/vlans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vlan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vlan_request));
            } else {
                $httpBody = $vlan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlansBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLAN[]
     */
    public function ipamVlansBulkPartialUpdate($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamVlansBulkPartialUpdateWithHttpInfo($vlan_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlansBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLAN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlansBulkPartialUpdateWithHttpInfo($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkPartialUpdate'][0])
    {
        $request = $this->ipamVlansBulkPartialUpdateRequest($vlan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VLAN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLAN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLAN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLAN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLAN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlansBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansBulkPartialUpdateAsync($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkPartialUpdate'][0])
    {
        return $this->ipamVlansBulkPartialUpdateAsyncWithHttpInfo($vlan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlansBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansBulkPartialUpdateAsyncWithHttpInfo($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLAN[]';
        $request = $this->ipamVlansBulkPartialUpdateRequest($vlan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlansBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlansBulkPartialUpdateRequest($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkPartialUpdate'][0])
    {

        // verify the required parameter 'vlan_request' is set
        if ($vlan_request === null || (is_array($vlan_request) && count($vlan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_request when calling ipamVlansBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/vlans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vlan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vlan_request));
            } else {
                $httpBody = $vlan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlansBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLAN[]
     */
    public function ipamVlansBulkUpdate($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkUpdate'][0])
    {
        list($response) = $this->ipamVlansBulkUpdateWithHttpInfo($vlan_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlansBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLAN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlansBulkUpdateWithHttpInfo($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkUpdate'][0])
    {
        $request = $this->ipamVlansBulkUpdateRequest($vlan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VLAN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLAN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLAN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLAN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLAN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlansBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansBulkUpdateAsync($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkUpdate'][0])
    {
        return $this->ipamVlansBulkUpdateAsyncWithHttpInfo($vlan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlansBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansBulkUpdateAsyncWithHttpInfo($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLAN[]';
        $request = $this->ipamVlansBulkUpdateRequest($vlan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlansBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\VLANRequest[] $vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlansBulkUpdateRequest($vlan_request, string $contentType = self::contentTypes['ipamVlansBulkUpdate'][0])
    {

        // verify the required parameter 'vlan_request' is set
        if ($vlan_request === null || (is_array($vlan_request) && count($vlan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_request when calling ipamVlansBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/vlans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vlan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vlan_request));
            } else {
                $httpBody = $vlan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlansCreate
     *
     * @param  \OpenAPI\Client\Model\WritableVLANRequest $writable_vlan_request writable_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLAN
     */
    public function ipamVlansCreate($writable_vlan_request, string $contentType = self::contentTypes['ipamVlansCreate'][0])
    {
        list($response) = $this->ipamVlansCreateWithHttpInfo($writable_vlan_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlansCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableVLANRequest $writable_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLAN, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlansCreateWithHttpInfo($writable_vlan_request, string $contentType = self::contentTypes['ipamVlansCreate'][0])
    {
        $request = $this->ipamVlansCreateRequest($writable_vlan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\VLAN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLAN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLAN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLAN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLAN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlansCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableVLANRequest $writable_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansCreateAsync($writable_vlan_request, string $contentType = self::contentTypes['ipamVlansCreate'][0])
    {
        return $this->ipamVlansCreateAsyncWithHttpInfo($writable_vlan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlansCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableVLANRequest $writable_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansCreateAsyncWithHttpInfo($writable_vlan_request, string $contentType = self::contentTypes['ipamVlansCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLAN';
        $request = $this->ipamVlansCreateRequest($writable_vlan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlansCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableVLANRequest $writable_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlansCreateRequest($writable_vlan_request, string $contentType = self::contentTypes['ipamVlansCreate'][0])
    {

        // verify the required parameter 'writable_vlan_request' is set
        if ($writable_vlan_request === null || (is_array($writable_vlan_request) && count($writable_vlan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_vlan_request when calling ipamVlansCreate'
            );
        }


        $resourcePath = '/api/ipam/vlans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_vlan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_vlan_request));
            } else {
                $httpBody = $writable_vlan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlansDestroy
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamVlansDestroy($id, string $contentType = self::contentTypes['ipamVlansDestroy'][0])
    {
        $this->ipamVlansDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamVlansDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlansDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamVlansDestroy'][0])
    {
        $request = $this->ipamVlansDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlansDestroyAsync
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansDestroyAsync($id, string $contentType = self::contentTypes['ipamVlansDestroy'][0])
    {
        return $this->ipamVlansDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlansDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamVlansDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamVlansDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlansDestroy'
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlansDestroyRequest($id, string $contentType = self::contentTypes['ipamVlansDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVlansDestroy'
            );
        }


        $resourcePath = '/api/ipam/vlans/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlansList
     *
     * @param  string $available_at_site available_at_site (optional)
     * @param  string $available_on_device available_on_device (optional)
     * @param  string $available_on_virtualmachine available_on_virtualmachine (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $group Group (optional)
     * @param  string[] $group__n Group (optional)
     * @param  int[] $group_id Group (ID) (optional)
     * @param  int[] $group_id__n Group (ID) (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  int[] $l2vpn L2VPN (optional)
     * @param  int[] $l2vpn__n L2VPN (optional)
     * @param  int[] $l2vpn_id L2VPN (ID) (optional)
     * @param  int[] $l2vpn_id__n L2VPN (ID) (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status Operational status of this VLAN (optional)
     * @param  string[] $status__n Operational status of this VLAN (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  int[] $vid vid (optional)
     * @param  bool $vid__empty vid__empty (optional)
     * @param  int[] $vid__gt vid__gt (optional)
     * @param  int[] $vid__gte vid__gte (optional)
     * @param  int[] $vid__lt vid__lt (optional)
     * @param  int[] $vid__lte vid__lte (optional)
     * @param  int[] $vid__n vid__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedVLANList
     */
    public function ipamVlansList($available_at_site = null, $available_on_device = null, $available_on_virtualmachine = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $l2vpn = null, $l2vpn__n = null, $l2vpn_id = null, $l2vpn_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vid = null, $vid__empty = null, $vid__gt = null, $vid__gte = null, $vid__lt = null, $vid__lte = null, $vid__n = null, string $contentType = self::contentTypes['ipamVlansList'][0])
    {
        list($response) = $this->ipamVlansListWithHttpInfo($available_at_site, $available_on_device, $available_on_virtualmachine, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $l2vpn, $l2vpn__n, $l2vpn_id, $l2vpn_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vid, $vid__empty, $vid__gt, $vid__gte, $vid__lt, $vid__lte, $vid__n, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlansListWithHttpInfo
     *
     * @param  string $available_at_site (optional)
     * @param  string $available_on_device (optional)
     * @param  string $available_on_virtualmachine (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $group Group (optional)
     * @param  string[] $group__n Group (optional)
     * @param  int[] $group_id Group (ID) (optional)
     * @param  int[] $group_id__n Group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $l2vpn L2VPN (optional)
     * @param  int[] $l2vpn__n L2VPN (optional)
     * @param  int[] $l2vpn_id L2VPN (ID) (optional)
     * @param  int[] $l2vpn_id__n L2VPN (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status Operational status of this VLAN (optional)
     * @param  string[] $status__n Operational status of this VLAN (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vid (optional)
     * @param  bool $vid__empty (optional)
     * @param  int[] $vid__gt (optional)
     * @param  int[] $vid__gte (optional)
     * @param  int[] $vid__lt (optional)
     * @param  int[] $vid__lte (optional)
     * @param  int[] $vid__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedVLANList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlansListWithHttpInfo($available_at_site = null, $available_on_device = null, $available_on_virtualmachine = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $l2vpn = null, $l2vpn__n = null, $l2vpn_id = null, $l2vpn_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vid = null, $vid__empty = null, $vid__gt = null, $vid__gte = null, $vid__lt = null, $vid__lte = null, $vid__n = null, string $contentType = self::contentTypes['ipamVlansList'][0])
    {
        $request = $this->ipamVlansListRequest($available_at_site, $available_on_device, $available_on_virtualmachine, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $l2vpn, $l2vpn__n, $l2vpn_id, $l2vpn_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vid, $vid__empty, $vid__gt, $vid__gte, $vid__lt, $vid__lte, $vid__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedVLANList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedVLANList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedVLANList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedVLANList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedVLANList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlansListAsync
     *
     * @param  string $available_at_site (optional)
     * @param  string $available_on_device (optional)
     * @param  string $available_on_virtualmachine (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $group Group (optional)
     * @param  string[] $group__n Group (optional)
     * @param  int[] $group_id Group (ID) (optional)
     * @param  int[] $group_id__n Group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $l2vpn L2VPN (optional)
     * @param  int[] $l2vpn__n L2VPN (optional)
     * @param  int[] $l2vpn_id L2VPN (ID) (optional)
     * @param  int[] $l2vpn_id__n L2VPN (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status Operational status of this VLAN (optional)
     * @param  string[] $status__n Operational status of this VLAN (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vid (optional)
     * @param  bool $vid__empty (optional)
     * @param  int[] $vid__gt (optional)
     * @param  int[] $vid__gte (optional)
     * @param  int[] $vid__lt (optional)
     * @param  int[] $vid__lte (optional)
     * @param  int[] $vid__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansListAsync($available_at_site = null, $available_on_device = null, $available_on_virtualmachine = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $l2vpn = null, $l2vpn__n = null, $l2vpn_id = null, $l2vpn_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vid = null, $vid__empty = null, $vid__gt = null, $vid__gte = null, $vid__lt = null, $vid__lte = null, $vid__n = null, string $contentType = self::contentTypes['ipamVlansList'][0])
    {
        return $this->ipamVlansListAsyncWithHttpInfo($available_at_site, $available_on_device, $available_on_virtualmachine, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $l2vpn, $l2vpn__n, $l2vpn_id, $l2vpn_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vid, $vid__empty, $vid__gt, $vid__gte, $vid__lt, $vid__lte, $vid__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlansListAsyncWithHttpInfo
     *
     * @param  string $available_at_site (optional)
     * @param  string $available_on_device (optional)
     * @param  string $available_on_virtualmachine (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $group Group (optional)
     * @param  string[] $group__n Group (optional)
     * @param  int[] $group_id Group (ID) (optional)
     * @param  int[] $group_id__n Group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $l2vpn L2VPN (optional)
     * @param  int[] $l2vpn__n L2VPN (optional)
     * @param  int[] $l2vpn_id L2VPN (ID) (optional)
     * @param  int[] $l2vpn_id__n L2VPN (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status Operational status of this VLAN (optional)
     * @param  string[] $status__n Operational status of this VLAN (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vid (optional)
     * @param  bool $vid__empty (optional)
     * @param  int[] $vid__gt (optional)
     * @param  int[] $vid__gte (optional)
     * @param  int[] $vid__lt (optional)
     * @param  int[] $vid__lte (optional)
     * @param  int[] $vid__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansListAsyncWithHttpInfo($available_at_site = null, $available_on_device = null, $available_on_virtualmachine = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $l2vpn = null, $l2vpn__n = null, $l2vpn_id = null, $l2vpn_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vid = null, $vid__empty = null, $vid__gt = null, $vid__gte = null, $vid__lt = null, $vid__lte = null, $vid__n = null, string $contentType = self::contentTypes['ipamVlansList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedVLANList';
        $request = $this->ipamVlansListRequest($available_at_site, $available_on_device, $available_on_virtualmachine, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $l2vpn, $l2vpn__n, $l2vpn_id, $l2vpn_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vid, $vid__empty, $vid__gt, $vid__gte, $vid__lt, $vid__lte, $vid__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlansList'
     *
     * @param  string $available_at_site (optional)
     * @param  string $available_on_device (optional)
     * @param  string $available_on_virtualmachine (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $group Group (optional)
     * @param  string[] $group__n Group (optional)
     * @param  int[] $group_id Group (ID) (optional)
     * @param  int[] $group_id__n Group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $l2vpn L2VPN (optional)
     * @param  int[] $l2vpn__n L2VPN (optional)
     * @param  int[] $l2vpn_id L2VPN (ID) (optional)
     * @param  int[] $l2vpn_id__n L2VPN (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (ID) (optional)
     * @param  int[] $role_id__n Role (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status Operational status of this VLAN (optional)
     * @param  string[] $status__n Operational status of this VLAN (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vid (optional)
     * @param  bool $vid__empty (optional)
     * @param  int[] $vid__gt (optional)
     * @param  int[] $vid__gte (optional)
     * @param  int[] $vid__lt (optional)
     * @param  int[] $vid__lte (optional)
     * @param  int[] $vid__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlansListRequest($available_at_site = null, $available_on_device = null, $available_on_virtualmachine = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $l2vpn = null, $l2vpn__n = null, $l2vpn_id = null, $l2vpn_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vid = null, $vid__empty = null, $vid__gt = null, $vid__gte = null, $vid__lt = null, $vid__lte = null, $vid__n = null, string $contentType = self::contentTypes['ipamVlansList'][0])
    {


































































































        $resourcePath = '/api/ipam/vlans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $available_at_site,
            'available_at_site', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $available_on_device,
            'available_on_device', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $available_on_virtualmachine,
            'available_on_virtualmachine', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group,
            'group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group__n,
            'group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id,
            'group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__n,
            'group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $l2vpn,
            'l2vpn', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $l2vpn__n,
            'l2vpn__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $l2vpn_id,
            'l2vpn_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $l2vpn_id__n,
            'l2vpn_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region,
            'region', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region__n,
            'region__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region_id,
            'region_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region_id__n,
            'region_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role,
            'role', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role__n,
            'role__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role_id,
            'role_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role_id__n,
            'role_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site,
            'site', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site__n,
            'site__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group,
            'site_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group__n,
            'site_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group_id,
            'site_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group_id__n,
            'site_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id,
            'site_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id__n,
            'site_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status__n,
            'status__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vid,
            'vid', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vid__empty,
            'vid__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vid__gt,
            'vid__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vid__gte,
            'vid__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vid__lt,
            'vid__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vid__lte,
            'vid__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vid__n,
            'vid__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlansPartialUpdate
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableVLANRequest $patched_writable_vlan_request patched_writable_vlan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLAN
     */
    public function ipamVlansPartialUpdate($id, $patched_writable_vlan_request = null, string $contentType = self::contentTypes['ipamVlansPartialUpdate'][0])
    {
        list($response) = $this->ipamVlansPartialUpdateWithHttpInfo($id, $patched_writable_vlan_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlansPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableVLANRequest $patched_writable_vlan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLAN, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlansPartialUpdateWithHttpInfo($id, $patched_writable_vlan_request = null, string $contentType = self::contentTypes['ipamVlansPartialUpdate'][0])
    {
        $request = $this->ipamVlansPartialUpdateRequest($id, $patched_writable_vlan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VLAN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLAN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLAN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLAN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLAN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlansPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableVLANRequest $patched_writable_vlan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansPartialUpdateAsync($id, $patched_writable_vlan_request = null, string $contentType = self::contentTypes['ipamVlansPartialUpdate'][0])
    {
        return $this->ipamVlansPartialUpdateAsyncWithHttpInfo($id, $patched_writable_vlan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlansPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableVLANRequest $patched_writable_vlan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansPartialUpdateAsyncWithHttpInfo($id, $patched_writable_vlan_request = null, string $contentType = self::contentTypes['ipamVlansPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLAN';
        $request = $this->ipamVlansPartialUpdateRequest($id, $patched_writable_vlan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlansPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableVLANRequest $patched_writable_vlan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlansPartialUpdateRequest($id, $patched_writable_vlan_request = null, string $contentType = self::contentTypes['ipamVlansPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVlansPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/vlans/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_vlan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_vlan_request));
            } else {
                $httpBody = $patched_writable_vlan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlansRetrieve
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLAN
     */
    public function ipamVlansRetrieve($id, string $contentType = self::contentTypes['ipamVlansRetrieve'][0])
    {
        list($response) = $this->ipamVlansRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlansRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLAN, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlansRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamVlansRetrieve'][0])
    {
        $request = $this->ipamVlansRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VLAN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLAN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLAN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLAN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLAN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlansRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansRetrieveAsync($id, string $contentType = self::contentTypes['ipamVlansRetrieve'][0])
    {
        return $this->ipamVlansRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlansRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamVlansRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLAN';
        $request = $this->ipamVlansRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlansRetrieve'
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlansRetrieveRequest($id, string $contentType = self::contentTypes['ipamVlansRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVlansRetrieve'
            );
        }


        $resourcePath = '/api/ipam/vlans/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVlansUpdate
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  \OpenAPI\Client\Model\WritableVLANRequest $writable_vlan_request writable_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VLAN
     */
    public function ipamVlansUpdate($id, $writable_vlan_request, string $contentType = self::contentTypes['ipamVlansUpdate'][0])
    {
        list($response) = $this->ipamVlansUpdateWithHttpInfo($id, $writable_vlan_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVlansUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  \OpenAPI\Client\Model\WritableVLANRequest $writable_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VLAN, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVlansUpdateWithHttpInfo($id, $writable_vlan_request, string $contentType = self::contentTypes['ipamVlansUpdate'][0])
    {
        $request = $this->ipamVlansUpdateRequest($id, $writable_vlan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VLAN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VLAN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VLAN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VLAN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VLAN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVlansUpdateAsync
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  \OpenAPI\Client\Model\WritableVLANRequest $writable_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansUpdateAsync($id, $writable_vlan_request, string $contentType = self::contentTypes['ipamVlansUpdate'][0])
    {
        return $this->ipamVlansUpdateAsyncWithHttpInfo($id, $writable_vlan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVlansUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  \OpenAPI\Client\Model\WritableVLANRequest $writable_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVlansUpdateAsyncWithHttpInfo($id, $writable_vlan_request, string $contentType = self::contentTypes['ipamVlansUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VLAN';
        $request = $this->ipamVlansUpdateRequest($id, $writable_vlan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVlansUpdate'
     *
     * @param  int $id A unique integer value identifying this VLAN. (required)
     * @param  \OpenAPI\Client\Model\WritableVLANRequest $writable_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVlansUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVlansUpdateRequest($id, $writable_vlan_request, string $contentType = self::contentTypes['ipamVlansUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVlansUpdate'
            );
        }

        // verify the required parameter 'writable_vlan_request' is set
        if ($writable_vlan_request === null || (is_array($writable_vlan_request) && count($writable_vlan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_vlan_request when calling ipamVlansUpdate'
            );
        }


        $resourcePath = '/api/ipam/vlans/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_vlan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_vlan_request));
            } else {
                $httpBody = $writable_vlan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVrfsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamVrfsBulkDestroy($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkDestroy'][0])
    {
        $this->ipamVrfsBulkDestroyWithHttpInfo($vrf_request, $contentType);
    }

    /**
     * Operation ipamVrfsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVrfsBulkDestroyWithHttpInfo($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkDestroy'][0])
    {
        $request = $this->ipamVrfsBulkDestroyRequest($vrf_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVrfsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsBulkDestroyAsync($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkDestroy'][0])
    {
        return $this->ipamVrfsBulkDestroyAsyncWithHttpInfo($vrf_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVrfsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsBulkDestroyAsyncWithHttpInfo($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamVrfsBulkDestroyRequest($vrf_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVrfsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVrfsBulkDestroyRequest($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkDestroy'][0])
    {

        // verify the required parameter 'vrf_request' is set
        if ($vrf_request === null || (is_array($vrf_request) && count($vrf_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vrf_request when calling ipamVrfsBulkDestroy'
            );
        }


        $resourcePath = '/api/ipam/vrfs/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vrf_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vrf_request));
            } else {
                $httpBody = $vrf_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVrfsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VRF[]
     */
    public function ipamVrfsBulkPartialUpdate($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkPartialUpdate'][0])
    {
        list($response) = $this->ipamVrfsBulkPartialUpdateWithHttpInfo($vrf_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVrfsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VRF[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVrfsBulkPartialUpdateWithHttpInfo($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkPartialUpdate'][0])
    {
        $request = $this->ipamVrfsBulkPartialUpdateRequest($vrf_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VRF[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VRF[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VRF[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VRF[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VRF[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVrfsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsBulkPartialUpdateAsync($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkPartialUpdate'][0])
    {
        return $this->ipamVrfsBulkPartialUpdateAsyncWithHttpInfo($vrf_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVrfsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsBulkPartialUpdateAsyncWithHttpInfo($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VRF[]';
        $request = $this->ipamVrfsBulkPartialUpdateRequest($vrf_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVrfsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVrfsBulkPartialUpdateRequest($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'vrf_request' is set
        if ($vrf_request === null || (is_array($vrf_request) && count($vrf_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vrf_request when calling ipamVrfsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/ipam/vrfs/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vrf_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vrf_request));
            } else {
                $httpBody = $vrf_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVrfsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VRF[]
     */
    public function ipamVrfsBulkUpdate($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkUpdate'][0])
    {
        list($response) = $this->ipamVrfsBulkUpdateWithHttpInfo($vrf_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVrfsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VRF[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVrfsBulkUpdateWithHttpInfo($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkUpdate'][0])
    {
        $request = $this->ipamVrfsBulkUpdateRequest($vrf_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VRF[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VRF[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VRF[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VRF[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VRF[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVrfsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsBulkUpdateAsync($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkUpdate'][0])
    {
        return $this->ipamVrfsBulkUpdateAsyncWithHttpInfo($vrf_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVrfsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsBulkUpdateAsyncWithHttpInfo($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VRF[]';
        $request = $this->ipamVrfsBulkUpdateRequest($vrf_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVrfsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\VRFRequest[] $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVrfsBulkUpdateRequest($vrf_request, string $contentType = self::contentTypes['ipamVrfsBulkUpdate'][0])
    {

        // verify the required parameter 'vrf_request' is set
        if ($vrf_request === null || (is_array($vrf_request) && count($vrf_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vrf_request when calling ipamVrfsBulkUpdate'
            );
        }


        $resourcePath = '/api/ipam/vrfs/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vrf_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vrf_request));
            } else {
                $httpBody = $vrf_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVrfsCreate
     *
     * @param  \OpenAPI\Client\Model\VRFRequest $vrf_request vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VRF
     */
    public function ipamVrfsCreate($vrf_request, string $contentType = self::contentTypes['ipamVrfsCreate'][0])
    {
        list($response) = $this->ipamVrfsCreateWithHttpInfo($vrf_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVrfsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VRFRequest $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VRF, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVrfsCreateWithHttpInfo($vrf_request, string $contentType = self::contentTypes['ipamVrfsCreate'][0])
    {
        $request = $this->ipamVrfsCreateRequest($vrf_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\VRF' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VRF' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VRF', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VRF';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VRF',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVrfsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\VRFRequest $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsCreateAsync($vrf_request, string $contentType = self::contentTypes['ipamVrfsCreate'][0])
    {
        return $this->ipamVrfsCreateAsyncWithHttpInfo($vrf_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVrfsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\VRFRequest $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsCreateAsyncWithHttpInfo($vrf_request, string $contentType = self::contentTypes['ipamVrfsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VRF';
        $request = $this->ipamVrfsCreateRequest($vrf_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVrfsCreate'
     *
     * @param  \OpenAPI\Client\Model\VRFRequest $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVrfsCreateRequest($vrf_request, string $contentType = self::contentTypes['ipamVrfsCreate'][0])
    {

        // verify the required parameter 'vrf_request' is set
        if ($vrf_request === null || (is_array($vrf_request) && count($vrf_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vrf_request when calling ipamVrfsCreate'
            );
        }


        $resourcePath = '/api/ipam/vrfs/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vrf_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vrf_request));
            } else {
                $httpBody = $vrf_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVrfsDestroy
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ipamVrfsDestroy($id, string $contentType = self::contentTypes['ipamVrfsDestroy'][0])
    {
        $this->ipamVrfsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation ipamVrfsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVrfsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['ipamVrfsDestroy'][0])
    {
        $request = $this->ipamVrfsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVrfsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsDestroyAsync($id, string $contentType = self::contentTypes['ipamVrfsDestroy'][0])
    {
        return $this->ipamVrfsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVrfsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamVrfsDestroy'][0])
    {
        $returnType = '';
        $request = $this->ipamVrfsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVrfsDestroy'
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVrfsDestroyRequest($id, string $contentType = self::contentTypes['ipamVrfsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVrfsDestroy'
            );
        }


        $resourcePath = '/api/ipam/vrfs/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVrfsList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  bool $enforce_unique enforce_unique (optional)
     * @param  string[] $export_target Export target (name) (optional)
     * @param  string[] $export_target__n Export target (name) (optional)
     * @param  int[] $export_target_id Export target (optional)
     * @param  int[] $export_target_id__n Export target (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $import_target Import target (name) (optional)
     * @param  string[] $import_target__n Import target (name) (optional)
     * @param  int[] $import_target_id Import target (optional)
     * @param  int[] $import_target_id__n Import target (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rd rd (optional)
     * @param  bool $rd__empty rd__empty (optional)
     * @param  string[] $rd__ic rd__ic (optional)
     * @param  string[] $rd__ie rd__ie (optional)
     * @param  string[] $rd__iew rd__iew (optional)
     * @param  string[] $rd__isw rd__isw (optional)
     * @param  string[] $rd__n rd__n (optional)
     * @param  string[] $rd__nic rd__nic (optional)
     * @param  string[] $rd__nie rd__nie (optional)
     * @param  string[] $rd__niew rd__niew (optional)
     * @param  string[] $rd__nisw rd__nisw (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedVRFList
     */
    public function ipamVrfsList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enforce_unique = null, $export_target = null, $export_target__n = null, $export_target_id = null, $export_target_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $import_target = null, $import_target__n = null, $import_target_id = null, $import_target_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rd = null, $rd__empty = null, $rd__ic = null, $rd__ie = null, $rd__iew = null, $rd__isw = null, $rd__n = null, $rd__nic = null, $rd__nie = null, $rd__niew = null, $rd__nisw = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamVrfsList'][0])
    {
        list($response) = $this->ipamVrfsListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enforce_unique, $export_target, $export_target__n, $export_target_id, $export_target_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $import_target, $import_target__n, $import_target_id, $import_target_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rd, $rd__empty, $rd__ic, $rd__ie, $rd__iew, $rd__isw, $rd__n, $rd__nic, $rd__nie, $rd__niew, $rd__nisw, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVrfsListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enforce_unique (optional)
     * @param  string[] $export_target Export target (name) (optional)
     * @param  string[] $export_target__n Export target (name) (optional)
     * @param  int[] $export_target_id Export target (optional)
     * @param  int[] $export_target_id__n Export target (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $import_target Import target (name) (optional)
     * @param  string[] $import_target__n Import target (name) (optional)
     * @param  int[] $import_target_id Import target (optional)
     * @param  int[] $import_target_id__n Import target (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rd (optional)
     * @param  bool $rd__empty (optional)
     * @param  string[] $rd__ic (optional)
     * @param  string[] $rd__ie (optional)
     * @param  string[] $rd__iew (optional)
     * @param  string[] $rd__isw (optional)
     * @param  string[] $rd__n (optional)
     * @param  string[] $rd__nic (optional)
     * @param  string[] $rd__nie (optional)
     * @param  string[] $rd__niew (optional)
     * @param  string[] $rd__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedVRFList, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVrfsListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enforce_unique = null, $export_target = null, $export_target__n = null, $export_target_id = null, $export_target_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $import_target = null, $import_target__n = null, $import_target_id = null, $import_target_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rd = null, $rd__empty = null, $rd__ic = null, $rd__ie = null, $rd__iew = null, $rd__isw = null, $rd__n = null, $rd__nic = null, $rd__nie = null, $rd__niew = null, $rd__nisw = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamVrfsList'][0])
    {
        $request = $this->ipamVrfsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enforce_unique, $export_target, $export_target__n, $export_target_id, $export_target_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $import_target, $import_target__n, $import_target_id, $import_target_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rd, $rd__empty, $rd__ic, $rd__ie, $rd__iew, $rd__isw, $rd__n, $rd__nic, $rd__nie, $rd__niew, $rd__nisw, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedVRFList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedVRFList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedVRFList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedVRFList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedVRFList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVrfsListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enforce_unique (optional)
     * @param  string[] $export_target Export target (name) (optional)
     * @param  string[] $export_target__n Export target (name) (optional)
     * @param  int[] $export_target_id Export target (optional)
     * @param  int[] $export_target_id__n Export target (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $import_target Import target (name) (optional)
     * @param  string[] $import_target__n Import target (name) (optional)
     * @param  int[] $import_target_id Import target (optional)
     * @param  int[] $import_target_id__n Import target (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rd (optional)
     * @param  bool $rd__empty (optional)
     * @param  string[] $rd__ic (optional)
     * @param  string[] $rd__ie (optional)
     * @param  string[] $rd__iew (optional)
     * @param  string[] $rd__isw (optional)
     * @param  string[] $rd__n (optional)
     * @param  string[] $rd__nic (optional)
     * @param  string[] $rd__nie (optional)
     * @param  string[] $rd__niew (optional)
     * @param  string[] $rd__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enforce_unique = null, $export_target = null, $export_target__n = null, $export_target_id = null, $export_target_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $import_target = null, $import_target__n = null, $import_target_id = null, $import_target_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rd = null, $rd__empty = null, $rd__ic = null, $rd__ie = null, $rd__iew = null, $rd__isw = null, $rd__n = null, $rd__nic = null, $rd__nie = null, $rd__niew = null, $rd__nisw = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamVrfsList'][0])
    {
        return $this->ipamVrfsListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enforce_unique, $export_target, $export_target__n, $export_target_id, $export_target_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $import_target, $import_target__n, $import_target_id, $import_target_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rd, $rd__empty, $rd__ic, $rd__ie, $rd__iew, $rd__isw, $rd__n, $rd__nic, $rd__nie, $rd__niew, $rd__nisw, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVrfsListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enforce_unique (optional)
     * @param  string[] $export_target Export target (name) (optional)
     * @param  string[] $export_target__n Export target (name) (optional)
     * @param  int[] $export_target_id Export target (optional)
     * @param  int[] $export_target_id__n Export target (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $import_target Import target (name) (optional)
     * @param  string[] $import_target__n Import target (name) (optional)
     * @param  int[] $import_target_id Import target (optional)
     * @param  int[] $import_target_id__n Import target (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rd (optional)
     * @param  bool $rd__empty (optional)
     * @param  string[] $rd__ic (optional)
     * @param  string[] $rd__ie (optional)
     * @param  string[] $rd__iew (optional)
     * @param  string[] $rd__isw (optional)
     * @param  string[] $rd__n (optional)
     * @param  string[] $rd__nic (optional)
     * @param  string[] $rd__nie (optional)
     * @param  string[] $rd__niew (optional)
     * @param  string[] $rd__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enforce_unique = null, $export_target = null, $export_target__n = null, $export_target_id = null, $export_target_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $import_target = null, $import_target__n = null, $import_target_id = null, $import_target_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rd = null, $rd__empty = null, $rd__ic = null, $rd__ie = null, $rd__iew = null, $rd__isw = null, $rd__n = null, $rd__nic = null, $rd__nie = null, $rd__niew = null, $rd__nisw = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamVrfsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedVRFList';
        $request = $this->ipamVrfsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enforce_unique, $export_target, $export_target__n, $export_target_id, $export_target_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $import_target, $import_target__n, $import_target_id, $import_target_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $rd, $rd__empty, $rd__ic, $rd__ie, $rd__iew, $rd__isw, $rd__n, $rd__nic, $rd__nie, $rd__niew, $rd__nisw, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVrfsList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enforce_unique (optional)
     * @param  string[] $export_target Export target (name) (optional)
     * @param  string[] $export_target__n Export target (name) (optional)
     * @param  int[] $export_target_id Export target (optional)
     * @param  int[] $export_target_id__n Export target (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $import_target Import target (name) (optional)
     * @param  string[] $import_target__n Import target (name) (optional)
     * @param  int[] $import_target_id Import target (optional)
     * @param  int[] $import_target_id__n Import target (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $rd (optional)
     * @param  bool $rd__empty (optional)
     * @param  string[] $rd__ic (optional)
     * @param  string[] $rd__ie (optional)
     * @param  string[] $rd__iew (optional)
     * @param  string[] $rd__isw (optional)
     * @param  string[] $rd__n (optional)
     * @param  string[] $rd__nic (optional)
     * @param  string[] $rd__nie (optional)
     * @param  string[] $rd__niew (optional)
     * @param  string[] $rd__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVrfsListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enforce_unique = null, $export_target = null, $export_target__n = null, $export_target_id = null, $export_target_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $import_target = null, $import_target__n = null, $import_target_id = null, $import_target_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $rd = null, $rd__empty = null, $rd__ic = null, $rd__ie = null, $rd__iew = null, $rd__isw = null, $rd__n = null, $rd__nic = null, $rd__nie = null, $rd__niew = null, $rd__nisw = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['ipamVrfsList'][0])
    {


















































































        $resourcePath = '/api/ipam/vrfs/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enforce_unique,
            'enforce_unique', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export_target,
            'export_target', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export_target__n,
            'export_target__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export_target_id,
            'export_target_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export_target_id__n,
            'export_target_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $import_target,
            'import_target', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $import_target__n,
            'import_target__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $import_target_id,
            'import_target_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $import_target_id__n,
            'import_target_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rd,
            'rd', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rd__empty,
            'rd__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rd__ic,
            'rd__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rd__ie,
            'rd__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rd__iew,
            'rd__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rd__isw,
            'rd__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rd__n,
            'rd__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rd__nic,
            'rd__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rd__nie,
            'rd__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rd__niew,
            'rd__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rd__nisw,
            'rd__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVrfsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  \OpenAPI\Client\Model\PatchedVRFRequest $patched_vrf_request patched_vrf_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VRF
     */
    public function ipamVrfsPartialUpdate($id, $patched_vrf_request = null, string $contentType = self::contentTypes['ipamVrfsPartialUpdate'][0])
    {
        list($response) = $this->ipamVrfsPartialUpdateWithHttpInfo($id, $patched_vrf_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVrfsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  \OpenAPI\Client\Model\PatchedVRFRequest $patched_vrf_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VRF, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVrfsPartialUpdateWithHttpInfo($id, $patched_vrf_request = null, string $contentType = self::contentTypes['ipamVrfsPartialUpdate'][0])
    {
        $request = $this->ipamVrfsPartialUpdateRequest($id, $patched_vrf_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VRF' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VRF' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VRF', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VRF';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VRF',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVrfsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  \OpenAPI\Client\Model\PatchedVRFRequest $patched_vrf_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsPartialUpdateAsync($id, $patched_vrf_request = null, string $contentType = self::contentTypes['ipamVrfsPartialUpdate'][0])
    {
        return $this->ipamVrfsPartialUpdateAsyncWithHttpInfo($id, $patched_vrf_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVrfsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  \OpenAPI\Client\Model\PatchedVRFRequest $patched_vrf_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsPartialUpdateAsyncWithHttpInfo($id, $patched_vrf_request = null, string $contentType = self::contentTypes['ipamVrfsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VRF';
        $request = $this->ipamVrfsPartialUpdateRequest($id, $patched_vrf_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVrfsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  \OpenAPI\Client\Model\PatchedVRFRequest $patched_vrf_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVrfsPartialUpdateRequest($id, $patched_vrf_request = null, string $contentType = self::contentTypes['ipamVrfsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVrfsPartialUpdate'
            );
        }



        $resourcePath = '/api/ipam/vrfs/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_vrf_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_vrf_request));
            } else {
                $httpBody = $patched_vrf_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVrfsRetrieve
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VRF
     */
    public function ipamVrfsRetrieve($id, string $contentType = self::contentTypes['ipamVrfsRetrieve'][0])
    {
        list($response) = $this->ipamVrfsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation ipamVrfsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VRF, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVrfsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['ipamVrfsRetrieve'][0])
    {
        $request = $this->ipamVrfsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VRF' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VRF' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VRF', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VRF';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VRF',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVrfsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsRetrieveAsync($id, string $contentType = self::contentTypes['ipamVrfsRetrieve'][0])
    {
        return $this->ipamVrfsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVrfsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['ipamVrfsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VRF';
        $request = $this->ipamVrfsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVrfsRetrieve'
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVrfsRetrieveRequest($id, string $contentType = self::contentTypes['ipamVrfsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVrfsRetrieve'
            );
        }


        $resourcePath = '/api/ipam/vrfs/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipamVrfsUpdate
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  \OpenAPI\Client\Model\VRFRequest $vrf_request vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VRF
     */
    public function ipamVrfsUpdate($id, $vrf_request, string $contentType = self::contentTypes['ipamVrfsUpdate'][0])
    {
        list($response) = $this->ipamVrfsUpdateWithHttpInfo($id, $vrf_request, $contentType);
        return $response;
    }

    /**
     * Operation ipamVrfsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  \OpenAPI\Client\Model\VRFRequest $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VRF, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipamVrfsUpdateWithHttpInfo($id, $vrf_request, string $contentType = self::contentTypes['ipamVrfsUpdate'][0])
    {
        $request = $this->ipamVrfsUpdateRequest($id, $vrf_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VRF' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VRF' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VRF', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VRF';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VRF',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipamVrfsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  \OpenAPI\Client\Model\VRFRequest $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsUpdateAsync($id, $vrf_request, string $contentType = self::contentTypes['ipamVrfsUpdate'][0])
    {
        return $this->ipamVrfsUpdateAsyncWithHttpInfo($id, $vrf_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipamVrfsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  \OpenAPI\Client\Model\VRFRequest $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipamVrfsUpdateAsyncWithHttpInfo($id, $vrf_request, string $contentType = self::contentTypes['ipamVrfsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VRF';
        $request = $this->ipamVrfsUpdateRequest($id, $vrf_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipamVrfsUpdate'
     *
     * @param  int $id A unique integer value identifying this VRF. (required)
     * @param  \OpenAPI\Client\Model\VRFRequest $vrf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ipamVrfsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipamVrfsUpdateRequest($id, $vrf_request, string $contentType = self::contentTypes['ipamVrfsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ipamVrfsUpdate'
            );
        }

        // verify the required parameter 'vrf_request' is set
        if ($vrf_request === null || (is_array($vrf_request) && count($vrf_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vrf_request when calling ipamVrfsUpdate'
            );
        }


        $resourcePath = '/api/ipam/vrfs/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vrf_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vrf_request));
            } else {
                $httpBody = $vrf_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
