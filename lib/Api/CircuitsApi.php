<?php
/**
 * CircuitsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NetBox REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0.8 (4.0)
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.8.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * CircuitsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class CircuitsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'circuitsCircuitTerminationsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitTerminationsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitTerminationsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitTerminationsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitTerminationsDestroy' => [
            'application/json',
        ],
        'circuitsCircuitTerminationsList' => [
            'application/json',
        ],
        'circuitsCircuitTerminationsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitTerminationsPathsRetrieve' => [
            'application/json',
        ],
        'circuitsCircuitTerminationsRetrieve' => [
            'application/json',
        ],
        'circuitsCircuitTerminationsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitTypesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitTypesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitTypesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitTypesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitTypesDestroy' => [
            'application/json',
        ],
        'circuitsCircuitTypesList' => [
            'application/json',
        ],
        'circuitsCircuitTypesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitTypesRetrieve' => [
            'application/json',
        ],
        'circuitsCircuitTypesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitsDestroy' => [
            'application/json',
        ],
        'circuitsCircuitsList' => [
            'application/json',
        ],
        'circuitsCircuitsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsCircuitsRetrieve' => [
            'application/json',
        ],
        'circuitsCircuitsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderAccountsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderAccountsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderAccountsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderAccountsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderAccountsDestroy' => [
            'application/json',
        ],
        'circuitsProviderAccountsList' => [
            'application/json',
        ],
        'circuitsProviderAccountsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderAccountsRetrieve' => [
            'application/json',
        ],
        'circuitsProviderAccountsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderNetworksBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderNetworksBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderNetworksBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderNetworksCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderNetworksDestroy' => [
            'application/json',
        ],
        'circuitsProviderNetworksList' => [
            'application/json',
        ],
        'circuitsProviderNetworksPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProviderNetworksRetrieve' => [
            'application/json',
        ],
        'circuitsProviderNetworksUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProvidersBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProvidersBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProvidersBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProvidersCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProvidersDestroy' => [
            'application/json',
        ],
        'circuitsProvidersList' => [
            'application/json',
        ],
        'circuitsProvidersPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'circuitsProvidersRetrieve' => [
            'application/json',
        ],
        'circuitsProvidersUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation circuitsCircuitTerminationsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsCircuitTerminationsBulkDestroy($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkDestroy'][0])
    {
        $this->circuitsCircuitTerminationsBulkDestroyWithHttpInfo($circuit_termination_request, $contentType);
    }

    /**
     * Operation circuitsCircuitTerminationsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTerminationsBulkDestroyWithHttpInfo($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkDestroy'][0])
    {
        $request = $this->circuitsCircuitTerminationsBulkDestroyRequest($circuit_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTerminationsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsBulkDestroyAsync($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkDestroy'][0])
    {
        return $this->circuitsCircuitTerminationsBulkDestroyAsyncWithHttpInfo($circuit_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTerminationsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsBulkDestroyAsyncWithHttpInfo($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsCircuitTerminationsBulkDestroyRequest($circuit_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTerminationsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTerminationsBulkDestroyRequest($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkDestroy'][0])
    {

        // verify the required parameter 'circuit_termination_request' is set
        if ($circuit_termination_request === null || (is_array($circuit_termination_request) && count($circuit_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_termination_request when calling circuitsCircuitTerminationsBulkDestroy'
            );
        }


        $resourcePath = '/api/circuits/circuit-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_termination_request));
            } else {
                $httpBody = $circuit_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTerminationsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitTermination[]
     */
    public function circuitsCircuitTerminationsBulkPartialUpdate($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkPartialUpdate'][0])
    {
        list($response) = $this->circuitsCircuitTerminationsBulkPartialUpdateWithHttpInfo($circuit_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTerminationsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitTermination[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTerminationsBulkPartialUpdateWithHttpInfo($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkPartialUpdate'][0])
    {
        $request = $this->circuitsCircuitTerminationsBulkPartialUpdateRequest($circuit_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CircuitTermination[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitTermination[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitTermination[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitTermination[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitTermination[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTerminationsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsBulkPartialUpdateAsync($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkPartialUpdate'][0])
    {
        return $this->circuitsCircuitTerminationsBulkPartialUpdateAsyncWithHttpInfo($circuit_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTerminationsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsBulkPartialUpdateAsyncWithHttpInfo($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitTermination[]';
        $request = $this->circuitsCircuitTerminationsBulkPartialUpdateRequest($circuit_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTerminationsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTerminationsBulkPartialUpdateRequest($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'circuit_termination_request' is set
        if ($circuit_termination_request === null || (is_array($circuit_termination_request) && count($circuit_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_termination_request when calling circuitsCircuitTerminationsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/circuits/circuit-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_termination_request));
            } else {
                $httpBody = $circuit_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTerminationsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitTermination[]
     */
    public function circuitsCircuitTerminationsBulkUpdate($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkUpdate'][0])
    {
        list($response) = $this->circuitsCircuitTerminationsBulkUpdateWithHttpInfo($circuit_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTerminationsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitTermination[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTerminationsBulkUpdateWithHttpInfo($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkUpdate'][0])
    {
        $request = $this->circuitsCircuitTerminationsBulkUpdateRequest($circuit_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CircuitTermination[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitTermination[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitTermination[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitTermination[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitTermination[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTerminationsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsBulkUpdateAsync($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkUpdate'][0])
    {
        return $this->circuitsCircuitTerminationsBulkUpdateAsyncWithHttpInfo($circuit_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTerminationsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsBulkUpdateAsyncWithHttpInfo($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitTermination[]';
        $request = $this->circuitsCircuitTerminationsBulkUpdateRequest($circuit_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTerminationsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest[] $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTerminationsBulkUpdateRequest($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsBulkUpdate'][0])
    {

        // verify the required parameter 'circuit_termination_request' is set
        if ($circuit_termination_request === null || (is_array($circuit_termination_request) && count($circuit_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_termination_request when calling circuitsCircuitTerminationsBulkUpdate'
            );
        }


        $resourcePath = '/api/circuits/circuit-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_termination_request));
            } else {
                $httpBody = $circuit_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTerminationsCreate
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest $circuit_termination_request circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitTermination
     */
    public function circuitsCircuitTerminationsCreate($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsCreate'][0])
    {
        list($response) = $this->circuitsCircuitTerminationsCreateWithHttpInfo($circuit_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTerminationsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTerminationsCreateWithHttpInfo($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsCreate'][0])
    {
        $request = $this->circuitsCircuitTerminationsCreateRequest($circuit_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\CircuitTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTerminationsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsCreateAsync($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsCreate'][0])
    {
        return $this->circuitsCircuitTerminationsCreateAsyncWithHttpInfo($circuit_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTerminationsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsCreateAsyncWithHttpInfo($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitTermination';
        $request = $this->circuitsCircuitTerminationsCreateRequest($circuit_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTerminationsCreate'
     *
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTerminationsCreateRequest($circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsCreate'][0])
    {

        // verify the required parameter 'circuit_termination_request' is set
        if ($circuit_termination_request === null || (is_array($circuit_termination_request) && count($circuit_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_termination_request when calling circuitsCircuitTerminationsCreate'
            );
        }


        $resourcePath = '/api/circuits/circuit-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_termination_request));
            } else {
                $httpBody = $circuit_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTerminationsDestroy
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsCircuitTerminationsDestroy($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsDestroy'][0])
    {
        $this->circuitsCircuitTerminationsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation circuitsCircuitTerminationsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTerminationsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsDestroy'][0])
    {
        $request = $this->circuitsCircuitTerminationsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTerminationsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsDestroyAsync($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsDestroy'][0])
    {
        return $this->circuitsCircuitTerminationsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTerminationsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsCircuitTerminationsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTerminationsDestroy'
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTerminationsDestroyRequest($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitTerminationsDestroy'
            );
        }


        $resourcePath = '/api/circuits/circuit-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTerminationsList
     *
     * @param  string $cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B (optional)
     * @param  string $cable_end__n * &#x60;A&#x60; - A * &#x60;B&#x60; - B (optional)
     * @param  int[] $cable_id Cable (ID) (optional)
     * @param  int[] $cable_id__n Cable (ID) (optional)
     * @param  bool $cabled cabled (optional)
     * @param  int[] $circuit_id Circuit (optional)
     * @param  int[] $circuit_id__n Circuit (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_connected mark_connected (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  bool $occupied occupied (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $port_speed port_speed (optional)
     * @param  bool $port_speed__empty port_speed__empty (optional)
     * @param  int[] $port_speed__gt port_speed__gt (optional)
     * @param  int[] $port_speed__gte port_speed__gte (optional)
     * @param  int[] $port_speed__lt port_speed__lt (optional)
     * @param  int[] $port_speed__lte port_speed__lte (optional)
     * @param  int[] $port_speed__n port_speed__n (optional)
     * @param  string[] $pp_info pp_info (optional)
     * @param  bool $pp_info__empty pp_info__empty (optional)
     * @param  string[] $pp_info__ic pp_info__ic (optional)
     * @param  string[] $pp_info__ie pp_info__ie (optional)
     * @param  string[] $pp_info__iew pp_info__iew (optional)
     * @param  string[] $pp_info__isw pp_info__isw (optional)
     * @param  string[] $pp_info__n pp_info__n (optional)
     * @param  string[] $pp_info__nic pp_info__nic (optional)
     * @param  string[] $pp_info__nie pp_info__nie (optional)
     * @param  string[] $pp_info__niew pp_info__niew (optional)
     * @param  string[] $pp_info__nisw pp_info__nisw (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  int[] $provider_network_id ProviderNetwork (ID) (optional)
     * @param  int[] $provider_network_id__n ProviderNetwork (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $term_side * &#x60;A&#x60; - A * &#x60;Z&#x60; - Z (optional)
     * @param  string $term_side__n * &#x60;A&#x60; - A * &#x60;Z&#x60; - Z (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  int[] $upstream_speed upstream_speed (optional)
     * @param  bool $upstream_speed__empty upstream_speed__empty (optional)
     * @param  int[] $upstream_speed__gt upstream_speed__gt (optional)
     * @param  int[] $upstream_speed__gte upstream_speed__gte (optional)
     * @param  int[] $upstream_speed__lt upstream_speed__lt (optional)
     * @param  int[] $upstream_speed__lte upstream_speed__lte (optional)
     * @param  int[] $upstream_speed__n upstream_speed__n (optional)
     * @param  string[] $xconnect_id xconnect_id (optional)
     * @param  bool $xconnect_id__empty xconnect_id__empty (optional)
     * @param  string[] $xconnect_id__ic xconnect_id__ic (optional)
     * @param  string[] $xconnect_id__ie xconnect_id__ie (optional)
     * @param  string[] $xconnect_id__iew xconnect_id__iew (optional)
     * @param  string[] $xconnect_id__isw xconnect_id__isw (optional)
     * @param  string[] $xconnect_id__n xconnect_id__n (optional)
     * @param  string[] $xconnect_id__nic xconnect_id__nic (optional)
     * @param  string[] $xconnect_id__nie xconnect_id__nie (optional)
     * @param  string[] $xconnect_id__niew xconnect_id__niew (optional)
     * @param  string[] $xconnect_id__nisw xconnect_id__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedCircuitTerminationList
     */
    public function circuitsCircuitTerminationsList($cable_end = null, $cable_end__n = null, $cable_id = null, $cable_id__n = null, $cabled = null, $circuit_id = null, $circuit_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_connected = null, $modified_by_request = null, $occupied = null, $offset = null, $ordering = null, $port_speed = null, $port_speed__empty = null, $port_speed__gt = null, $port_speed__gte = null, $port_speed__lt = null, $port_speed__lte = null, $port_speed__n = null, $pp_info = null, $pp_info__empty = null, $pp_info__ic = null, $pp_info__ie = null, $pp_info__iew = null, $pp_info__isw = null, $pp_info__n = null, $pp_info__nic = null, $pp_info__nie = null, $pp_info__niew = null, $pp_info__nisw = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $provider_network_id = null, $provider_network_id__n = null, $q = null, $site = null, $site__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $term_side = null, $term_side__n = null, $updated_by_request = null, $upstream_speed = null, $upstream_speed__empty = null, $upstream_speed__gt = null, $upstream_speed__gte = null, $upstream_speed__lt = null, $upstream_speed__lte = null, $upstream_speed__n = null, $xconnect_id = null, $xconnect_id__empty = null, $xconnect_id__ic = null, $xconnect_id__ie = null, $xconnect_id__iew = null, $xconnect_id__isw = null, $xconnect_id__n = null, $xconnect_id__nic = null, $xconnect_id__nie = null, $xconnect_id__niew = null, $xconnect_id__nisw = null, string $contentType = self::contentTypes['circuitsCircuitTerminationsList'][0])
    {
        list($response) = $this->circuitsCircuitTerminationsListWithHttpInfo($cable_end, $cable_end__n, $cable_id, $cable_id__n, $cabled, $circuit_id, $circuit_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_connected, $modified_by_request, $occupied, $offset, $ordering, $port_speed, $port_speed__empty, $port_speed__gt, $port_speed__gte, $port_speed__lt, $port_speed__lte, $port_speed__n, $pp_info, $pp_info__empty, $pp_info__ic, $pp_info__ie, $pp_info__iew, $pp_info__isw, $pp_info__n, $pp_info__nic, $pp_info__nie, $pp_info__niew, $pp_info__nisw, $provider, $provider__n, $provider_id, $provider_id__n, $provider_network_id, $provider_network_id__n, $q, $site, $site__n, $site_id, $site_id__n, $tag, $tag__n, $term_side, $term_side__n, $updated_by_request, $upstream_speed, $upstream_speed__empty, $upstream_speed__gt, $upstream_speed__gte, $upstream_speed__lt, $upstream_speed__lte, $upstream_speed__n, $xconnect_id, $xconnect_id__empty, $xconnect_id__ic, $xconnect_id__ie, $xconnect_id__iew, $xconnect_id__isw, $xconnect_id__n, $xconnect_id__nic, $xconnect_id__nie, $xconnect_id__niew, $xconnect_id__nisw, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTerminationsListWithHttpInfo
     *
     * @param  string $cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B (optional)
     * @param  string $cable_end__n * &#x60;A&#x60; - A * &#x60;B&#x60; - B (optional)
     * @param  int[] $cable_id Cable (ID) (optional)
     * @param  int[] $cable_id__n Cable (ID) (optional)
     * @param  bool $cabled (optional)
     * @param  int[] $circuit_id Circuit (optional)
     * @param  int[] $circuit_id__n Circuit (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_connected (optional)
     * @param  string $modified_by_request (optional)
     * @param  bool $occupied (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $port_speed (optional)
     * @param  bool $port_speed__empty (optional)
     * @param  int[] $port_speed__gt (optional)
     * @param  int[] $port_speed__gte (optional)
     * @param  int[] $port_speed__lt (optional)
     * @param  int[] $port_speed__lte (optional)
     * @param  int[] $port_speed__n (optional)
     * @param  string[] $pp_info (optional)
     * @param  bool $pp_info__empty (optional)
     * @param  string[] $pp_info__ic (optional)
     * @param  string[] $pp_info__ie (optional)
     * @param  string[] $pp_info__iew (optional)
     * @param  string[] $pp_info__isw (optional)
     * @param  string[] $pp_info__n (optional)
     * @param  string[] $pp_info__nic (optional)
     * @param  string[] $pp_info__nie (optional)
     * @param  string[] $pp_info__niew (optional)
     * @param  string[] $pp_info__nisw (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  int[] $provider_network_id ProviderNetwork (ID) (optional)
     * @param  int[] $provider_network_id__n ProviderNetwork (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $term_side * &#x60;A&#x60; - A * &#x60;Z&#x60; - Z (optional)
     * @param  string $term_side__n * &#x60;A&#x60; - A * &#x60;Z&#x60; - Z (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $upstream_speed (optional)
     * @param  bool $upstream_speed__empty (optional)
     * @param  int[] $upstream_speed__gt (optional)
     * @param  int[] $upstream_speed__gte (optional)
     * @param  int[] $upstream_speed__lt (optional)
     * @param  int[] $upstream_speed__lte (optional)
     * @param  int[] $upstream_speed__n (optional)
     * @param  string[] $xconnect_id (optional)
     * @param  bool $xconnect_id__empty (optional)
     * @param  string[] $xconnect_id__ic (optional)
     * @param  string[] $xconnect_id__ie (optional)
     * @param  string[] $xconnect_id__iew (optional)
     * @param  string[] $xconnect_id__isw (optional)
     * @param  string[] $xconnect_id__n (optional)
     * @param  string[] $xconnect_id__nic (optional)
     * @param  string[] $xconnect_id__nie (optional)
     * @param  string[] $xconnect_id__niew (optional)
     * @param  string[] $xconnect_id__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedCircuitTerminationList, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTerminationsListWithHttpInfo($cable_end = null, $cable_end__n = null, $cable_id = null, $cable_id__n = null, $cabled = null, $circuit_id = null, $circuit_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_connected = null, $modified_by_request = null, $occupied = null, $offset = null, $ordering = null, $port_speed = null, $port_speed__empty = null, $port_speed__gt = null, $port_speed__gte = null, $port_speed__lt = null, $port_speed__lte = null, $port_speed__n = null, $pp_info = null, $pp_info__empty = null, $pp_info__ic = null, $pp_info__ie = null, $pp_info__iew = null, $pp_info__isw = null, $pp_info__n = null, $pp_info__nic = null, $pp_info__nie = null, $pp_info__niew = null, $pp_info__nisw = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $provider_network_id = null, $provider_network_id__n = null, $q = null, $site = null, $site__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $term_side = null, $term_side__n = null, $updated_by_request = null, $upstream_speed = null, $upstream_speed__empty = null, $upstream_speed__gt = null, $upstream_speed__gte = null, $upstream_speed__lt = null, $upstream_speed__lte = null, $upstream_speed__n = null, $xconnect_id = null, $xconnect_id__empty = null, $xconnect_id__ic = null, $xconnect_id__ie = null, $xconnect_id__iew = null, $xconnect_id__isw = null, $xconnect_id__n = null, $xconnect_id__nic = null, $xconnect_id__nie = null, $xconnect_id__niew = null, $xconnect_id__nisw = null, string $contentType = self::contentTypes['circuitsCircuitTerminationsList'][0])
    {
        $request = $this->circuitsCircuitTerminationsListRequest($cable_end, $cable_end__n, $cable_id, $cable_id__n, $cabled, $circuit_id, $circuit_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_connected, $modified_by_request, $occupied, $offset, $ordering, $port_speed, $port_speed__empty, $port_speed__gt, $port_speed__gte, $port_speed__lt, $port_speed__lte, $port_speed__n, $pp_info, $pp_info__empty, $pp_info__ic, $pp_info__ie, $pp_info__iew, $pp_info__isw, $pp_info__n, $pp_info__nic, $pp_info__nie, $pp_info__niew, $pp_info__nisw, $provider, $provider__n, $provider_id, $provider_id__n, $provider_network_id, $provider_network_id__n, $q, $site, $site__n, $site_id, $site_id__n, $tag, $tag__n, $term_side, $term_side__n, $updated_by_request, $upstream_speed, $upstream_speed__empty, $upstream_speed__gt, $upstream_speed__gte, $upstream_speed__lt, $upstream_speed__lte, $upstream_speed__n, $xconnect_id, $xconnect_id__empty, $xconnect_id__ic, $xconnect_id__ie, $xconnect_id__iew, $xconnect_id__isw, $xconnect_id__n, $xconnect_id__nic, $xconnect_id__nie, $xconnect_id__niew, $xconnect_id__nisw, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedCircuitTerminationList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedCircuitTerminationList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedCircuitTerminationList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedCircuitTerminationList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedCircuitTerminationList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTerminationsListAsync
     *
     * @param  string $cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B (optional)
     * @param  string $cable_end__n * &#x60;A&#x60; - A * &#x60;B&#x60; - B (optional)
     * @param  int[] $cable_id Cable (ID) (optional)
     * @param  int[] $cable_id__n Cable (ID) (optional)
     * @param  bool $cabled (optional)
     * @param  int[] $circuit_id Circuit (optional)
     * @param  int[] $circuit_id__n Circuit (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_connected (optional)
     * @param  string $modified_by_request (optional)
     * @param  bool $occupied (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $port_speed (optional)
     * @param  bool $port_speed__empty (optional)
     * @param  int[] $port_speed__gt (optional)
     * @param  int[] $port_speed__gte (optional)
     * @param  int[] $port_speed__lt (optional)
     * @param  int[] $port_speed__lte (optional)
     * @param  int[] $port_speed__n (optional)
     * @param  string[] $pp_info (optional)
     * @param  bool $pp_info__empty (optional)
     * @param  string[] $pp_info__ic (optional)
     * @param  string[] $pp_info__ie (optional)
     * @param  string[] $pp_info__iew (optional)
     * @param  string[] $pp_info__isw (optional)
     * @param  string[] $pp_info__n (optional)
     * @param  string[] $pp_info__nic (optional)
     * @param  string[] $pp_info__nie (optional)
     * @param  string[] $pp_info__niew (optional)
     * @param  string[] $pp_info__nisw (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  int[] $provider_network_id ProviderNetwork (ID) (optional)
     * @param  int[] $provider_network_id__n ProviderNetwork (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $term_side * &#x60;A&#x60; - A * &#x60;Z&#x60; - Z (optional)
     * @param  string $term_side__n * &#x60;A&#x60; - A * &#x60;Z&#x60; - Z (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $upstream_speed (optional)
     * @param  bool $upstream_speed__empty (optional)
     * @param  int[] $upstream_speed__gt (optional)
     * @param  int[] $upstream_speed__gte (optional)
     * @param  int[] $upstream_speed__lt (optional)
     * @param  int[] $upstream_speed__lte (optional)
     * @param  int[] $upstream_speed__n (optional)
     * @param  string[] $xconnect_id (optional)
     * @param  bool $xconnect_id__empty (optional)
     * @param  string[] $xconnect_id__ic (optional)
     * @param  string[] $xconnect_id__ie (optional)
     * @param  string[] $xconnect_id__iew (optional)
     * @param  string[] $xconnect_id__isw (optional)
     * @param  string[] $xconnect_id__n (optional)
     * @param  string[] $xconnect_id__nic (optional)
     * @param  string[] $xconnect_id__nie (optional)
     * @param  string[] $xconnect_id__niew (optional)
     * @param  string[] $xconnect_id__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsListAsync($cable_end = null, $cable_end__n = null, $cable_id = null, $cable_id__n = null, $cabled = null, $circuit_id = null, $circuit_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_connected = null, $modified_by_request = null, $occupied = null, $offset = null, $ordering = null, $port_speed = null, $port_speed__empty = null, $port_speed__gt = null, $port_speed__gte = null, $port_speed__lt = null, $port_speed__lte = null, $port_speed__n = null, $pp_info = null, $pp_info__empty = null, $pp_info__ic = null, $pp_info__ie = null, $pp_info__iew = null, $pp_info__isw = null, $pp_info__n = null, $pp_info__nic = null, $pp_info__nie = null, $pp_info__niew = null, $pp_info__nisw = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $provider_network_id = null, $provider_network_id__n = null, $q = null, $site = null, $site__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $term_side = null, $term_side__n = null, $updated_by_request = null, $upstream_speed = null, $upstream_speed__empty = null, $upstream_speed__gt = null, $upstream_speed__gte = null, $upstream_speed__lt = null, $upstream_speed__lte = null, $upstream_speed__n = null, $xconnect_id = null, $xconnect_id__empty = null, $xconnect_id__ic = null, $xconnect_id__ie = null, $xconnect_id__iew = null, $xconnect_id__isw = null, $xconnect_id__n = null, $xconnect_id__nic = null, $xconnect_id__nie = null, $xconnect_id__niew = null, $xconnect_id__nisw = null, string $contentType = self::contentTypes['circuitsCircuitTerminationsList'][0])
    {
        return $this->circuitsCircuitTerminationsListAsyncWithHttpInfo($cable_end, $cable_end__n, $cable_id, $cable_id__n, $cabled, $circuit_id, $circuit_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_connected, $modified_by_request, $occupied, $offset, $ordering, $port_speed, $port_speed__empty, $port_speed__gt, $port_speed__gte, $port_speed__lt, $port_speed__lte, $port_speed__n, $pp_info, $pp_info__empty, $pp_info__ic, $pp_info__ie, $pp_info__iew, $pp_info__isw, $pp_info__n, $pp_info__nic, $pp_info__nie, $pp_info__niew, $pp_info__nisw, $provider, $provider__n, $provider_id, $provider_id__n, $provider_network_id, $provider_network_id__n, $q, $site, $site__n, $site_id, $site_id__n, $tag, $tag__n, $term_side, $term_side__n, $updated_by_request, $upstream_speed, $upstream_speed__empty, $upstream_speed__gt, $upstream_speed__gte, $upstream_speed__lt, $upstream_speed__lte, $upstream_speed__n, $xconnect_id, $xconnect_id__empty, $xconnect_id__ic, $xconnect_id__ie, $xconnect_id__iew, $xconnect_id__isw, $xconnect_id__n, $xconnect_id__nic, $xconnect_id__nie, $xconnect_id__niew, $xconnect_id__nisw, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTerminationsListAsyncWithHttpInfo
     *
     * @param  string $cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B (optional)
     * @param  string $cable_end__n * &#x60;A&#x60; - A * &#x60;B&#x60; - B (optional)
     * @param  int[] $cable_id Cable (ID) (optional)
     * @param  int[] $cable_id__n Cable (ID) (optional)
     * @param  bool $cabled (optional)
     * @param  int[] $circuit_id Circuit (optional)
     * @param  int[] $circuit_id__n Circuit (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_connected (optional)
     * @param  string $modified_by_request (optional)
     * @param  bool $occupied (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $port_speed (optional)
     * @param  bool $port_speed__empty (optional)
     * @param  int[] $port_speed__gt (optional)
     * @param  int[] $port_speed__gte (optional)
     * @param  int[] $port_speed__lt (optional)
     * @param  int[] $port_speed__lte (optional)
     * @param  int[] $port_speed__n (optional)
     * @param  string[] $pp_info (optional)
     * @param  bool $pp_info__empty (optional)
     * @param  string[] $pp_info__ic (optional)
     * @param  string[] $pp_info__ie (optional)
     * @param  string[] $pp_info__iew (optional)
     * @param  string[] $pp_info__isw (optional)
     * @param  string[] $pp_info__n (optional)
     * @param  string[] $pp_info__nic (optional)
     * @param  string[] $pp_info__nie (optional)
     * @param  string[] $pp_info__niew (optional)
     * @param  string[] $pp_info__nisw (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  int[] $provider_network_id ProviderNetwork (ID) (optional)
     * @param  int[] $provider_network_id__n ProviderNetwork (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $term_side * &#x60;A&#x60; - A * &#x60;Z&#x60; - Z (optional)
     * @param  string $term_side__n * &#x60;A&#x60; - A * &#x60;Z&#x60; - Z (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $upstream_speed (optional)
     * @param  bool $upstream_speed__empty (optional)
     * @param  int[] $upstream_speed__gt (optional)
     * @param  int[] $upstream_speed__gte (optional)
     * @param  int[] $upstream_speed__lt (optional)
     * @param  int[] $upstream_speed__lte (optional)
     * @param  int[] $upstream_speed__n (optional)
     * @param  string[] $xconnect_id (optional)
     * @param  bool $xconnect_id__empty (optional)
     * @param  string[] $xconnect_id__ic (optional)
     * @param  string[] $xconnect_id__ie (optional)
     * @param  string[] $xconnect_id__iew (optional)
     * @param  string[] $xconnect_id__isw (optional)
     * @param  string[] $xconnect_id__n (optional)
     * @param  string[] $xconnect_id__nic (optional)
     * @param  string[] $xconnect_id__nie (optional)
     * @param  string[] $xconnect_id__niew (optional)
     * @param  string[] $xconnect_id__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsListAsyncWithHttpInfo($cable_end = null, $cable_end__n = null, $cable_id = null, $cable_id__n = null, $cabled = null, $circuit_id = null, $circuit_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_connected = null, $modified_by_request = null, $occupied = null, $offset = null, $ordering = null, $port_speed = null, $port_speed__empty = null, $port_speed__gt = null, $port_speed__gte = null, $port_speed__lt = null, $port_speed__lte = null, $port_speed__n = null, $pp_info = null, $pp_info__empty = null, $pp_info__ic = null, $pp_info__ie = null, $pp_info__iew = null, $pp_info__isw = null, $pp_info__n = null, $pp_info__nic = null, $pp_info__nie = null, $pp_info__niew = null, $pp_info__nisw = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $provider_network_id = null, $provider_network_id__n = null, $q = null, $site = null, $site__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $term_side = null, $term_side__n = null, $updated_by_request = null, $upstream_speed = null, $upstream_speed__empty = null, $upstream_speed__gt = null, $upstream_speed__gte = null, $upstream_speed__lt = null, $upstream_speed__lte = null, $upstream_speed__n = null, $xconnect_id = null, $xconnect_id__empty = null, $xconnect_id__ic = null, $xconnect_id__ie = null, $xconnect_id__iew = null, $xconnect_id__isw = null, $xconnect_id__n = null, $xconnect_id__nic = null, $xconnect_id__nie = null, $xconnect_id__niew = null, $xconnect_id__nisw = null, string $contentType = self::contentTypes['circuitsCircuitTerminationsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedCircuitTerminationList';
        $request = $this->circuitsCircuitTerminationsListRequest($cable_end, $cable_end__n, $cable_id, $cable_id__n, $cabled, $circuit_id, $circuit_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mark_connected, $modified_by_request, $occupied, $offset, $ordering, $port_speed, $port_speed__empty, $port_speed__gt, $port_speed__gte, $port_speed__lt, $port_speed__lte, $port_speed__n, $pp_info, $pp_info__empty, $pp_info__ic, $pp_info__ie, $pp_info__iew, $pp_info__isw, $pp_info__n, $pp_info__nic, $pp_info__nie, $pp_info__niew, $pp_info__nisw, $provider, $provider__n, $provider_id, $provider_id__n, $provider_network_id, $provider_network_id__n, $q, $site, $site__n, $site_id, $site_id__n, $tag, $tag__n, $term_side, $term_side__n, $updated_by_request, $upstream_speed, $upstream_speed__empty, $upstream_speed__gt, $upstream_speed__gte, $upstream_speed__lt, $upstream_speed__lte, $upstream_speed__n, $xconnect_id, $xconnect_id__empty, $xconnect_id__ic, $xconnect_id__ie, $xconnect_id__iew, $xconnect_id__isw, $xconnect_id__n, $xconnect_id__nic, $xconnect_id__nie, $xconnect_id__niew, $xconnect_id__nisw, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTerminationsList'
     *
     * @param  string $cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B (optional)
     * @param  string $cable_end__n * &#x60;A&#x60; - A * &#x60;B&#x60; - B (optional)
     * @param  int[] $cable_id Cable (ID) (optional)
     * @param  int[] $cable_id__n Cable (ID) (optional)
     * @param  bool $cabled (optional)
     * @param  int[] $circuit_id Circuit (optional)
     * @param  int[] $circuit_id__n Circuit (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  bool $mark_connected (optional)
     * @param  string $modified_by_request (optional)
     * @param  bool $occupied (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $port_speed (optional)
     * @param  bool $port_speed__empty (optional)
     * @param  int[] $port_speed__gt (optional)
     * @param  int[] $port_speed__gte (optional)
     * @param  int[] $port_speed__lt (optional)
     * @param  int[] $port_speed__lte (optional)
     * @param  int[] $port_speed__n (optional)
     * @param  string[] $pp_info (optional)
     * @param  bool $pp_info__empty (optional)
     * @param  string[] $pp_info__ic (optional)
     * @param  string[] $pp_info__ie (optional)
     * @param  string[] $pp_info__iew (optional)
     * @param  string[] $pp_info__isw (optional)
     * @param  string[] $pp_info__n (optional)
     * @param  string[] $pp_info__nic (optional)
     * @param  string[] $pp_info__nie (optional)
     * @param  string[] $pp_info__niew (optional)
     * @param  string[] $pp_info__nisw (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  int[] $provider_network_id ProviderNetwork (ID) (optional)
     * @param  int[] $provider_network_id__n ProviderNetwork (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $term_side * &#x60;A&#x60; - A * &#x60;Z&#x60; - Z (optional)
     * @param  string $term_side__n * &#x60;A&#x60; - A * &#x60;Z&#x60; - Z (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $upstream_speed (optional)
     * @param  bool $upstream_speed__empty (optional)
     * @param  int[] $upstream_speed__gt (optional)
     * @param  int[] $upstream_speed__gte (optional)
     * @param  int[] $upstream_speed__lt (optional)
     * @param  int[] $upstream_speed__lte (optional)
     * @param  int[] $upstream_speed__n (optional)
     * @param  string[] $xconnect_id (optional)
     * @param  bool $xconnect_id__empty (optional)
     * @param  string[] $xconnect_id__ic (optional)
     * @param  string[] $xconnect_id__ie (optional)
     * @param  string[] $xconnect_id__iew (optional)
     * @param  string[] $xconnect_id__isw (optional)
     * @param  string[] $xconnect_id__n (optional)
     * @param  string[] $xconnect_id__nic (optional)
     * @param  string[] $xconnect_id__nie (optional)
     * @param  string[] $xconnect_id__niew (optional)
     * @param  string[] $xconnect_id__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTerminationsListRequest($cable_end = null, $cable_end__n = null, $cable_id = null, $cable_id__n = null, $cabled = null, $circuit_id = null, $circuit_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mark_connected = null, $modified_by_request = null, $occupied = null, $offset = null, $ordering = null, $port_speed = null, $port_speed__empty = null, $port_speed__gt = null, $port_speed__gte = null, $port_speed__lt = null, $port_speed__lte = null, $port_speed__n = null, $pp_info = null, $pp_info__empty = null, $pp_info__ic = null, $pp_info__ie = null, $pp_info__iew = null, $pp_info__isw = null, $pp_info__n = null, $pp_info__nic = null, $pp_info__nie = null, $pp_info__niew = null, $pp_info__nisw = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $provider_network_id = null, $provider_network_id__n = null, $q = null, $site = null, $site__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $term_side = null, $term_side__n = null, $updated_by_request = null, $upstream_speed = null, $upstream_speed__empty = null, $upstream_speed__gt = null, $upstream_speed__gte = null, $upstream_speed__lt = null, $upstream_speed__lte = null, $upstream_speed__n = null, $xconnect_id = null, $xconnect_id__empty = null, $xconnect_id__ic = null, $xconnect_id__ie = null, $xconnect_id__iew = null, $xconnect_id__isw = null, $xconnect_id__n = null, $xconnect_id__nic = null, $xconnect_id__nie = null, $xconnect_id__niew = null, $xconnect_id__nisw = null, string $contentType = self::contentTypes['circuitsCircuitTerminationsList'][0])
    {




































































































        $resourcePath = '/api/circuits/circuit-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cable_end,
            'cable_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cable_end__n,
            'cable_end__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cable_id,
            'cable_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cable_id__n,
            'cable_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cabled,
            'cabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $circuit_id,
            'circuit_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $circuit_id__n,
            'circuit_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mark_connected,
            'mark_connected', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occupied,
            'occupied', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $port_speed,
            'port_speed', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $port_speed__empty,
            'port_speed__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $port_speed__gt,
            'port_speed__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $port_speed__gte,
            'port_speed__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $port_speed__lt,
            'port_speed__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $port_speed__lte,
            'port_speed__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $port_speed__n,
            'port_speed__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pp_info,
            'pp_info', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pp_info__empty,
            'pp_info__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pp_info__ic,
            'pp_info__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pp_info__ie,
            'pp_info__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pp_info__iew,
            'pp_info__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pp_info__isw,
            'pp_info__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pp_info__n,
            'pp_info__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pp_info__nic,
            'pp_info__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pp_info__nie,
            'pp_info__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pp_info__niew,
            'pp_info__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pp_info__nisw,
            'pp_info__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider,
            'provider', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider__n,
            'provider__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id,
            'provider_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id__n,
            'provider_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_network_id,
            'provider_network_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_network_id__n,
            'provider_network_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site,
            'site', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site__n,
            'site__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id,
            'site_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id__n,
            'site_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $term_side,
            'term_side', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $term_side__n,
            'term_side__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $upstream_speed,
            'upstream_speed', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $upstream_speed__empty,
            'upstream_speed__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $upstream_speed__gt,
            'upstream_speed__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $upstream_speed__gte,
            'upstream_speed__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $upstream_speed__lt,
            'upstream_speed__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $upstream_speed__lte,
            'upstream_speed__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $upstream_speed__n,
            'upstream_speed__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $xconnect_id,
            'xconnect_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $xconnect_id__empty,
            'xconnect_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $xconnect_id__ic,
            'xconnect_id__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $xconnect_id__ie,
            'xconnect_id__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $xconnect_id__iew,
            'xconnect_id__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $xconnect_id__isw,
            'xconnect_id__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $xconnect_id__n,
            'xconnect_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $xconnect_id__nic,
            'xconnect_id__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $xconnect_id__nie,
            'xconnect_id__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $xconnect_id__niew,
            'xconnect_id__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $xconnect_id__nisw,
            'xconnect_id__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTerminationsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedCircuitTerminationRequest $patched_circuit_termination_request patched_circuit_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitTermination
     */
    public function circuitsCircuitTerminationsPartialUpdate($id, $patched_circuit_termination_request = null, string $contentType = self::contentTypes['circuitsCircuitTerminationsPartialUpdate'][0])
    {
        list($response) = $this->circuitsCircuitTerminationsPartialUpdateWithHttpInfo($id, $patched_circuit_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTerminationsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedCircuitTerminationRequest $patched_circuit_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTerminationsPartialUpdateWithHttpInfo($id, $patched_circuit_termination_request = null, string $contentType = self::contentTypes['circuitsCircuitTerminationsPartialUpdate'][0])
    {
        $request = $this->circuitsCircuitTerminationsPartialUpdateRequest($id, $patched_circuit_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CircuitTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTerminationsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedCircuitTerminationRequest $patched_circuit_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsPartialUpdateAsync($id, $patched_circuit_termination_request = null, string $contentType = self::contentTypes['circuitsCircuitTerminationsPartialUpdate'][0])
    {
        return $this->circuitsCircuitTerminationsPartialUpdateAsyncWithHttpInfo($id, $patched_circuit_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTerminationsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedCircuitTerminationRequest $patched_circuit_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsPartialUpdateAsyncWithHttpInfo($id, $patched_circuit_termination_request = null, string $contentType = self::contentTypes['circuitsCircuitTerminationsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitTermination';
        $request = $this->circuitsCircuitTerminationsPartialUpdateRequest($id, $patched_circuit_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTerminationsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedCircuitTerminationRequest $patched_circuit_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTerminationsPartialUpdateRequest($id, $patched_circuit_termination_request = null, string $contentType = self::contentTypes['circuitsCircuitTerminationsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitTerminationsPartialUpdate'
            );
        }



        $resourcePath = '/api/circuits/circuit-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_circuit_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_circuit_termination_request));
            } else {
                $httpBody = $patched_circuit_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTerminationsPathsRetrieve
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsPathsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitTermination
     */
    public function circuitsCircuitTerminationsPathsRetrieve($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsPathsRetrieve'][0])
    {
        list($response) = $this->circuitsCircuitTerminationsPathsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTerminationsPathsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsPathsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTerminationsPathsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsPathsRetrieve'][0])
    {
        $request = $this->circuitsCircuitTerminationsPathsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CircuitTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTerminationsPathsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsPathsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsPathsRetrieveAsync($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsPathsRetrieve'][0])
    {
        return $this->circuitsCircuitTerminationsPathsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTerminationsPathsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsPathsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsPathsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsPathsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitTermination';
        $request = $this->circuitsCircuitTerminationsPathsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTerminationsPathsRetrieve'
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsPathsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTerminationsPathsRetrieveRequest($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsPathsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitTerminationsPathsRetrieve'
            );
        }


        $resourcePath = '/api/circuits/circuit-terminations/{id}/paths/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTerminationsRetrieve
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitTermination
     */
    public function circuitsCircuitTerminationsRetrieve($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsRetrieve'][0])
    {
        list($response) = $this->circuitsCircuitTerminationsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTerminationsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTerminationsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsRetrieve'][0])
    {
        $request = $this->circuitsCircuitTerminationsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CircuitTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTerminationsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsRetrieveAsync($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsRetrieve'][0])
    {
        return $this->circuitsCircuitTerminationsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTerminationsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitTermination';
        $request = $this->circuitsCircuitTerminationsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTerminationsRetrieve'
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTerminationsRetrieveRequest($id, string $contentType = self::contentTypes['circuitsCircuitTerminationsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitTerminationsRetrieve'
            );
        }


        $resourcePath = '/api/circuits/circuit-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTerminationsUpdate
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest $circuit_termination_request circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitTermination
     */
    public function circuitsCircuitTerminationsUpdate($id, $circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsUpdate'][0])
    {
        list($response) = $this->circuitsCircuitTerminationsUpdateWithHttpInfo($id, $circuit_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTerminationsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTerminationsUpdateWithHttpInfo($id, $circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsUpdate'][0])
    {
        $request = $this->circuitsCircuitTerminationsUpdateRequest($id, $circuit_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CircuitTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTerminationsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsUpdateAsync($id, $circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsUpdate'][0])
    {
        return $this->circuitsCircuitTerminationsUpdateAsyncWithHttpInfo($id, $circuit_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTerminationsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTerminationsUpdateAsyncWithHttpInfo($id, $circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitTermination';
        $request = $this->circuitsCircuitTerminationsUpdateRequest($id, $circuit_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTerminationsUpdate'
     *
     * @param  int $id A unique integer value identifying this circuit termination. (required)
     * @param  \OpenAPI\Client\Model\CircuitTerminationRequest $circuit_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTerminationsUpdateRequest($id, $circuit_termination_request, string $contentType = self::contentTypes['circuitsCircuitTerminationsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitTerminationsUpdate'
            );
        }

        // verify the required parameter 'circuit_termination_request' is set
        if ($circuit_termination_request === null || (is_array($circuit_termination_request) && count($circuit_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_termination_request when calling circuitsCircuitTerminationsUpdate'
            );
        }


        $resourcePath = '/api/circuits/circuit-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_termination_request));
            } else {
                $httpBody = $circuit_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTypesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsCircuitTypesBulkDestroy($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkDestroy'][0])
    {
        $this->circuitsCircuitTypesBulkDestroyWithHttpInfo($circuit_type_request, $contentType);
    }

    /**
     * Operation circuitsCircuitTypesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTypesBulkDestroyWithHttpInfo($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkDestroy'][0])
    {
        $request = $this->circuitsCircuitTypesBulkDestroyRequest($circuit_type_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTypesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesBulkDestroyAsync($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkDestroy'][0])
    {
        return $this->circuitsCircuitTypesBulkDestroyAsyncWithHttpInfo($circuit_type_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTypesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesBulkDestroyAsyncWithHttpInfo($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsCircuitTypesBulkDestroyRequest($circuit_type_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTypesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTypesBulkDestroyRequest($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkDestroy'][0])
    {

        // verify the required parameter 'circuit_type_request' is set
        if ($circuit_type_request === null || (is_array($circuit_type_request) && count($circuit_type_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_type_request when calling circuitsCircuitTypesBulkDestroy'
            );
        }


        $resourcePath = '/api/circuits/circuit-types/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_type_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_type_request));
            } else {
                $httpBody = $circuit_type_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTypesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitType[]
     */
    public function circuitsCircuitTypesBulkPartialUpdate($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkPartialUpdate'][0])
    {
        list($response) = $this->circuitsCircuitTypesBulkPartialUpdateWithHttpInfo($circuit_type_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTypesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTypesBulkPartialUpdateWithHttpInfo($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkPartialUpdate'][0])
    {
        $request = $this->circuitsCircuitTypesBulkPartialUpdateRequest($circuit_type_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CircuitType[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitType[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitType[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTypesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesBulkPartialUpdateAsync($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkPartialUpdate'][0])
    {
        return $this->circuitsCircuitTypesBulkPartialUpdateAsyncWithHttpInfo($circuit_type_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTypesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesBulkPartialUpdateAsyncWithHttpInfo($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitType[]';
        $request = $this->circuitsCircuitTypesBulkPartialUpdateRequest($circuit_type_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTypesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTypesBulkPartialUpdateRequest($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'circuit_type_request' is set
        if ($circuit_type_request === null || (is_array($circuit_type_request) && count($circuit_type_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_type_request when calling circuitsCircuitTypesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/circuits/circuit-types/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_type_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_type_request));
            } else {
                $httpBody = $circuit_type_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTypesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitType[]
     */
    public function circuitsCircuitTypesBulkUpdate($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkUpdate'][0])
    {
        list($response) = $this->circuitsCircuitTypesBulkUpdateWithHttpInfo($circuit_type_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTypesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTypesBulkUpdateWithHttpInfo($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkUpdate'][0])
    {
        $request = $this->circuitsCircuitTypesBulkUpdateRequest($circuit_type_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CircuitType[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitType[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitType[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTypesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesBulkUpdateAsync($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkUpdate'][0])
    {
        return $this->circuitsCircuitTypesBulkUpdateAsyncWithHttpInfo($circuit_type_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTypesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesBulkUpdateAsyncWithHttpInfo($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitType[]';
        $request = $this->circuitsCircuitTypesBulkUpdateRequest($circuit_type_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTypesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest[] $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTypesBulkUpdateRequest($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesBulkUpdate'][0])
    {

        // verify the required parameter 'circuit_type_request' is set
        if ($circuit_type_request === null || (is_array($circuit_type_request) && count($circuit_type_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_type_request when calling circuitsCircuitTypesBulkUpdate'
            );
        }


        $resourcePath = '/api/circuits/circuit-types/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_type_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_type_request));
            } else {
                $httpBody = $circuit_type_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTypesCreate
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest $circuit_type_request circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitType
     */
    public function circuitsCircuitTypesCreate($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesCreate'][0])
    {
        list($response) = $this->circuitsCircuitTypesCreateWithHttpInfo($circuit_type_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTypesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitType, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTypesCreateWithHttpInfo($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesCreate'][0])
    {
        $request = $this->circuitsCircuitTypesCreateRequest($circuit_type_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\CircuitType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitType' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTypesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesCreateAsync($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesCreate'][0])
    {
        return $this->circuitsCircuitTypesCreateAsyncWithHttpInfo($circuit_type_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTypesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesCreateAsyncWithHttpInfo($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitType';
        $request = $this->circuitsCircuitTypesCreateRequest($circuit_type_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTypesCreate'
     *
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTypesCreateRequest($circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesCreate'][0])
    {

        // verify the required parameter 'circuit_type_request' is set
        if ($circuit_type_request === null || (is_array($circuit_type_request) && count($circuit_type_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_type_request when calling circuitsCircuitTypesCreate'
            );
        }


        $resourcePath = '/api/circuits/circuit-types/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_type_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_type_request));
            } else {
                $httpBody = $circuit_type_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTypesDestroy
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsCircuitTypesDestroy($id, string $contentType = self::contentTypes['circuitsCircuitTypesDestroy'][0])
    {
        $this->circuitsCircuitTypesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation circuitsCircuitTypesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTypesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitTypesDestroy'][0])
    {
        $request = $this->circuitsCircuitTypesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTypesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesDestroyAsync($id, string $contentType = self::contentTypes['circuitsCircuitTypesDestroy'][0])
    {
        return $this->circuitsCircuitTypesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTypesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitTypesDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsCircuitTypesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTypesDestroy'
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTypesDestroyRequest($id, string $contentType = self::contentTypes['circuitsCircuitTypesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitTypesDestroy'
            );
        }


        $resourcePath = '/api/circuits/circuit-types/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTypesList
     *
     * @param  string[] $color color (optional)
     * @param  bool $color__empty color__empty (optional)
     * @param  string[] $color__ic color__ic (optional)
     * @param  string[] $color__ie color__ie (optional)
     * @param  string[] $color__iew color__iew (optional)
     * @param  string[] $color__isw color__isw (optional)
     * @param  string[] $color__n color__n (optional)
     * @param  string[] $color__nic color__nic (optional)
     * @param  string[] $color__nie color__nie (optional)
     * @param  string[] $color__niew color__niew (optional)
     * @param  string[] $color__nisw color__nisw (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug slug (optional)
     * @param  bool $slug__empty slug__empty (optional)
     * @param  string[] $slug__ic slug__ic (optional)
     * @param  string[] $slug__ie slug__ie (optional)
     * @param  string[] $slug__iew slug__iew (optional)
     * @param  string[] $slug__isw slug__isw (optional)
     * @param  string[] $slug__n slug__n (optional)
     * @param  string[] $slug__nic slug__nic (optional)
     * @param  string[] $slug__nie slug__nie (optional)
     * @param  string[] $slug__niew slug__niew (optional)
     * @param  string[] $slug__nisw slug__nisw (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedCircuitTypeList
     */
    public function circuitsCircuitTypesList($color = null, $color__empty = null, $color__ic = null, $color__ie = null, $color__iew = null, $color__isw = null, $color__n = null, $color__nic = null, $color__nie = null, $color__niew = null, $color__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsCircuitTypesList'][0])
    {
        list($response) = $this->circuitsCircuitTypesListWithHttpInfo($color, $color__empty, $color__ic, $color__ie, $color__iew, $color__isw, $color__n, $color__nic, $color__nie, $color__niew, $color__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTypesListWithHttpInfo
     *
     * @param  string[] $color (optional)
     * @param  bool $color__empty (optional)
     * @param  string[] $color__ic (optional)
     * @param  string[] $color__ie (optional)
     * @param  string[] $color__iew (optional)
     * @param  string[] $color__isw (optional)
     * @param  string[] $color__n (optional)
     * @param  string[] $color__nic (optional)
     * @param  string[] $color__nie (optional)
     * @param  string[] $color__niew (optional)
     * @param  string[] $color__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedCircuitTypeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTypesListWithHttpInfo($color = null, $color__empty = null, $color__ic = null, $color__ie = null, $color__iew = null, $color__isw = null, $color__n = null, $color__nic = null, $color__nie = null, $color__niew = null, $color__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsCircuitTypesList'][0])
    {
        $request = $this->circuitsCircuitTypesListRequest($color, $color__empty, $color__ic, $color__ie, $color__iew, $color__isw, $color__n, $color__nic, $color__nie, $color__niew, $color__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedCircuitTypeList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedCircuitTypeList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedCircuitTypeList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedCircuitTypeList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedCircuitTypeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTypesListAsync
     *
     * @param  string[] $color (optional)
     * @param  bool $color__empty (optional)
     * @param  string[] $color__ic (optional)
     * @param  string[] $color__ie (optional)
     * @param  string[] $color__iew (optional)
     * @param  string[] $color__isw (optional)
     * @param  string[] $color__n (optional)
     * @param  string[] $color__nic (optional)
     * @param  string[] $color__nie (optional)
     * @param  string[] $color__niew (optional)
     * @param  string[] $color__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesListAsync($color = null, $color__empty = null, $color__ic = null, $color__ie = null, $color__iew = null, $color__isw = null, $color__n = null, $color__nic = null, $color__nie = null, $color__niew = null, $color__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsCircuitTypesList'][0])
    {
        return $this->circuitsCircuitTypesListAsyncWithHttpInfo($color, $color__empty, $color__ic, $color__ie, $color__iew, $color__isw, $color__n, $color__nic, $color__nie, $color__niew, $color__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTypesListAsyncWithHttpInfo
     *
     * @param  string[] $color (optional)
     * @param  bool $color__empty (optional)
     * @param  string[] $color__ic (optional)
     * @param  string[] $color__ie (optional)
     * @param  string[] $color__iew (optional)
     * @param  string[] $color__isw (optional)
     * @param  string[] $color__n (optional)
     * @param  string[] $color__nic (optional)
     * @param  string[] $color__nie (optional)
     * @param  string[] $color__niew (optional)
     * @param  string[] $color__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesListAsyncWithHttpInfo($color = null, $color__empty = null, $color__ic = null, $color__ie = null, $color__iew = null, $color__isw = null, $color__n = null, $color__nic = null, $color__nie = null, $color__niew = null, $color__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsCircuitTypesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedCircuitTypeList';
        $request = $this->circuitsCircuitTypesListRequest($color, $color__empty, $color__ic, $color__ie, $color__iew, $color__isw, $color__n, $color__nic, $color__nie, $color__niew, $color__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTypesList'
     *
     * @param  string[] $color (optional)
     * @param  bool $color__empty (optional)
     * @param  string[] $color__ic (optional)
     * @param  string[] $color__ie (optional)
     * @param  string[] $color__iew (optional)
     * @param  string[] $color__isw (optional)
     * @param  string[] $color__n (optional)
     * @param  string[] $color__nic (optional)
     * @param  string[] $color__nie (optional)
     * @param  string[] $color__niew (optional)
     * @param  string[] $color__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTypesListRequest($color = null, $color__empty = null, $color__ic = null, $color__ie = null, $color__iew = null, $color__isw = null, $color__n = null, $color__nic = null, $color__nie = null, $color__niew = null, $color__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsCircuitTypesList'][0])
    {












































































        $resourcePath = '/api/circuits/circuit-types/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color,
            'color', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__empty,
            'color__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__ic,
            'color__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__ie,
            'color__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__iew,
            'color__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__isw,
            'color__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__n,
            'color__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__nic,
            'color__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__nie,
            'color__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__niew,
            'color__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__nisw,
            'color__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__empty,
            'slug__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ic,
            'slug__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ie,
            'slug__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__iew,
            'slug__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__isw,
            'slug__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__n,
            'slug__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nic,
            'slug__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nie,
            'slug__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__niew,
            'slug__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nisw,
            'slug__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTypesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  \OpenAPI\Client\Model\PatchedCircuitTypeRequest $patched_circuit_type_request patched_circuit_type_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitType
     */
    public function circuitsCircuitTypesPartialUpdate($id, $patched_circuit_type_request = null, string $contentType = self::contentTypes['circuitsCircuitTypesPartialUpdate'][0])
    {
        list($response) = $this->circuitsCircuitTypesPartialUpdateWithHttpInfo($id, $patched_circuit_type_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTypesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  \OpenAPI\Client\Model\PatchedCircuitTypeRequest $patched_circuit_type_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitType, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTypesPartialUpdateWithHttpInfo($id, $patched_circuit_type_request = null, string $contentType = self::contentTypes['circuitsCircuitTypesPartialUpdate'][0])
    {
        $request = $this->circuitsCircuitTypesPartialUpdateRequest($id, $patched_circuit_type_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CircuitType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitType' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTypesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  \OpenAPI\Client\Model\PatchedCircuitTypeRequest $patched_circuit_type_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesPartialUpdateAsync($id, $patched_circuit_type_request = null, string $contentType = self::contentTypes['circuitsCircuitTypesPartialUpdate'][0])
    {
        return $this->circuitsCircuitTypesPartialUpdateAsyncWithHttpInfo($id, $patched_circuit_type_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTypesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  \OpenAPI\Client\Model\PatchedCircuitTypeRequest $patched_circuit_type_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesPartialUpdateAsyncWithHttpInfo($id, $patched_circuit_type_request = null, string $contentType = self::contentTypes['circuitsCircuitTypesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitType';
        $request = $this->circuitsCircuitTypesPartialUpdateRequest($id, $patched_circuit_type_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTypesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  \OpenAPI\Client\Model\PatchedCircuitTypeRequest $patched_circuit_type_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTypesPartialUpdateRequest($id, $patched_circuit_type_request = null, string $contentType = self::contentTypes['circuitsCircuitTypesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitTypesPartialUpdate'
            );
        }



        $resourcePath = '/api/circuits/circuit-types/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_circuit_type_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_circuit_type_request));
            } else {
                $httpBody = $patched_circuit_type_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTypesRetrieve
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitType
     */
    public function circuitsCircuitTypesRetrieve($id, string $contentType = self::contentTypes['circuitsCircuitTypesRetrieve'][0])
    {
        list($response) = $this->circuitsCircuitTypesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTypesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitType, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTypesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitTypesRetrieve'][0])
    {
        $request = $this->circuitsCircuitTypesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CircuitType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitType' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTypesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesRetrieveAsync($id, string $contentType = self::contentTypes['circuitsCircuitTypesRetrieve'][0])
    {
        return $this->circuitsCircuitTypesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTypesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitTypesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitType';
        $request = $this->circuitsCircuitTypesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTypesRetrieve'
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTypesRetrieveRequest($id, string $contentType = self::contentTypes['circuitsCircuitTypesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitTypesRetrieve'
            );
        }


        $resourcePath = '/api/circuits/circuit-types/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitTypesUpdate
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest $circuit_type_request circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CircuitType
     */
    public function circuitsCircuitTypesUpdate($id, $circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesUpdate'][0])
    {
        list($response) = $this->circuitsCircuitTypesUpdateWithHttpInfo($id, $circuit_type_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitTypesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CircuitType, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitTypesUpdateWithHttpInfo($id, $circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesUpdate'][0])
    {
        $request = $this->circuitsCircuitTypesUpdateRequest($id, $circuit_type_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CircuitType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CircuitType' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CircuitType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CircuitType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CircuitType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitTypesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesUpdateAsync($id, $circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesUpdate'][0])
    {
        return $this->circuitsCircuitTypesUpdateAsyncWithHttpInfo($id, $circuit_type_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitTypesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitTypesUpdateAsyncWithHttpInfo($id, $circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CircuitType';
        $request = $this->circuitsCircuitTypesUpdateRequest($id, $circuit_type_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitTypesUpdate'
     *
     * @param  int $id A unique integer value identifying this circuit type. (required)
     * @param  \OpenAPI\Client\Model\CircuitTypeRequest $circuit_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitTypesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitTypesUpdateRequest($id, $circuit_type_request, string $contentType = self::contentTypes['circuitsCircuitTypesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitTypesUpdate'
            );
        }

        // verify the required parameter 'circuit_type_request' is set
        if ($circuit_type_request === null || (is_array($circuit_type_request) && count($circuit_type_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_type_request when calling circuitsCircuitTypesUpdate'
            );
        }


        $resourcePath = '/api/circuits/circuit-types/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_type_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_type_request));
            } else {
                $httpBody = $circuit_type_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsCircuitsBulkDestroy($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkDestroy'][0])
    {
        $this->circuitsCircuitsBulkDestroyWithHttpInfo($circuit_request, $contentType);
    }

    /**
     * Operation circuitsCircuitsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitsBulkDestroyWithHttpInfo($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkDestroy'][0])
    {
        $request = $this->circuitsCircuitsBulkDestroyRequest($circuit_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsBulkDestroyAsync($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkDestroy'][0])
    {
        return $this->circuitsCircuitsBulkDestroyAsyncWithHttpInfo($circuit_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsBulkDestroyAsyncWithHttpInfo($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsCircuitsBulkDestroyRequest($circuit_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitsBulkDestroyRequest($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkDestroy'][0])
    {

        // verify the required parameter 'circuit_request' is set
        if ($circuit_request === null || (is_array($circuit_request) && count($circuit_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_request when calling circuitsCircuitsBulkDestroy'
            );
        }


        $resourcePath = '/api/circuits/circuits/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_request));
            } else {
                $httpBody = $circuit_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Circuit[]
     */
    public function circuitsCircuitsBulkPartialUpdate($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkPartialUpdate'][0])
    {
        list($response) = $this->circuitsCircuitsBulkPartialUpdateWithHttpInfo($circuit_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Circuit[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitsBulkPartialUpdateWithHttpInfo($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkPartialUpdate'][0])
    {
        $request = $this->circuitsCircuitsBulkPartialUpdateRequest($circuit_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Circuit[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Circuit[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Circuit[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Circuit[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Circuit[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsBulkPartialUpdateAsync($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkPartialUpdate'][0])
    {
        return $this->circuitsCircuitsBulkPartialUpdateAsyncWithHttpInfo($circuit_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsBulkPartialUpdateAsyncWithHttpInfo($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Circuit[]';
        $request = $this->circuitsCircuitsBulkPartialUpdateRequest($circuit_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitsBulkPartialUpdateRequest($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'circuit_request' is set
        if ($circuit_request === null || (is_array($circuit_request) && count($circuit_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_request when calling circuitsCircuitsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/circuits/circuits/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_request));
            } else {
                $httpBody = $circuit_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Circuit[]
     */
    public function circuitsCircuitsBulkUpdate($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkUpdate'][0])
    {
        list($response) = $this->circuitsCircuitsBulkUpdateWithHttpInfo($circuit_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Circuit[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitsBulkUpdateWithHttpInfo($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkUpdate'][0])
    {
        $request = $this->circuitsCircuitsBulkUpdateRequest($circuit_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Circuit[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Circuit[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Circuit[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Circuit[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Circuit[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsBulkUpdateAsync($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkUpdate'][0])
    {
        return $this->circuitsCircuitsBulkUpdateAsyncWithHttpInfo($circuit_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsBulkUpdateAsyncWithHttpInfo($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Circuit[]';
        $request = $this->circuitsCircuitsBulkUpdateRequest($circuit_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\CircuitRequest[] $circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitsBulkUpdateRequest($circuit_request, string $contentType = self::contentTypes['circuitsCircuitsBulkUpdate'][0])
    {

        // verify the required parameter 'circuit_request' is set
        if ($circuit_request === null || (is_array($circuit_request) && count($circuit_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $circuit_request when calling circuitsCircuitsBulkUpdate'
            );
        }


        $resourcePath = '/api/circuits/circuits/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($circuit_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($circuit_request));
            } else {
                $httpBody = $circuit_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitsCreate
     *
     * @param  \OpenAPI\Client\Model\WritableCircuitRequest $writable_circuit_request writable_circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Circuit
     */
    public function circuitsCircuitsCreate($writable_circuit_request, string $contentType = self::contentTypes['circuitsCircuitsCreate'][0])
    {
        list($response) = $this->circuitsCircuitsCreateWithHttpInfo($writable_circuit_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableCircuitRequest $writable_circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Circuit, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitsCreateWithHttpInfo($writable_circuit_request, string $contentType = self::contentTypes['circuitsCircuitsCreate'][0])
    {
        $request = $this->circuitsCircuitsCreateRequest($writable_circuit_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Circuit' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Circuit' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Circuit', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Circuit';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Circuit',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableCircuitRequest $writable_circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsCreateAsync($writable_circuit_request, string $contentType = self::contentTypes['circuitsCircuitsCreate'][0])
    {
        return $this->circuitsCircuitsCreateAsyncWithHttpInfo($writable_circuit_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableCircuitRequest $writable_circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsCreateAsyncWithHttpInfo($writable_circuit_request, string $contentType = self::contentTypes['circuitsCircuitsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Circuit';
        $request = $this->circuitsCircuitsCreateRequest($writable_circuit_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitsCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableCircuitRequest $writable_circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitsCreateRequest($writable_circuit_request, string $contentType = self::contentTypes['circuitsCircuitsCreate'][0])
    {

        // verify the required parameter 'writable_circuit_request' is set
        if ($writable_circuit_request === null || (is_array($writable_circuit_request) && count($writable_circuit_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_circuit_request when calling circuitsCircuitsCreate'
            );
        }


        $resourcePath = '/api/circuits/circuits/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_circuit_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_circuit_request));
            } else {
                $httpBody = $writable_circuit_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitsDestroy
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsCircuitsDestroy($id, string $contentType = self::contentTypes['circuitsCircuitsDestroy'][0])
    {
        $this->circuitsCircuitsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation circuitsCircuitsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitsDestroy'][0])
    {
        $request = $this->circuitsCircuitsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsDestroyAsync($id, string $contentType = self::contentTypes['circuitsCircuitsDestroy'][0])
    {
        return $this->circuitsCircuitsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitsDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsCircuitsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitsDestroy'
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitsDestroyRequest($id, string $contentType = self::contentTypes['circuitsCircuitsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitsDestroy'
            );
        }


        $resourcePath = '/api/circuits/circuits/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitsList
     *
     * @param  string[] $cid cid (optional)
     * @param  bool $cid__empty cid__empty (optional)
     * @param  string[] $cid__ic cid__ic (optional)
     * @param  string[] $cid__ie cid__ie (optional)
     * @param  string[] $cid__iew cid__iew (optional)
     * @param  string[] $cid__isw cid__isw (optional)
     * @param  string[] $cid__n cid__n (optional)
     * @param  string[] $cid__nic cid__nic (optional)
     * @param  string[] $cid__nie cid__nie (optional)
     * @param  string[] $cid__niew cid__niew (optional)
     * @param  string[] $cid__nisw cid__nisw (optional)
     * @param  int[] $commit_rate commit_rate (optional)
     * @param  bool $commit_rate__empty commit_rate__empty (optional)
     * @param  int[] $commit_rate__gt commit_rate__gt (optional)
     * @param  int[] $commit_rate__gte commit_rate__gte (optional)
     * @param  int[] $commit_rate__lt commit_rate__lt (optional)
     * @param  int[] $commit_rate__lte commit_rate__lte (optional)
     * @param  int[] $commit_rate__n commit_rate__n (optional)
     * @param  int[] $contact Contact (optional)
     * @param  int[] $contact__n Contact (optional)
     * @param  int[] $contact_group Contact group (optional)
     * @param  int[] $contact_group__n Contact group (optional)
     * @param  int[] $contact_role Contact Role (optional)
     * @param  int[] $contact_role__n Contact Role (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $install_date install_date (optional)
     * @param  bool $install_date__empty install_date__empty (optional)
     * @param  \DateTime[] $install_date__gt install_date__gt (optional)
     * @param  \DateTime[] $install_date__gte install_date__gte (optional)
     * @param  \DateTime[] $install_date__lt install_date__lt (optional)
     * @param  \DateTime[] $install_date__lte install_date__lte (optional)
     * @param  \DateTime[] $install_date__n install_date__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  string[] $provider_account Provider account (account) (optional)
     * @param  string[] $provider_account__n Provider account (account) (optional)
     * @param  int[] $provider_account_id Provider account (ID) (optional)
     * @param  int[] $provider_account_id__n Provider account (ID) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  int[] $provider_network_id Provider network (ID) (optional)
     * @param  int[] $provider_network_id__n Provider network (ID) (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status status (optional)
     * @param  string[] $status__n status__n (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  int[] $termination_a_id Termination A (ID) (optional)
     * @param  int[] $termination_a_id__n Termination A (ID) (optional)
     * @param  \DateTime[] $termination_date termination_date (optional)
     * @param  bool $termination_date__empty termination_date__empty (optional)
     * @param  \DateTime[] $termination_date__gt termination_date__gt (optional)
     * @param  \DateTime[] $termination_date__gte termination_date__gte (optional)
     * @param  \DateTime[] $termination_date__lt termination_date__lt (optional)
     * @param  \DateTime[] $termination_date__lte termination_date__lte (optional)
     * @param  \DateTime[] $termination_date__n termination_date__n (optional)
     * @param  int[] $termination_z_id Termination A (ID) (optional)
     * @param  int[] $termination_z_id__n Termination A (ID) (optional)
     * @param  string[] $type Circuit type (slug) (optional)
     * @param  string[] $type__n Circuit type (slug) (optional)
     * @param  int[] $type_id Circuit type (ID) (optional)
     * @param  int[] $type_id__n Circuit type (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedCircuitList
     */
    public function circuitsCircuitsList($cid = null, $cid__empty = null, $cid__ic = null, $cid__ie = null, $cid__iew = null, $cid__isw = null, $cid__n = null, $cid__nic = null, $cid__nie = null, $cid__niew = null, $cid__nisw = null, $commit_rate = null, $commit_rate__empty = null, $commit_rate__gt = null, $commit_rate__gte = null, $commit_rate__lt = null, $commit_rate__lte = null, $commit_rate__n = null, $contact = null, $contact__n = null, $contact_group = null, $contact_group__n = null, $contact_role = null, $contact_role__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $install_date = null, $install_date__empty = null, $install_date__gt = null, $install_date__gte = null, $install_date__lt = null, $install_date__lte = null, $install_date__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_account = null, $provider_account__n = null, $provider_account_id = null, $provider_account_id__n = null, $provider_id = null, $provider_id__n = null, $provider_network_id = null, $provider_network_id__n = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $termination_a_id = null, $termination_a_id__n = null, $termination_date = null, $termination_date__empty = null, $termination_date__gt = null, $termination_date__gte = null, $termination_date__lt = null, $termination_date__lte = null, $termination_date__n = null, $termination_z_id = null, $termination_z_id__n = null, $type = null, $type__n = null, $type_id = null, $type_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsCircuitsList'][0])
    {
        list($response) = $this->circuitsCircuitsListWithHttpInfo($cid, $cid__empty, $cid__ic, $cid__ie, $cid__iew, $cid__isw, $cid__n, $cid__nic, $cid__nie, $cid__niew, $cid__nisw, $commit_rate, $commit_rate__empty, $commit_rate__gt, $commit_rate__gte, $commit_rate__lt, $commit_rate__lte, $commit_rate__n, $contact, $contact__n, $contact_group, $contact_group__n, $contact_role, $contact_role__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $install_date, $install_date__empty, $install_date__gt, $install_date__gte, $install_date__lt, $install_date__lte, $install_date__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $provider, $provider__n, $provider_account, $provider_account__n, $provider_account_id, $provider_account_id__n, $provider_id, $provider_id__n, $provider_network_id, $provider_network_id__n, $q, $region, $region__n, $region_id, $region_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $termination_a_id, $termination_a_id__n, $termination_date, $termination_date__empty, $termination_date__gt, $termination_date__gte, $termination_date__lt, $termination_date__lte, $termination_date__n, $termination_z_id, $termination_z_id__n, $type, $type__n, $type_id, $type_id__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitsListWithHttpInfo
     *
     * @param  string[] $cid (optional)
     * @param  bool $cid__empty (optional)
     * @param  string[] $cid__ic (optional)
     * @param  string[] $cid__ie (optional)
     * @param  string[] $cid__iew (optional)
     * @param  string[] $cid__isw (optional)
     * @param  string[] $cid__n (optional)
     * @param  string[] $cid__nic (optional)
     * @param  string[] $cid__nie (optional)
     * @param  string[] $cid__niew (optional)
     * @param  string[] $cid__nisw (optional)
     * @param  int[] $commit_rate (optional)
     * @param  bool $commit_rate__empty (optional)
     * @param  int[] $commit_rate__gt (optional)
     * @param  int[] $commit_rate__gte (optional)
     * @param  int[] $commit_rate__lt (optional)
     * @param  int[] $commit_rate__lte (optional)
     * @param  int[] $commit_rate__n (optional)
     * @param  int[] $contact Contact (optional)
     * @param  int[] $contact__n Contact (optional)
     * @param  int[] $contact_group Contact group (optional)
     * @param  int[] $contact_group__n Contact group (optional)
     * @param  int[] $contact_role Contact Role (optional)
     * @param  int[] $contact_role__n Contact Role (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $install_date (optional)
     * @param  bool $install_date__empty (optional)
     * @param  \DateTime[] $install_date__gt (optional)
     * @param  \DateTime[] $install_date__gte (optional)
     * @param  \DateTime[] $install_date__lt (optional)
     * @param  \DateTime[] $install_date__lte (optional)
     * @param  \DateTime[] $install_date__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  string[] $provider_account Provider account (account) (optional)
     * @param  string[] $provider_account__n Provider account (account) (optional)
     * @param  int[] $provider_account_id Provider account (ID) (optional)
     * @param  int[] $provider_account_id__n Provider account (ID) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  int[] $provider_network_id Provider network (ID) (optional)
     * @param  int[] $provider_network_id__n Provider network (ID) (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  int[] $termination_a_id Termination A (ID) (optional)
     * @param  int[] $termination_a_id__n Termination A (ID) (optional)
     * @param  \DateTime[] $termination_date (optional)
     * @param  bool $termination_date__empty (optional)
     * @param  \DateTime[] $termination_date__gt (optional)
     * @param  \DateTime[] $termination_date__gte (optional)
     * @param  \DateTime[] $termination_date__lt (optional)
     * @param  \DateTime[] $termination_date__lte (optional)
     * @param  \DateTime[] $termination_date__n (optional)
     * @param  int[] $termination_z_id Termination A (ID) (optional)
     * @param  int[] $termination_z_id__n Termination A (ID) (optional)
     * @param  string[] $type Circuit type (slug) (optional)
     * @param  string[] $type__n Circuit type (slug) (optional)
     * @param  int[] $type_id Circuit type (ID) (optional)
     * @param  int[] $type_id__n Circuit type (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedCircuitList, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitsListWithHttpInfo($cid = null, $cid__empty = null, $cid__ic = null, $cid__ie = null, $cid__iew = null, $cid__isw = null, $cid__n = null, $cid__nic = null, $cid__nie = null, $cid__niew = null, $cid__nisw = null, $commit_rate = null, $commit_rate__empty = null, $commit_rate__gt = null, $commit_rate__gte = null, $commit_rate__lt = null, $commit_rate__lte = null, $commit_rate__n = null, $contact = null, $contact__n = null, $contact_group = null, $contact_group__n = null, $contact_role = null, $contact_role__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $install_date = null, $install_date__empty = null, $install_date__gt = null, $install_date__gte = null, $install_date__lt = null, $install_date__lte = null, $install_date__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_account = null, $provider_account__n = null, $provider_account_id = null, $provider_account_id__n = null, $provider_id = null, $provider_id__n = null, $provider_network_id = null, $provider_network_id__n = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $termination_a_id = null, $termination_a_id__n = null, $termination_date = null, $termination_date__empty = null, $termination_date__gt = null, $termination_date__gte = null, $termination_date__lt = null, $termination_date__lte = null, $termination_date__n = null, $termination_z_id = null, $termination_z_id__n = null, $type = null, $type__n = null, $type_id = null, $type_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsCircuitsList'][0])
    {
        $request = $this->circuitsCircuitsListRequest($cid, $cid__empty, $cid__ic, $cid__ie, $cid__iew, $cid__isw, $cid__n, $cid__nic, $cid__nie, $cid__niew, $cid__nisw, $commit_rate, $commit_rate__empty, $commit_rate__gt, $commit_rate__gte, $commit_rate__lt, $commit_rate__lte, $commit_rate__n, $contact, $contact__n, $contact_group, $contact_group__n, $contact_role, $contact_role__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $install_date, $install_date__empty, $install_date__gt, $install_date__gte, $install_date__lt, $install_date__lte, $install_date__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $provider, $provider__n, $provider_account, $provider_account__n, $provider_account_id, $provider_account_id__n, $provider_id, $provider_id__n, $provider_network_id, $provider_network_id__n, $q, $region, $region__n, $region_id, $region_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $termination_a_id, $termination_a_id__n, $termination_date, $termination_date__empty, $termination_date__gt, $termination_date__gte, $termination_date__lt, $termination_date__lte, $termination_date__n, $termination_z_id, $termination_z_id__n, $type, $type__n, $type_id, $type_id__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedCircuitList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedCircuitList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedCircuitList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedCircuitList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedCircuitList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitsListAsync
     *
     * @param  string[] $cid (optional)
     * @param  bool $cid__empty (optional)
     * @param  string[] $cid__ic (optional)
     * @param  string[] $cid__ie (optional)
     * @param  string[] $cid__iew (optional)
     * @param  string[] $cid__isw (optional)
     * @param  string[] $cid__n (optional)
     * @param  string[] $cid__nic (optional)
     * @param  string[] $cid__nie (optional)
     * @param  string[] $cid__niew (optional)
     * @param  string[] $cid__nisw (optional)
     * @param  int[] $commit_rate (optional)
     * @param  bool $commit_rate__empty (optional)
     * @param  int[] $commit_rate__gt (optional)
     * @param  int[] $commit_rate__gte (optional)
     * @param  int[] $commit_rate__lt (optional)
     * @param  int[] $commit_rate__lte (optional)
     * @param  int[] $commit_rate__n (optional)
     * @param  int[] $contact Contact (optional)
     * @param  int[] $contact__n Contact (optional)
     * @param  int[] $contact_group Contact group (optional)
     * @param  int[] $contact_group__n Contact group (optional)
     * @param  int[] $contact_role Contact Role (optional)
     * @param  int[] $contact_role__n Contact Role (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $install_date (optional)
     * @param  bool $install_date__empty (optional)
     * @param  \DateTime[] $install_date__gt (optional)
     * @param  \DateTime[] $install_date__gte (optional)
     * @param  \DateTime[] $install_date__lt (optional)
     * @param  \DateTime[] $install_date__lte (optional)
     * @param  \DateTime[] $install_date__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  string[] $provider_account Provider account (account) (optional)
     * @param  string[] $provider_account__n Provider account (account) (optional)
     * @param  int[] $provider_account_id Provider account (ID) (optional)
     * @param  int[] $provider_account_id__n Provider account (ID) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  int[] $provider_network_id Provider network (ID) (optional)
     * @param  int[] $provider_network_id__n Provider network (ID) (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  int[] $termination_a_id Termination A (ID) (optional)
     * @param  int[] $termination_a_id__n Termination A (ID) (optional)
     * @param  \DateTime[] $termination_date (optional)
     * @param  bool $termination_date__empty (optional)
     * @param  \DateTime[] $termination_date__gt (optional)
     * @param  \DateTime[] $termination_date__gte (optional)
     * @param  \DateTime[] $termination_date__lt (optional)
     * @param  \DateTime[] $termination_date__lte (optional)
     * @param  \DateTime[] $termination_date__n (optional)
     * @param  int[] $termination_z_id Termination A (ID) (optional)
     * @param  int[] $termination_z_id__n Termination A (ID) (optional)
     * @param  string[] $type Circuit type (slug) (optional)
     * @param  string[] $type__n Circuit type (slug) (optional)
     * @param  int[] $type_id Circuit type (ID) (optional)
     * @param  int[] $type_id__n Circuit type (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsListAsync($cid = null, $cid__empty = null, $cid__ic = null, $cid__ie = null, $cid__iew = null, $cid__isw = null, $cid__n = null, $cid__nic = null, $cid__nie = null, $cid__niew = null, $cid__nisw = null, $commit_rate = null, $commit_rate__empty = null, $commit_rate__gt = null, $commit_rate__gte = null, $commit_rate__lt = null, $commit_rate__lte = null, $commit_rate__n = null, $contact = null, $contact__n = null, $contact_group = null, $contact_group__n = null, $contact_role = null, $contact_role__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $install_date = null, $install_date__empty = null, $install_date__gt = null, $install_date__gte = null, $install_date__lt = null, $install_date__lte = null, $install_date__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_account = null, $provider_account__n = null, $provider_account_id = null, $provider_account_id__n = null, $provider_id = null, $provider_id__n = null, $provider_network_id = null, $provider_network_id__n = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $termination_a_id = null, $termination_a_id__n = null, $termination_date = null, $termination_date__empty = null, $termination_date__gt = null, $termination_date__gte = null, $termination_date__lt = null, $termination_date__lte = null, $termination_date__n = null, $termination_z_id = null, $termination_z_id__n = null, $type = null, $type__n = null, $type_id = null, $type_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsCircuitsList'][0])
    {
        return $this->circuitsCircuitsListAsyncWithHttpInfo($cid, $cid__empty, $cid__ic, $cid__ie, $cid__iew, $cid__isw, $cid__n, $cid__nic, $cid__nie, $cid__niew, $cid__nisw, $commit_rate, $commit_rate__empty, $commit_rate__gt, $commit_rate__gte, $commit_rate__lt, $commit_rate__lte, $commit_rate__n, $contact, $contact__n, $contact_group, $contact_group__n, $contact_role, $contact_role__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $install_date, $install_date__empty, $install_date__gt, $install_date__gte, $install_date__lt, $install_date__lte, $install_date__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $provider, $provider__n, $provider_account, $provider_account__n, $provider_account_id, $provider_account_id__n, $provider_id, $provider_id__n, $provider_network_id, $provider_network_id__n, $q, $region, $region__n, $region_id, $region_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $termination_a_id, $termination_a_id__n, $termination_date, $termination_date__empty, $termination_date__gt, $termination_date__gte, $termination_date__lt, $termination_date__lte, $termination_date__n, $termination_z_id, $termination_z_id__n, $type, $type__n, $type_id, $type_id__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitsListAsyncWithHttpInfo
     *
     * @param  string[] $cid (optional)
     * @param  bool $cid__empty (optional)
     * @param  string[] $cid__ic (optional)
     * @param  string[] $cid__ie (optional)
     * @param  string[] $cid__iew (optional)
     * @param  string[] $cid__isw (optional)
     * @param  string[] $cid__n (optional)
     * @param  string[] $cid__nic (optional)
     * @param  string[] $cid__nie (optional)
     * @param  string[] $cid__niew (optional)
     * @param  string[] $cid__nisw (optional)
     * @param  int[] $commit_rate (optional)
     * @param  bool $commit_rate__empty (optional)
     * @param  int[] $commit_rate__gt (optional)
     * @param  int[] $commit_rate__gte (optional)
     * @param  int[] $commit_rate__lt (optional)
     * @param  int[] $commit_rate__lte (optional)
     * @param  int[] $commit_rate__n (optional)
     * @param  int[] $contact Contact (optional)
     * @param  int[] $contact__n Contact (optional)
     * @param  int[] $contact_group Contact group (optional)
     * @param  int[] $contact_group__n Contact group (optional)
     * @param  int[] $contact_role Contact Role (optional)
     * @param  int[] $contact_role__n Contact Role (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $install_date (optional)
     * @param  bool $install_date__empty (optional)
     * @param  \DateTime[] $install_date__gt (optional)
     * @param  \DateTime[] $install_date__gte (optional)
     * @param  \DateTime[] $install_date__lt (optional)
     * @param  \DateTime[] $install_date__lte (optional)
     * @param  \DateTime[] $install_date__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  string[] $provider_account Provider account (account) (optional)
     * @param  string[] $provider_account__n Provider account (account) (optional)
     * @param  int[] $provider_account_id Provider account (ID) (optional)
     * @param  int[] $provider_account_id__n Provider account (ID) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  int[] $provider_network_id Provider network (ID) (optional)
     * @param  int[] $provider_network_id__n Provider network (ID) (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  int[] $termination_a_id Termination A (ID) (optional)
     * @param  int[] $termination_a_id__n Termination A (ID) (optional)
     * @param  \DateTime[] $termination_date (optional)
     * @param  bool $termination_date__empty (optional)
     * @param  \DateTime[] $termination_date__gt (optional)
     * @param  \DateTime[] $termination_date__gte (optional)
     * @param  \DateTime[] $termination_date__lt (optional)
     * @param  \DateTime[] $termination_date__lte (optional)
     * @param  \DateTime[] $termination_date__n (optional)
     * @param  int[] $termination_z_id Termination A (ID) (optional)
     * @param  int[] $termination_z_id__n Termination A (ID) (optional)
     * @param  string[] $type Circuit type (slug) (optional)
     * @param  string[] $type__n Circuit type (slug) (optional)
     * @param  int[] $type_id Circuit type (ID) (optional)
     * @param  int[] $type_id__n Circuit type (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsListAsyncWithHttpInfo($cid = null, $cid__empty = null, $cid__ic = null, $cid__ie = null, $cid__iew = null, $cid__isw = null, $cid__n = null, $cid__nic = null, $cid__nie = null, $cid__niew = null, $cid__nisw = null, $commit_rate = null, $commit_rate__empty = null, $commit_rate__gt = null, $commit_rate__gte = null, $commit_rate__lt = null, $commit_rate__lte = null, $commit_rate__n = null, $contact = null, $contact__n = null, $contact_group = null, $contact_group__n = null, $contact_role = null, $contact_role__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $install_date = null, $install_date__empty = null, $install_date__gt = null, $install_date__gte = null, $install_date__lt = null, $install_date__lte = null, $install_date__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_account = null, $provider_account__n = null, $provider_account_id = null, $provider_account_id__n = null, $provider_id = null, $provider_id__n = null, $provider_network_id = null, $provider_network_id__n = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $termination_a_id = null, $termination_a_id__n = null, $termination_date = null, $termination_date__empty = null, $termination_date__gt = null, $termination_date__gte = null, $termination_date__lt = null, $termination_date__lte = null, $termination_date__n = null, $termination_z_id = null, $termination_z_id__n = null, $type = null, $type__n = null, $type_id = null, $type_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsCircuitsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedCircuitList';
        $request = $this->circuitsCircuitsListRequest($cid, $cid__empty, $cid__ic, $cid__ie, $cid__iew, $cid__isw, $cid__n, $cid__nic, $cid__nie, $cid__niew, $cid__nisw, $commit_rate, $commit_rate__empty, $commit_rate__gt, $commit_rate__gte, $commit_rate__lt, $commit_rate__lte, $commit_rate__n, $contact, $contact__n, $contact_group, $contact_group__n, $contact_role, $contact_role__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $install_date, $install_date__empty, $install_date__gt, $install_date__gte, $install_date__lt, $install_date__lte, $install_date__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $provider, $provider__n, $provider_account, $provider_account__n, $provider_account_id, $provider_account_id__n, $provider_id, $provider_id__n, $provider_network_id, $provider_network_id__n, $q, $region, $region__n, $region_id, $region_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $termination_a_id, $termination_a_id__n, $termination_date, $termination_date__empty, $termination_date__gt, $termination_date__gte, $termination_date__lt, $termination_date__lte, $termination_date__n, $termination_z_id, $termination_z_id__n, $type, $type__n, $type_id, $type_id__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitsList'
     *
     * @param  string[] $cid (optional)
     * @param  bool $cid__empty (optional)
     * @param  string[] $cid__ic (optional)
     * @param  string[] $cid__ie (optional)
     * @param  string[] $cid__iew (optional)
     * @param  string[] $cid__isw (optional)
     * @param  string[] $cid__n (optional)
     * @param  string[] $cid__nic (optional)
     * @param  string[] $cid__nie (optional)
     * @param  string[] $cid__niew (optional)
     * @param  string[] $cid__nisw (optional)
     * @param  int[] $commit_rate (optional)
     * @param  bool $commit_rate__empty (optional)
     * @param  int[] $commit_rate__gt (optional)
     * @param  int[] $commit_rate__gte (optional)
     * @param  int[] $commit_rate__lt (optional)
     * @param  int[] $commit_rate__lte (optional)
     * @param  int[] $commit_rate__n (optional)
     * @param  int[] $contact Contact (optional)
     * @param  int[] $contact__n Contact (optional)
     * @param  int[] $contact_group Contact group (optional)
     * @param  int[] $contact_group__n Contact group (optional)
     * @param  int[] $contact_role Contact Role (optional)
     * @param  int[] $contact_role__n Contact Role (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $install_date (optional)
     * @param  bool $install_date__empty (optional)
     * @param  \DateTime[] $install_date__gt (optional)
     * @param  \DateTime[] $install_date__gte (optional)
     * @param  \DateTime[] $install_date__lt (optional)
     * @param  \DateTime[] $install_date__lte (optional)
     * @param  \DateTime[] $install_date__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  string[] $provider_account Provider account (account) (optional)
     * @param  string[] $provider_account__n Provider account (account) (optional)
     * @param  int[] $provider_account_id Provider account (ID) (optional)
     * @param  int[] $provider_account_id__n Provider account (ID) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  int[] $provider_network_id Provider network (ID) (optional)
     * @param  int[] $provider_network_id__n Provider network (ID) (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (ID) (optional)
     * @param  int[] $site_id__n Site (ID) (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  int[] $tenant_group Tenant Group (slug) (optional)
     * @param  int[] $tenant_group__n Tenant Group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant Group (ID) (optional)
     * @param  int[] $tenant_group_id__n Tenant Group (ID) (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  int[] $termination_a_id Termination A (ID) (optional)
     * @param  int[] $termination_a_id__n Termination A (ID) (optional)
     * @param  \DateTime[] $termination_date (optional)
     * @param  bool $termination_date__empty (optional)
     * @param  \DateTime[] $termination_date__gt (optional)
     * @param  \DateTime[] $termination_date__gte (optional)
     * @param  \DateTime[] $termination_date__lt (optional)
     * @param  \DateTime[] $termination_date__lte (optional)
     * @param  \DateTime[] $termination_date__n (optional)
     * @param  int[] $termination_z_id Termination A (ID) (optional)
     * @param  int[] $termination_z_id__n Termination A (ID) (optional)
     * @param  string[] $type Circuit type (slug) (optional)
     * @param  string[] $type__n Circuit type (slug) (optional)
     * @param  int[] $type_id Circuit type (ID) (optional)
     * @param  int[] $type_id__n Circuit type (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitsListRequest($cid = null, $cid__empty = null, $cid__ic = null, $cid__ie = null, $cid__iew = null, $cid__isw = null, $cid__n = null, $cid__nic = null, $cid__nie = null, $cid__niew = null, $cid__nisw = null, $commit_rate = null, $commit_rate__empty = null, $commit_rate__gt = null, $commit_rate__gte = null, $commit_rate__lt = null, $commit_rate__lte = null, $commit_rate__n = null, $contact = null, $contact__n = null, $contact_group = null, $contact_group__n = null, $contact_role = null, $contact_role__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $install_date = null, $install_date__empty = null, $install_date__gt = null, $install_date__gte = null, $install_date__lt = null, $install_date__lte = null, $install_date__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_account = null, $provider_account__n = null, $provider_account_id = null, $provider_account_id__n = null, $provider_id = null, $provider_id__n = null, $provider_network_id = null, $provider_network_id__n = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $termination_a_id = null, $termination_a_id__n = null, $termination_date = null, $termination_date__empty = null, $termination_date__gt = null, $termination_date__gte = null, $termination_date__lt = null, $termination_date__lte = null, $termination_date__n = null, $termination_z_id = null, $termination_z_id__n = null, $type = null, $type__n = null, $type_id = null, $type_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsCircuitsList'][0])
    {

























































































































        $resourcePath = '/api/circuits/circuits/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cid,
            'cid', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cid__empty,
            'cid__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cid__ic,
            'cid__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cid__ie,
            'cid__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cid__iew,
            'cid__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cid__isw,
            'cid__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cid__n,
            'cid__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cid__nic,
            'cid__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cid__nie,
            'cid__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cid__niew,
            'cid__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cid__nisw,
            'cid__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commit_rate,
            'commit_rate', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commit_rate__empty,
            'commit_rate__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commit_rate__gt,
            'commit_rate__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commit_rate__gte,
            'commit_rate__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commit_rate__lt,
            'commit_rate__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commit_rate__lte,
            'commit_rate__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commit_rate__n,
            'commit_rate__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact,
            'contact', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact__n,
            'contact__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_group,
            'contact_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_group__n,
            'contact_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_role,
            'contact_role', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_role__n,
            'contact_role__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $install_date,
            'install_date', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $install_date__empty,
            'install_date__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $install_date__gt,
            'install_date__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $install_date__gte,
            'install_date__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $install_date__lt,
            'install_date__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $install_date__lte,
            'install_date__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $install_date__n,
            'install_date__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider,
            'provider', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider__n,
            'provider__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_account,
            'provider_account', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_account__n,
            'provider_account__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_account_id,
            'provider_account_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_account_id__n,
            'provider_account_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id,
            'provider_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id__n,
            'provider_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_network_id,
            'provider_network_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_network_id__n,
            'provider_network_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region,
            'region', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region__n,
            'region__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region_id,
            'region_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region_id__n,
            'region_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site,
            'site', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site__n,
            'site__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group,
            'site_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group__n,
            'site_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group_id,
            'site_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group_id__n,
            'site_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id,
            'site_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id__n,
            'site_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status__n,
            'status__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_a_id,
            'termination_a_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_a_id__n,
            'termination_a_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_date,
            'termination_date', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_date__empty,
            'termination_date__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_date__gt,
            'termination_date__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_date__gte,
            'termination_date__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_date__lt,
            'termination_date__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_date__lte,
            'termination_date__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_date__n,
            'termination_date__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_z_id,
            'termination_z_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_z_id__n,
            'termination_z_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type__n,
            'type__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_id,
            'type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_id__n,
            'type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCircuitRequest $patched_writable_circuit_request patched_writable_circuit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Circuit
     */
    public function circuitsCircuitsPartialUpdate($id, $patched_writable_circuit_request = null, string $contentType = self::contentTypes['circuitsCircuitsPartialUpdate'][0])
    {
        list($response) = $this->circuitsCircuitsPartialUpdateWithHttpInfo($id, $patched_writable_circuit_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCircuitRequest $patched_writable_circuit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Circuit, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitsPartialUpdateWithHttpInfo($id, $patched_writable_circuit_request = null, string $contentType = self::contentTypes['circuitsCircuitsPartialUpdate'][0])
    {
        $request = $this->circuitsCircuitsPartialUpdateRequest($id, $patched_writable_circuit_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Circuit' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Circuit' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Circuit', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Circuit';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Circuit',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCircuitRequest $patched_writable_circuit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsPartialUpdateAsync($id, $patched_writable_circuit_request = null, string $contentType = self::contentTypes['circuitsCircuitsPartialUpdate'][0])
    {
        return $this->circuitsCircuitsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_circuit_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCircuitRequest $patched_writable_circuit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_circuit_request = null, string $contentType = self::contentTypes['circuitsCircuitsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Circuit';
        $request = $this->circuitsCircuitsPartialUpdateRequest($id, $patched_writable_circuit_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCircuitRequest $patched_writable_circuit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitsPartialUpdateRequest($id, $patched_writable_circuit_request = null, string $contentType = self::contentTypes['circuitsCircuitsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitsPartialUpdate'
            );
        }



        $resourcePath = '/api/circuits/circuits/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_circuit_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_circuit_request));
            } else {
                $httpBody = $patched_writable_circuit_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitsRetrieve
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Circuit
     */
    public function circuitsCircuitsRetrieve($id, string $contentType = self::contentTypes['circuitsCircuitsRetrieve'][0])
    {
        list($response) = $this->circuitsCircuitsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Circuit, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitsRetrieve'][0])
    {
        $request = $this->circuitsCircuitsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Circuit' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Circuit' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Circuit', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Circuit';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Circuit',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsRetrieveAsync($id, string $contentType = self::contentTypes['circuitsCircuitsRetrieve'][0])
    {
        return $this->circuitsCircuitsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsCircuitsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Circuit';
        $request = $this->circuitsCircuitsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitsRetrieve'
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitsRetrieveRequest($id, string $contentType = self::contentTypes['circuitsCircuitsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitsRetrieve'
            );
        }


        $resourcePath = '/api/circuits/circuits/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsCircuitsUpdate
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  \OpenAPI\Client\Model\WritableCircuitRequest $writable_circuit_request writable_circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Circuit
     */
    public function circuitsCircuitsUpdate($id, $writable_circuit_request, string $contentType = self::contentTypes['circuitsCircuitsUpdate'][0])
    {
        list($response) = $this->circuitsCircuitsUpdateWithHttpInfo($id, $writable_circuit_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsCircuitsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  \OpenAPI\Client\Model\WritableCircuitRequest $writable_circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Circuit, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsCircuitsUpdateWithHttpInfo($id, $writable_circuit_request, string $contentType = self::contentTypes['circuitsCircuitsUpdate'][0])
    {
        $request = $this->circuitsCircuitsUpdateRequest($id, $writable_circuit_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Circuit' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Circuit' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Circuit', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Circuit';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Circuit',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsCircuitsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  \OpenAPI\Client\Model\WritableCircuitRequest $writable_circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsUpdateAsync($id, $writable_circuit_request, string $contentType = self::contentTypes['circuitsCircuitsUpdate'][0])
    {
        return $this->circuitsCircuitsUpdateAsyncWithHttpInfo($id, $writable_circuit_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsCircuitsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  \OpenAPI\Client\Model\WritableCircuitRequest $writable_circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsCircuitsUpdateAsyncWithHttpInfo($id, $writable_circuit_request, string $contentType = self::contentTypes['circuitsCircuitsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Circuit';
        $request = $this->circuitsCircuitsUpdateRequest($id, $writable_circuit_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsCircuitsUpdate'
     *
     * @param  int $id A unique integer value identifying this circuit. (required)
     * @param  \OpenAPI\Client\Model\WritableCircuitRequest $writable_circuit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsCircuitsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsCircuitsUpdateRequest($id, $writable_circuit_request, string $contentType = self::contentTypes['circuitsCircuitsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsCircuitsUpdate'
            );
        }

        // verify the required parameter 'writable_circuit_request' is set
        if ($writable_circuit_request === null || (is_array($writable_circuit_request) && count($writable_circuit_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_circuit_request when calling circuitsCircuitsUpdate'
            );
        }


        $resourcePath = '/api/circuits/circuits/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_circuit_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_circuit_request));
            } else {
                $httpBody = $writable_circuit_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderAccountsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsProviderAccountsBulkDestroy($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkDestroy'][0])
    {
        $this->circuitsProviderAccountsBulkDestroyWithHttpInfo($provider_account_request, $contentType);
    }

    /**
     * Operation circuitsProviderAccountsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderAccountsBulkDestroyWithHttpInfo($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkDestroy'][0])
    {
        $request = $this->circuitsProviderAccountsBulkDestroyRequest($provider_account_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderAccountsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsBulkDestroyAsync($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkDestroy'][0])
    {
        return $this->circuitsProviderAccountsBulkDestroyAsyncWithHttpInfo($provider_account_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderAccountsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsBulkDestroyAsyncWithHttpInfo($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsProviderAccountsBulkDestroyRequest($provider_account_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderAccountsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderAccountsBulkDestroyRequest($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkDestroy'][0])
    {

        // verify the required parameter 'provider_account_request' is set
        if ($provider_account_request === null || (is_array($provider_account_request) && count($provider_account_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_account_request when calling circuitsProviderAccountsBulkDestroy'
            );
        }


        $resourcePath = '/api/circuits/provider-accounts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_account_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_account_request));
            } else {
                $httpBody = $provider_account_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderAccountsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderAccount[]
     */
    public function circuitsProviderAccountsBulkPartialUpdate($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkPartialUpdate'][0])
    {
        list($response) = $this->circuitsProviderAccountsBulkPartialUpdateWithHttpInfo($provider_account_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderAccountsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderAccount[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderAccountsBulkPartialUpdateWithHttpInfo($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkPartialUpdate'][0])
    {
        $request = $this->circuitsProviderAccountsBulkPartialUpdateRequest($provider_account_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProviderAccount[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderAccount[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderAccount[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderAccount[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderAccount[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderAccountsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsBulkPartialUpdateAsync($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkPartialUpdate'][0])
    {
        return $this->circuitsProviderAccountsBulkPartialUpdateAsyncWithHttpInfo($provider_account_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderAccountsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsBulkPartialUpdateAsyncWithHttpInfo($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderAccount[]';
        $request = $this->circuitsProviderAccountsBulkPartialUpdateRequest($provider_account_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderAccountsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderAccountsBulkPartialUpdateRequest($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'provider_account_request' is set
        if ($provider_account_request === null || (is_array($provider_account_request) && count($provider_account_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_account_request when calling circuitsProviderAccountsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/circuits/provider-accounts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_account_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_account_request));
            } else {
                $httpBody = $provider_account_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderAccountsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderAccount[]
     */
    public function circuitsProviderAccountsBulkUpdate($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkUpdate'][0])
    {
        list($response) = $this->circuitsProviderAccountsBulkUpdateWithHttpInfo($provider_account_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderAccountsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderAccount[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderAccountsBulkUpdateWithHttpInfo($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkUpdate'][0])
    {
        $request = $this->circuitsProviderAccountsBulkUpdateRequest($provider_account_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProviderAccount[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderAccount[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderAccount[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderAccount[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderAccount[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderAccountsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsBulkUpdateAsync($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkUpdate'][0])
    {
        return $this->circuitsProviderAccountsBulkUpdateAsyncWithHttpInfo($provider_account_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderAccountsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsBulkUpdateAsyncWithHttpInfo($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderAccount[]';
        $request = $this->circuitsProviderAccountsBulkUpdateRequest($provider_account_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderAccountsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest[] $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderAccountsBulkUpdateRequest($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsBulkUpdate'][0])
    {

        // verify the required parameter 'provider_account_request' is set
        if ($provider_account_request === null || (is_array($provider_account_request) && count($provider_account_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_account_request when calling circuitsProviderAccountsBulkUpdate'
            );
        }


        $resourcePath = '/api/circuits/provider-accounts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_account_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_account_request));
            } else {
                $httpBody = $provider_account_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderAccountsCreate
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest $provider_account_request provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderAccount
     */
    public function circuitsProviderAccountsCreate($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsCreate'][0])
    {
        list($response) = $this->circuitsProviderAccountsCreateWithHttpInfo($provider_account_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderAccountsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderAccountsCreateWithHttpInfo($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsCreate'][0])
    {
        $request = $this->circuitsProviderAccountsCreateRequest($provider_account_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ProviderAccount' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderAccount' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderAccount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderAccount';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderAccountsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsCreateAsync($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsCreate'][0])
    {
        return $this->circuitsProviderAccountsCreateAsyncWithHttpInfo($provider_account_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderAccountsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsCreateAsyncWithHttpInfo($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderAccount';
        $request = $this->circuitsProviderAccountsCreateRequest($provider_account_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderAccountsCreate'
     *
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderAccountsCreateRequest($provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsCreate'][0])
    {

        // verify the required parameter 'provider_account_request' is set
        if ($provider_account_request === null || (is_array($provider_account_request) && count($provider_account_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_account_request when calling circuitsProviderAccountsCreate'
            );
        }


        $resourcePath = '/api/circuits/provider-accounts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_account_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_account_request));
            } else {
                $httpBody = $provider_account_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderAccountsDestroy
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsProviderAccountsDestroy($id, string $contentType = self::contentTypes['circuitsProviderAccountsDestroy'][0])
    {
        $this->circuitsProviderAccountsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation circuitsProviderAccountsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderAccountsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProviderAccountsDestroy'][0])
    {
        $request = $this->circuitsProviderAccountsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderAccountsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsDestroyAsync($id, string $contentType = self::contentTypes['circuitsProviderAccountsDestroy'][0])
    {
        return $this->circuitsProviderAccountsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderAccountsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProviderAccountsDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsProviderAccountsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderAccountsDestroy'
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderAccountsDestroyRequest($id, string $contentType = self::contentTypes['circuitsProviderAccountsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProviderAccountsDestroy'
            );
        }


        $resourcePath = '/api/circuits/provider-accounts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderAccountsList
     *
     * @param  string[] $account account (optional)
     * @param  bool $account__empty account__empty (optional)
     * @param  string[] $account__ic account__ic (optional)
     * @param  string[] $account__ie account__ie (optional)
     * @param  string[] $account__iew account__iew (optional)
     * @param  string[] $account__isw account__isw (optional)
     * @param  string[] $account__n account__n (optional)
     * @param  string[] $account__nic account__nic (optional)
     * @param  string[] $account__nie account__nie (optional)
     * @param  string[] $account__niew account__niew (optional)
     * @param  string[] $account__nisw account__nisw (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedProviderAccountList
     */
    public function circuitsProviderAccountsList($account = null, $account__empty = null, $account__ic = null, $account__ie = null, $account__iew = null, $account__isw = null, $account__n = null, $account__nic = null, $account__nie = null, $account__niew = null, $account__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProviderAccountsList'][0])
    {
        list($response) = $this->circuitsProviderAccountsListWithHttpInfo($account, $account__empty, $account__ic, $account__ie, $account__iew, $account__isw, $account__n, $account__nic, $account__nie, $account__niew, $account__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderAccountsListWithHttpInfo
     *
     * @param  string[] $account (optional)
     * @param  bool $account__empty (optional)
     * @param  string[] $account__ic (optional)
     * @param  string[] $account__ie (optional)
     * @param  string[] $account__iew (optional)
     * @param  string[] $account__isw (optional)
     * @param  string[] $account__n (optional)
     * @param  string[] $account__nic (optional)
     * @param  string[] $account__nie (optional)
     * @param  string[] $account__niew (optional)
     * @param  string[] $account__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedProviderAccountList, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderAccountsListWithHttpInfo($account = null, $account__empty = null, $account__ic = null, $account__ie = null, $account__iew = null, $account__isw = null, $account__n = null, $account__nic = null, $account__nie = null, $account__niew = null, $account__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProviderAccountsList'][0])
    {
        $request = $this->circuitsProviderAccountsListRequest($account, $account__empty, $account__ic, $account__ie, $account__iew, $account__isw, $account__n, $account__nic, $account__nie, $account__niew, $account__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedProviderAccountList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedProviderAccountList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedProviderAccountList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedProviderAccountList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedProviderAccountList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderAccountsListAsync
     *
     * @param  string[] $account (optional)
     * @param  bool $account__empty (optional)
     * @param  string[] $account__ic (optional)
     * @param  string[] $account__ie (optional)
     * @param  string[] $account__iew (optional)
     * @param  string[] $account__isw (optional)
     * @param  string[] $account__n (optional)
     * @param  string[] $account__nic (optional)
     * @param  string[] $account__nie (optional)
     * @param  string[] $account__niew (optional)
     * @param  string[] $account__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsListAsync($account = null, $account__empty = null, $account__ic = null, $account__ie = null, $account__iew = null, $account__isw = null, $account__n = null, $account__nic = null, $account__nie = null, $account__niew = null, $account__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProviderAccountsList'][0])
    {
        return $this->circuitsProviderAccountsListAsyncWithHttpInfo($account, $account__empty, $account__ic, $account__ie, $account__iew, $account__isw, $account__n, $account__nic, $account__nie, $account__niew, $account__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderAccountsListAsyncWithHttpInfo
     *
     * @param  string[] $account (optional)
     * @param  bool $account__empty (optional)
     * @param  string[] $account__ic (optional)
     * @param  string[] $account__ie (optional)
     * @param  string[] $account__iew (optional)
     * @param  string[] $account__isw (optional)
     * @param  string[] $account__n (optional)
     * @param  string[] $account__nic (optional)
     * @param  string[] $account__nie (optional)
     * @param  string[] $account__niew (optional)
     * @param  string[] $account__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsListAsyncWithHttpInfo($account = null, $account__empty = null, $account__ic = null, $account__ie = null, $account__iew = null, $account__isw = null, $account__n = null, $account__nic = null, $account__nie = null, $account__niew = null, $account__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProviderAccountsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedProviderAccountList';
        $request = $this->circuitsProviderAccountsListRequest($account, $account__empty, $account__ic, $account__ie, $account__iew, $account__isw, $account__n, $account__nic, $account__nie, $account__niew, $account__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderAccountsList'
     *
     * @param  string[] $account (optional)
     * @param  bool $account__empty (optional)
     * @param  string[] $account__ic (optional)
     * @param  string[] $account__ie (optional)
     * @param  string[] $account__iew (optional)
     * @param  string[] $account__isw (optional)
     * @param  string[] $account__n (optional)
     * @param  string[] $account__nic (optional)
     * @param  string[] $account__nie (optional)
     * @param  string[] $account__niew (optional)
     * @param  string[] $account__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderAccountsListRequest($account = null, $account__empty = null, $account__ic = null, $account__ie = null, $account__iew = null, $account__isw = null, $account__n = null, $account__nic = null, $account__nie = null, $account__niew = null, $account__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProviderAccountsList'][0])
    {





































































        $resourcePath = '/api/circuits/provider-accounts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account,
            'account', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account__empty,
            'account__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account__ic,
            'account__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account__ie,
            'account__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account__iew,
            'account__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account__isw,
            'account__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account__n,
            'account__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account__nic,
            'account__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account__nie,
            'account__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account__niew,
            'account__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account__nisw,
            'account__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider,
            'provider', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider__n,
            'provider__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id,
            'provider_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id__n,
            'provider_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderAccountsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderAccountRequest $patched_provider_account_request patched_provider_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderAccount
     */
    public function circuitsProviderAccountsPartialUpdate($id, $patched_provider_account_request = null, string $contentType = self::contentTypes['circuitsProviderAccountsPartialUpdate'][0])
    {
        list($response) = $this->circuitsProviderAccountsPartialUpdateWithHttpInfo($id, $patched_provider_account_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderAccountsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderAccountRequest $patched_provider_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderAccountsPartialUpdateWithHttpInfo($id, $patched_provider_account_request = null, string $contentType = self::contentTypes['circuitsProviderAccountsPartialUpdate'][0])
    {
        $request = $this->circuitsProviderAccountsPartialUpdateRequest($id, $patched_provider_account_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProviderAccount' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderAccount' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderAccount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderAccount';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderAccountsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderAccountRequest $patched_provider_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsPartialUpdateAsync($id, $patched_provider_account_request = null, string $contentType = self::contentTypes['circuitsProviderAccountsPartialUpdate'][0])
    {
        return $this->circuitsProviderAccountsPartialUpdateAsyncWithHttpInfo($id, $patched_provider_account_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderAccountsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderAccountRequest $patched_provider_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsPartialUpdateAsyncWithHttpInfo($id, $patched_provider_account_request = null, string $contentType = self::contentTypes['circuitsProviderAccountsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderAccount';
        $request = $this->circuitsProviderAccountsPartialUpdateRequest($id, $patched_provider_account_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderAccountsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderAccountRequest $patched_provider_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderAccountsPartialUpdateRequest($id, $patched_provider_account_request = null, string $contentType = self::contentTypes['circuitsProviderAccountsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProviderAccountsPartialUpdate'
            );
        }



        $resourcePath = '/api/circuits/provider-accounts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_provider_account_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_provider_account_request));
            } else {
                $httpBody = $patched_provider_account_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderAccountsRetrieve
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderAccount
     */
    public function circuitsProviderAccountsRetrieve($id, string $contentType = self::contentTypes['circuitsProviderAccountsRetrieve'][0])
    {
        list($response) = $this->circuitsProviderAccountsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderAccountsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderAccountsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProviderAccountsRetrieve'][0])
    {
        $request = $this->circuitsProviderAccountsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProviderAccount' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderAccount' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderAccount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderAccount';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderAccountsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsRetrieveAsync($id, string $contentType = self::contentTypes['circuitsProviderAccountsRetrieve'][0])
    {
        return $this->circuitsProviderAccountsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderAccountsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProviderAccountsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderAccount';
        $request = $this->circuitsProviderAccountsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderAccountsRetrieve'
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderAccountsRetrieveRequest($id, string $contentType = self::contentTypes['circuitsProviderAccountsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProviderAccountsRetrieve'
            );
        }


        $resourcePath = '/api/circuits/provider-accounts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderAccountsUpdate
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest $provider_account_request provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderAccount
     */
    public function circuitsProviderAccountsUpdate($id, $provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsUpdate'][0])
    {
        list($response) = $this->circuitsProviderAccountsUpdateWithHttpInfo($id, $provider_account_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderAccountsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderAccountsUpdateWithHttpInfo($id, $provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsUpdate'][0])
    {
        $request = $this->circuitsProviderAccountsUpdateRequest($id, $provider_account_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProviderAccount' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderAccount' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderAccount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderAccount';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderAccountsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsUpdateAsync($id, $provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsUpdate'][0])
    {
        return $this->circuitsProviderAccountsUpdateAsyncWithHttpInfo($id, $provider_account_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderAccountsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderAccountsUpdateAsyncWithHttpInfo($id, $provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderAccount';
        $request = $this->circuitsProviderAccountsUpdateRequest($id, $provider_account_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderAccountsUpdate'
     *
     * @param  int $id A unique integer value identifying this provider account. (required)
     * @param  \OpenAPI\Client\Model\ProviderAccountRequest $provider_account_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderAccountsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderAccountsUpdateRequest($id, $provider_account_request, string $contentType = self::contentTypes['circuitsProviderAccountsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProviderAccountsUpdate'
            );
        }

        // verify the required parameter 'provider_account_request' is set
        if ($provider_account_request === null || (is_array($provider_account_request) && count($provider_account_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_account_request when calling circuitsProviderAccountsUpdate'
            );
        }


        $resourcePath = '/api/circuits/provider-accounts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_account_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_account_request));
            } else {
                $httpBody = $provider_account_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderNetworksBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsProviderNetworksBulkDestroy($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkDestroy'][0])
    {
        $this->circuitsProviderNetworksBulkDestroyWithHttpInfo($provider_network_request, $contentType);
    }

    /**
     * Operation circuitsProviderNetworksBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderNetworksBulkDestroyWithHttpInfo($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkDestroy'][0])
    {
        $request = $this->circuitsProviderNetworksBulkDestroyRequest($provider_network_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderNetworksBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksBulkDestroyAsync($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkDestroy'][0])
    {
        return $this->circuitsProviderNetworksBulkDestroyAsyncWithHttpInfo($provider_network_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderNetworksBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksBulkDestroyAsyncWithHttpInfo($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsProviderNetworksBulkDestroyRequest($provider_network_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderNetworksBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderNetworksBulkDestroyRequest($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkDestroy'][0])
    {

        // verify the required parameter 'provider_network_request' is set
        if ($provider_network_request === null || (is_array($provider_network_request) && count($provider_network_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_network_request when calling circuitsProviderNetworksBulkDestroy'
            );
        }


        $resourcePath = '/api/circuits/provider-networks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_network_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_network_request));
            } else {
                $httpBody = $provider_network_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderNetworksBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderNetwork[]
     */
    public function circuitsProviderNetworksBulkPartialUpdate($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkPartialUpdate'][0])
    {
        list($response) = $this->circuitsProviderNetworksBulkPartialUpdateWithHttpInfo($provider_network_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderNetworksBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderNetwork[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderNetworksBulkPartialUpdateWithHttpInfo($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkPartialUpdate'][0])
    {
        $request = $this->circuitsProviderNetworksBulkPartialUpdateRequest($provider_network_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProviderNetwork[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderNetwork[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderNetwork[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderNetwork[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderNetwork[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderNetworksBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksBulkPartialUpdateAsync($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkPartialUpdate'][0])
    {
        return $this->circuitsProviderNetworksBulkPartialUpdateAsyncWithHttpInfo($provider_network_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderNetworksBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksBulkPartialUpdateAsyncWithHttpInfo($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderNetwork[]';
        $request = $this->circuitsProviderNetworksBulkPartialUpdateRequest($provider_network_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderNetworksBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderNetworksBulkPartialUpdateRequest($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkPartialUpdate'][0])
    {

        // verify the required parameter 'provider_network_request' is set
        if ($provider_network_request === null || (is_array($provider_network_request) && count($provider_network_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_network_request when calling circuitsProviderNetworksBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/circuits/provider-networks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_network_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_network_request));
            } else {
                $httpBody = $provider_network_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderNetworksBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderNetwork[]
     */
    public function circuitsProviderNetworksBulkUpdate($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkUpdate'][0])
    {
        list($response) = $this->circuitsProviderNetworksBulkUpdateWithHttpInfo($provider_network_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderNetworksBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderNetwork[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderNetworksBulkUpdateWithHttpInfo($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkUpdate'][0])
    {
        $request = $this->circuitsProviderNetworksBulkUpdateRequest($provider_network_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProviderNetwork[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderNetwork[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderNetwork[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderNetwork[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderNetwork[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderNetworksBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksBulkUpdateAsync($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkUpdate'][0])
    {
        return $this->circuitsProviderNetworksBulkUpdateAsyncWithHttpInfo($provider_network_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderNetworksBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksBulkUpdateAsyncWithHttpInfo($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderNetwork[]';
        $request = $this->circuitsProviderNetworksBulkUpdateRequest($provider_network_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderNetworksBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest[] $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderNetworksBulkUpdateRequest($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksBulkUpdate'][0])
    {

        // verify the required parameter 'provider_network_request' is set
        if ($provider_network_request === null || (is_array($provider_network_request) && count($provider_network_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_network_request when calling circuitsProviderNetworksBulkUpdate'
            );
        }


        $resourcePath = '/api/circuits/provider-networks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_network_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_network_request));
            } else {
                $httpBody = $provider_network_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderNetworksCreate
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest $provider_network_request provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderNetwork
     */
    public function circuitsProviderNetworksCreate($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksCreate'][0])
    {
        list($response) = $this->circuitsProviderNetworksCreateWithHttpInfo($provider_network_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderNetworksCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderNetworksCreateWithHttpInfo($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksCreate'][0])
    {
        $request = $this->circuitsProviderNetworksCreateRequest($provider_network_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ProviderNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderNetworksCreateAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksCreateAsync($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksCreate'][0])
    {
        return $this->circuitsProviderNetworksCreateAsyncWithHttpInfo($provider_network_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderNetworksCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksCreateAsyncWithHttpInfo($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderNetwork';
        $request = $this->circuitsProviderNetworksCreateRequest($provider_network_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderNetworksCreate'
     *
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderNetworksCreateRequest($provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksCreate'][0])
    {

        // verify the required parameter 'provider_network_request' is set
        if ($provider_network_request === null || (is_array($provider_network_request) && count($provider_network_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_network_request when calling circuitsProviderNetworksCreate'
            );
        }


        $resourcePath = '/api/circuits/provider-networks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_network_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_network_request));
            } else {
                $httpBody = $provider_network_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderNetworksDestroy
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsProviderNetworksDestroy($id, string $contentType = self::contentTypes['circuitsProviderNetworksDestroy'][0])
    {
        $this->circuitsProviderNetworksDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation circuitsProviderNetworksDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderNetworksDestroyWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProviderNetworksDestroy'][0])
    {
        $request = $this->circuitsProviderNetworksDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderNetworksDestroyAsync
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksDestroyAsync($id, string $contentType = self::contentTypes['circuitsProviderNetworksDestroy'][0])
    {
        return $this->circuitsProviderNetworksDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderNetworksDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProviderNetworksDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsProviderNetworksDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderNetworksDestroy'
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderNetworksDestroyRequest($id, string $contentType = self::contentTypes['circuitsProviderNetworksDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProviderNetworksDestroy'
            );
        }


        $resourcePath = '/api/circuits/provider-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderNetworksList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $service_id service_id (optional)
     * @param  bool $service_id__empty service_id__empty (optional)
     * @param  string[] $service_id__ic service_id__ic (optional)
     * @param  string[] $service_id__ie service_id__ie (optional)
     * @param  string[] $service_id__iew service_id__iew (optional)
     * @param  string[] $service_id__isw service_id__isw (optional)
     * @param  string[] $service_id__n service_id__n (optional)
     * @param  string[] $service_id__nic service_id__nic (optional)
     * @param  string[] $service_id__nie service_id__nie (optional)
     * @param  string[] $service_id__niew service_id__niew (optional)
     * @param  string[] $service_id__nisw service_id__nisw (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedProviderNetworkList
     */
    public function circuitsProviderNetworksList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $service_id = null, $service_id__empty = null, $service_id__ic = null, $service_id__ie = null, $service_id__iew = null, $service_id__isw = null, $service_id__n = null, $service_id__nic = null, $service_id__nie = null, $service_id__niew = null, $service_id__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProviderNetworksList'][0])
    {
        list($response) = $this->circuitsProviderNetworksListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $service_id, $service_id__empty, $service_id__ic, $service_id__ie, $service_id__iew, $service_id__isw, $service_id__n, $service_id__nic, $service_id__nie, $service_id__niew, $service_id__nisw, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderNetworksListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $service_id (optional)
     * @param  bool $service_id__empty (optional)
     * @param  string[] $service_id__ic (optional)
     * @param  string[] $service_id__ie (optional)
     * @param  string[] $service_id__iew (optional)
     * @param  string[] $service_id__isw (optional)
     * @param  string[] $service_id__n (optional)
     * @param  string[] $service_id__nic (optional)
     * @param  string[] $service_id__nie (optional)
     * @param  string[] $service_id__niew (optional)
     * @param  string[] $service_id__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedProviderNetworkList, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderNetworksListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $service_id = null, $service_id__empty = null, $service_id__ic = null, $service_id__ie = null, $service_id__iew = null, $service_id__isw = null, $service_id__n = null, $service_id__nic = null, $service_id__nie = null, $service_id__niew = null, $service_id__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProviderNetworksList'][0])
    {
        $request = $this->circuitsProviderNetworksListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $service_id, $service_id__empty, $service_id__ic, $service_id__ie, $service_id__iew, $service_id__isw, $service_id__n, $service_id__nic, $service_id__nie, $service_id__niew, $service_id__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedProviderNetworkList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedProviderNetworkList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedProviderNetworkList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedProviderNetworkList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedProviderNetworkList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderNetworksListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $service_id (optional)
     * @param  bool $service_id__empty (optional)
     * @param  string[] $service_id__ic (optional)
     * @param  string[] $service_id__ie (optional)
     * @param  string[] $service_id__iew (optional)
     * @param  string[] $service_id__isw (optional)
     * @param  string[] $service_id__n (optional)
     * @param  string[] $service_id__nic (optional)
     * @param  string[] $service_id__nie (optional)
     * @param  string[] $service_id__niew (optional)
     * @param  string[] $service_id__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $service_id = null, $service_id__empty = null, $service_id__ic = null, $service_id__ie = null, $service_id__iew = null, $service_id__isw = null, $service_id__n = null, $service_id__nic = null, $service_id__nie = null, $service_id__niew = null, $service_id__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProviderNetworksList'][0])
    {
        return $this->circuitsProviderNetworksListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $service_id, $service_id__empty, $service_id__ic, $service_id__ie, $service_id__iew, $service_id__isw, $service_id__n, $service_id__nic, $service_id__nie, $service_id__niew, $service_id__nisw, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderNetworksListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $service_id (optional)
     * @param  bool $service_id__empty (optional)
     * @param  string[] $service_id__ic (optional)
     * @param  string[] $service_id__ie (optional)
     * @param  string[] $service_id__iew (optional)
     * @param  string[] $service_id__isw (optional)
     * @param  string[] $service_id__n (optional)
     * @param  string[] $service_id__nic (optional)
     * @param  string[] $service_id__nie (optional)
     * @param  string[] $service_id__niew (optional)
     * @param  string[] $service_id__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $service_id = null, $service_id__empty = null, $service_id__ic = null, $service_id__ie = null, $service_id__iew = null, $service_id__isw = null, $service_id__n = null, $service_id__nic = null, $service_id__nie = null, $service_id__niew = null, $service_id__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProviderNetworksList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedProviderNetworkList';
        $request = $this->circuitsProviderNetworksListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $provider, $provider__n, $provider_id, $provider_id__n, $q, $service_id, $service_id__empty, $service_id__ic, $service_id__ie, $service_id__iew, $service_id__isw, $service_id__n, $service_id__nic, $service_id__nie, $service_id__niew, $service_id__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderNetworksList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $provider Provider (slug) (optional)
     * @param  string[] $provider__n Provider (slug) (optional)
     * @param  int[] $provider_id Provider (ID) (optional)
     * @param  int[] $provider_id__n Provider (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $service_id (optional)
     * @param  bool $service_id__empty (optional)
     * @param  string[] $service_id__ic (optional)
     * @param  string[] $service_id__ie (optional)
     * @param  string[] $service_id__iew (optional)
     * @param  string[] $service_id__isw (optional)
     * @param  string[] $service_id__n (optional)
     * @param  string[] $service_id__nic (optional)
     * @param  string[] $service_id__nie (optional)
     * @param  string[] $service_id__niew (optional)
     * @param  string[] $service_id__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderNetworksListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $provider = null, $provider__n = null, $provider_id = null, $provider_id__n = null, $q = null, $service_id = null, $service_id__empty = null, $service_id__ic = null, $service_id__ie = null, $service_id__iew = null, $service_id__isw = null, $service_id__n = null, $service_id__nic = null, $service_id__nie = null, $service_id__niew = null, $service_id__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProviderNetworksList'][0])
    {





































































        $resourcePath = '/api/circuits/provider-networks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider,
            'provider', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider__n,
            'provider__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id,
            'provider_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id__n,
            'provider_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id,
            'service_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id__empty,
            'service_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id__ic,
            'service_id__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id__ie,
            'service_id__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id__iew,
            'service_id__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id__isw,
            'service_id__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id__n,
            'service_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id__nic,
            'service_id__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id__nie,
            'service_id__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id__niew,
            'service_id__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_id__nisw,
            'service_id__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderNetworksPartialUpdate
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderNetworkRequest $patched_provider_network_request patched_provider_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderNetwork
     */
    public function circuitsProviderNetworksPartialUpdate($id, $patched_provider_network_request = null, string $contentType = self::contentTypes['circuitsProviderNetworksPartialUpdate'][0])
    {
        list($response) = $this->circuitsProviderNetworksPartialUpdateWithHttpInfo($id, $patched_provider_network_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderNetworksPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderNetworkRequest $patched_provider_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderNetworksPartialUpdateWithHttpInfo($id, $patched_provider_network_request = null, string $contentType = self::contentTypes['circuitsProviderNetworksPartialUpdate'][0])
    {
        $request = $this->circuitsProviderNetworksPartialUpdateRequest($id, $patched_provider_network_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProviderNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderNetworksPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderNetworkRequest $patched_provider_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksPartialUpdateAsync($id, $patched_provider_network_request = null, string $contentType = self::contentTypes['circuitsProviderNetworksPartialUpdate'][0])
    {
        return $this->circuitsProviderNetworksPartialUpdateAsyncWithHttpInfo($id, $patched_provider_network_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderNetworksPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderNetworkRequest $patched_provider_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksPartialUpdateAsyncWithHttpInfo($id, $patched_provider_network_request = null, string $contentType = self::contentTypes['circuitsProviderNetworksPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderNetwork';
        $request = $this->circuitsProviderNetworksPartialUpdateRequest($id, $patched_provider_network_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderNetworksPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderNetworkRequest $patched_provider_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderNetworksPartialUpdateRequest($id, $patched_provider_network_request = null, string $contentType = self::contentTypes['circuitsProviderNetworksPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProviderNetworksPartialUpdate'
            );
        }



        $resourcePath = '/api/circuits/provider-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_provider_network_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_provider_network_request));
            } else {
                $httpBody = $patched_provider_network_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderNetworksRetrieve
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderNetwork
     */
    public function circuitsProviderNetworksRetrieve($id, string $contentType = self::contentTypes['circuitsProviderNetworksRetrieve'][0])
    {
        list($response) = $this->circuitsProviderNetworksRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderNetworksRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderNetworksRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProviderNetworksRetrieve'][0])
    {
        $request = $this->circuitsProviderNetworksRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProviderNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderNetworksRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksRetrieveAsync($id, string $contentType = self::contentTypes['circuitsProviderNetworksRetrieve'][0])
    {
        return $this->circuitsProviderNetworksRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderNetworksRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProviderNetworksRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderNetwork';
        $request = $this->circuitsProviderNetworksRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderNetworksRetrieve'
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderNetworksRetrieveRequest($id, string $contentType = self::contentTypes['circuitsProviderNetworksRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProviderNetworksRetrieve'
            );
        }


        $resourcePath = '/api/circuits/provider-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProviderNetworksUpdate
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest $provider_network_request provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProviderNetwork
     */
    public function circuitsProviderNetworksUpdate($id, $provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksUpdate'][0])
    {
        list($response) = $this->circuitsProviderNetworksUpdateWithHttpInfo($id, $provider_network_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProviderNetworksUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProviderNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProviderNetworksUpdateWithHttpInfo($id, $provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksUpdate'][0])
    {
        $request = $this->circuitsProviderNetworksUpdateRequest($id, $provider_network_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProviderNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProviderNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProviderNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProviderNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProviderNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProviderNetworksUpdateAsync
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksUpdateAsync($id, $provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksUpdate'][0])
    {
        return $this->circuitsProviderNetworksUpdateAsyncWithHttpInfo($id, $provider_network_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProviderNetworksUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProviderNetworksUpdateAsyncWithHttpInfo($id, $provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProviderNetwork';
        $request = $this->circuitsProviderNetworksUpdateRequest($id, $provider_network_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProviderNetworksUpdate'
     *
     * @param  int $id A unique integer value identifying this provider network. (required)
     * @param  \OpenAPI\Client\Model\ProviderNetworkRequest $provider_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProviderNetworksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProviderNetworksUpdateRequest($id, $provider_network_request, string $contentType = self::contentTypes['circuitsProviderNetworksUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProviderNetworksUpdate'
            );
        }

        // verify the required parameter 'provider_network_request' is set
        if ($provider_network_request === null || (is_array($provider_network_request) && count($provider_network_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_network_request when calling circuitsProviderNetworksUpdate'
            );
        }


        $resourcePath = '/api/circuits/provider-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_network_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_network_request));
            } else {
                $httpBody = $provider_network_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProvidersBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsProvidersBulkDestroy($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkDestroy'][0])
    {
        $this->circuitsProvidersBulkDestroyWithHttpInfo($provider_request, $contentType);
    }

    /**
     * Operation circuitsProvidersBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProvidersBulkDestroyWithHttpInfo($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkDestroy'][0])
    {
        $request = $this->circuitsProvidersBulkDestroyRequest($provider_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProvidersBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersBulkDestroyAsync($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkDestroy'][0])
    {
        return $this->circuitsProvidersBulkDestroyAsyncWithHttpInfo($provider_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProvidersBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersBulkDestroyAsyncWithHttpInfo($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsProvidersBulkDestroyRequest($provider_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProvidersBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProvidersBulkDestroyRequest($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkDestroy'][0])
    {

        // verify the required parameter 'provider_request' is set
        if ($provider_request === null || (is_array($provider_request) && count($provider_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_request when calling circuitsProvidersBulkDestroy'
            );
        }


        $resourcePath = '/api/circuits/providers/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_request));
            } else {
                $httpBody = $provider_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProvidersBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Provider[]
     */
    public function circuitsProvidersBulkPartialUpdate($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkPartialUpdate'][0])
    {
        list($response) = $this->circuitsProvidersBulkPartialUpdateWithHttpInfo($provider_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProvidersBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Provider[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProvidersBulkPartialUpdateWithHttpInfo($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkPartialUpdate'][0])
    {
        $request = $this->circuitsProvidersBulkPartialUpdateRequest($provider_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Provider[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Provider[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Provider[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Provider[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Provider[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProvidersBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersBulkPartialUpdateAsync($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkPartialUpdate'][0])
    {
        return $this->circuitsProvidersBulkPartialUpdateAsyncWithHttpInfo($provider_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProvidersBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersBulkPartialUpdateAsyncWithHttpInfo($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Provider[]';
        $request = $this->circuitsProvidersBulkPartialUpdateRequest($provider_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProvidersBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProvidersBulkPartialUpdateRequest($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkPartialUpdate'][0])
    {

        // verify the required parameter 'provider_request' is set
        if ($provider_request === null || (is_array($provider_request) && count($provider_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_request when calling circuitsProvidersBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/circuits/providers/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_request));
            } else {
                $httpBody = $provider_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProvidersBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Provider[]
     */
    public function circuitsProvidersBulkUpdate($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkUpdate'][0])
    {
        list($response) = $this->circuitsProvidersBulkUpdateWithHttpInfo($provider_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProvidersBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Provider[], HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProvidersBulkUpdateWithHttpInfo($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkUpdate'][0])
    {
        $request = $this->circuitsProvidersBulkUpdateRequest($provider_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Provider[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Provider[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Provider[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Provider[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Provider[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProvidersBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersBulkUpdateAsync($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkUpdate'][0])
    {
        return $this->circuitsProvidersBulkUpdateAsyncWithHttpInfo($provider_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProvidersBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersBulkUpdateAsyncWithHttpInfo($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Provider[]';
        $request = $this->circuitsProvidersBulkUpdateRequest($provider_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProvidersBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest[] $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProvidersBulkUpdateRequest($provider_request, string $contentType = self::contentTypes['circuitsProvidersBulkUpdate'][0])
    {

        // verify the required parameter 'provider_request' is set
        if ($provider_request === null || (is_array($provider_request) && count($provider_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_request when calling circuitsProvidersBulkUpdate'
            );
        }


        $resourcePath = '/api/circuits/providers/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_request));
            } else {
                $httpBody = $provider_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProvidersCreate
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest $provider_request provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Provider
     */
    public function circuitsProvidersCreate($provider_request, string $contentType = self::contentTypes['circuitsProvidersCreate'][0])
    {
        list($response) = $this->circuitsProvidersCreateWithHttpInfo($provider_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProvidersCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Provider, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProvidersCreateWithHttpInfo($provider_request, string $contentType = self::contentTypes['circuitsProvidersCreate'][0])
    {
        $request = $this->circuitsProvidersCreateRequest($provider_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Provider' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Provider' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Provider', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Provider';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Provider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProvidersCreateAsync
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersCreateAsync($provider_request, string $contentType = self::contentTypes['circuitsProvidersCreate'][0])
    {
        return $this->circuitsProvidersCreateAsyncWithHttpInfo($provider_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProvidersCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersCreateAsyncWithHttpInfo($provider_request, string $contentType = self::contentTypes['circuitsProvidersCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Provider';
        $request = $this->circuitsProvidersCreateRequest($provider_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProvidersCreate'
     *
     * @param  \OpenAPI\Client\Model\ProviderRequest $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProvidersCreateRequest($provider_request, string $contentType = self::contentTypes['circuitsProvidersCreate'][0])
    {

        // verify the required parameter 'provider_request' is set
        if ($provider_request === null || (is_array($provider_request) && count($provider_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_request when calling circuitsProvidersCreate'
            );
        }


        $resourcePath = '/api/circuits/providers/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_request));
            } else {
                $httpBody = $provider_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProvidersDestroy
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function circuitsProvidersDestroy($id, string $contentType = self::contentTypes['circuitsProvidersDestroy'][0])
    {
        $this->circuitsProvidersDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation circuitsProvidersDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProvidersDestroyWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProvidersDestroy'][0])
    {
        $request = $this->circuitsProvidersDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProvidersDestroyAsync
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersDestroyAsync($id, string $contentType = self::contentTypes['circuitsProvidersDestroy'][0])
    {
        return $this->circuitsProvidersDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProvidersDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProvidersDestroy'][0])
    {
        $returnType = '';
        $request = $this->circuitsProvidersDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProvidersDestroy'
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProvidersDestroyRequest($id, string $contentType = self::contentTypes['circuitsProvidersDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProvidersDestroy'
            );
        }


        $resourcePath = '/api/circuits/providers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProvidersList
     *
     * @param  int[] $asn ASN (optional)
     * @param  int[] $asn__n ASN (optional)
     * @param  int[] $asn_id ASN (ID) (optional)
     * @param  int[] $asn_id__n ASN (ID) (optional)
     * @param  int[] $contact Contact (optional)
     * @param  int[] $contact__n Contact (optional)
     * @param  int[] $contact_group Contact group (optional)
     * @param  int[] $contact_group__n Contact group (optional)
     * @param  int[] $contact_role Contact Role (optional)
     * @param  int[] $contact_role__n Contact Role (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (optional)
     * @param  int[] $site_id__n Site (optional)
     * @param  string[] $slug slug (optional)
     * @param  bool $slug__empty slug__empty (optional)
     * @param  string[] $slug__ic slug__ic (optional)
     * @param  string[] $slug__ie slug__ie (optional)
     * @param  string[] $slug__iew slug__iew (optional)
     * @param  string[] $slug__isw slug__isw (optional)
     * @param  string[] $slug__n slug__n (optional)
     * @param  string[] $slug__nic slug__nic (optional)
     * @param  string[] $slug__nie slug__nie (optional)
     * @param  string[] $slug__niew slug__niew (optional)
     * @param  string[] $slug__nisw slug__nisw (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedProviderList
     */
    public function circuitsProvidersList($asn = null, $asn__n = null, $asn_id = null, $asn_id__n = null, $contact = null, $contact__n = null, $contact_group = null, $contact_group__n = null, $contact_role = null, $contact_role__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProvidersList'][0])
    {
        list($response) = $this->circuitsProvidersListWithHttpInfo($asn, $asn__n, $asn_id, $asn_id__n, $contact, $contact__n, $contact_group, $contact_group__n, $contact_role, $contact_role__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $region, $region__n, $region_id, $region_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProvidersListWithHttpInfo
     *
     * @param  int[] $asn ASN (optional)
     * @param  int[] $asn__n ASN (optional)
     * @param  int[] $asn_id ASN (ID) (optional)
     * @param  int[] $asn_id__n ASN (ID) (optional)
     * @param  int[] $contact Contact (optional)
     * @param  int[] $contact__n Contact (optional)
     * @param  int[] $contact_group Contact group (optional)
     * @param  int[] $contact_group__n Contact group (optional)
     * @param  int[] $contact_role Contact Role (optional)
     * @param  int[] $contact_role__n Contact Role (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (optional)
     * @param  int[] $site_id__n Site (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedProviderList, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProvidersListWithHttpInfo($asn = null, $asn__n = null, $asn_id = null, $asn_id__n = null, $contact = null, $contact__n = null, $contact_group = null, $contact_group__n = null, $contact_role = null, $contact_role__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProvidersList'][0])
    {
        $request = $this->circuitsProvidersListRequest($asn, $asn__n, $asn_id, $asn_id__n, $contact, $contact__n, $contact_group, $contact_group__n, $contact_role, $contact_role__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $region, $region__n, $region_id, $region_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedProviderList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedProviderList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedProviderList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedProviderList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedProviderList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProvidersListAsync
     *
     * @param  int[] $asn ASN (optional)
     * @param  int[] $asn__n ASN (optional)
     * @param  int[] $asn_id ASN (ID) (optional)
     * @param  int[] $asn_id__n ASN (ID) (optional)
     * @param  int[] $contact Contact (optional)
     * @param  int[] $contact__n Contact (optional)
     * @param  int[] $contact_group Contact group (optional)
     * @param  int[] $contact_group__n Contact group (optional)
     * @param  int[] $contact_role Contact Role (optional)
     * @param  int[] $contact_role__n Contact Role (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (optional)
     * @param  int[] $site_id__n Site (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersListAsync($asn = null, $asn__n = null, $asn_id = null, $asn_id__n = null, $contact = null, $contact__n = null, $contact_group = null, $contact_group__n = null, $contact_role = null, $contact_role__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProvidersList'][0])
    {
        return $this->circuitsProvidersListAsyncWithHttpInfo($asn, $asn__n, $asn_id, $asn_id__n, $contact, $contact__n, $contact_group, $contact_group__n, $contact_role, $contact_role__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $region, $region__n, $region_id, $region_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProvidersListAsyncWithHttpInfo
     *
     * @param  int[] $asn ASN (optional)
     * @param  int[] $asn__n ASN (optional)
     * @param  int[] $asn_id ASN (ID) (optional)
     * @param  int[] $asn_id__n ASN (ID) (optional)
     * @param  int[] $contact Contact (optional)
     * @param  int[] $contact__n Contact (optional)
     * @param  int[] $contact_group Contact group (optional)
     * @param  int[] $contact_group__n Contact group (optional)
     * @param  int[] $contact_role Contact Role (optional)
     * @param  int[] $contact_role__n Contact Role (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (optional)
     * @param  int[] $site_id__n Site (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersListAsyncWithHttpInfo($asn = null, $asn__n = null, $asn_id = null, $asn_id__n = null, $contact = null, $contact__n = null, $contact_group = null, $contact_group__n = null, $contact_role = null, $contact_role__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProvidersList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedProviderList';
        $request = $this->circuitsProvidersListRequest($asn, $asn__n, $asn_id, $asn_id__n, $contact, $contact__n, $contact_group, $contact_group__n, $contact_role, $contact_role__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $region, $region__n, $region_id, $region_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProvidersList'
     *
     * @param  int[] $asn ASN (optional)
     * @param  int[] $asn__n ASN (optional)
     * @param  int[] $asn_id ASN (ID) (optional)
     * @param  int[] $asn_id__n ASN (ID) (optional)
     * @param  int[] $contact Contact (optional)
     * @param  int[] $contact__n Contact (optional)
     * @param  int[] $contact_group Contact group (optional)
     * @param  int[] $contact_group__n Contact group (optional)
     * @param  int[] $contact_role Contact Role (optional)
     * @param  int[] $contact_role__n Contact Role (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $region Region (slug) (optional)
     * @param  int[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (ID) (optional)
     * @param  int[] $region_id__n Region (ID) (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  int[] $site_group Site group (slug) (optional)
     * @param  int[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (ID) (optional)
     * @param  int[] $site_group_id__n Site group (ID) (optional)
     * @param  int[] $site_id Site (optional)
     * @param  int[] $site_id__n Site (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProvidersListRequest($asn = null, $asn__n = null, $asn_id = null, $asn_id__n = null, $contact = null, $contact__n = null, $contact_group = null, $contact_group__n = null, $contact_role = null, $contact_role__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['circuitsProvidersList'][0])
    {























































































        $resourcePath = '/api/circuits/providers/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asn,
            'asn', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asn__n,
            'asn__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asn_id,
            'asn_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asn_id__n,
            'asn_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact,
            'contact', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact__n,
            'contact__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_group,
            'contact_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_group__n,
            'contact_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_role,
            'contact_role', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_role__n,
            'contact_role__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region,
            'region', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region__n,
            'region__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region_id,
            'region_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region_id__n,
            'region_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site,
            'site', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site__n,
            'site__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group,
            'site_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group__n,
            'site_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group_id,
            'site_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group_id__n,
            'site_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id,
            'site_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id__n,
            'site_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__empty,
            'slug__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ic,
            'slug__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ie,
            'slug__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__iew,
            'slug__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__isw,
            'slug__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__n,
            'slug__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nic,
            'slug__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nie,
            'slug__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__niew,
            'slug__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nisw,
            'slug__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProvidersPartialUpdate
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderRequest $patched_provider_request patched_provider_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Provider
     */
    public function circuitsProvidersPartialUpdate($id, $patched_provider_request = null, string $contentType = self::contentTypes['circuitsProvidersPartialUpdate'][0])
    {
        list($response) = $this->circuitsProvidersPartialUpdateWithHttpInfo($id, $patched_provider_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProvidersPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderRequest $patched_provider_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Provider, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProvidersPartialUpdateWithHttpInfo($id, $patched_provider_request = null, string $contentType = self::contentTypes['circuitsProvidersPartialUpdate'][0])
    {
        $request = $this->circuitsProvidersPartialUpdateRequest($id, $patched_provider_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Provider' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Provider' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Provider', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Provider';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Provider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProvidersPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderRequest $patched_provider_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersPartialUpdateAsync($id, $patched_provider_request = null, string $contentType = self::contentTypes['circuitsProvidersPartialUpdate'][0])
    {
        return $this->circuitsProvidersPartialUpdateAsyncWithHttpInfo($id, $patched_provider_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProvidersPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderRequest $patched_provider_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersPartialUpdateAsyncWithHttpInfo($id, $patched_provider_request = null, string $contentType = self::contentTypes['circuitsProvidersPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Provider';
        $request = $this->circuitsProvidersPartialUpdateRequest($id, $patched_provider_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProvidersPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  \OpenAPI\Client\Model\PatchedProviderRequest $patched_provider_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProvidersPartialUpdateRequest($id, $patched_provider_request = null, string $contentType = self::contentTypes['circuitsProvidersPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProvidersPartialUpdate'
            );
        }



        $resourcePath = '/api/circuits/providers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_provider_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_provider_request));
            } else {
                $httpBody = $patched_provider_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProvidersRetrieve
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Provider
     */
    public function circuitsProvidersRetrieve($id, string $contentType = self::contentTypes['circuitsProvidersRetrieve'][0])
    {
        list($response) = $this->circuitsProvidersRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProvidersRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Provider, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProvidersRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProvidersRetrieve'][0])
    {
        $request = $this->circuitsProvidersRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Provider' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Provider' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Provider', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Provider';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Provider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProvidersRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersRetrieveAsync($id, string $contentType = self::contentTypes['circuitsProvidersRetrieve'][0])
    {
        return $this->circuitsProvidersRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProvidersRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['circuitsProvidersRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Provider';
        $request = $this->circuitsProvidersRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProvidersRetrieve'
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProvidersRetrieveRequest($id, string $contentType = self::contentTypes['circuitsProvidersRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProvidersRetrieve'
            );
        }


        $resourcePath = '/api/circuits/providers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation circuitsProvidersUpdate
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  \OpenAPI\Client\Model\ProviderRequest $provider_request provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Provider
     */
    public function circuitsProvidersUpdate($id, $provider_request, string $contentType = self::contentTypes['circuitsProvidersUpdate'][0])
    {
        list($response) = $this->circuitsProvidersUpdateWithHttpInfo($id, $provider_request, $contentType);
        return $response;
    }

    /**
     * Operation circuitsProvidersUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  \OpenAPI\Client\Model\ProviderRequest $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Provider, HTTP status code, HTTP response headers (array of strings)
     */
    public function circuitsProvidersUpdateWithHttpInfo($id, $provider_request, string $contentType = self::contentTypes['circuitsProvidersUpdate'][0])
    {
        $request = $this->circuitsProvidersUpdateRequest($id, $provider_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Provider' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Provider' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Provider', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Provider';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Provider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation circuitsProvidersUpdateAsync
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  \OpenAPI\Client\Model\ProviderRequest $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersUpdateAsync($id, $provider_request, string $contentType = self::contentTypes['circuitsProvidersUpdate'][0])
    {
        return $this->circuitsProvidersUpdateAsyncWithHttpInfo($id, $provider_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation circuitsProvidersUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  \OpenAPI\Client\Model\ProviderRequest $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function circuitsProvidersUpdateAsyncWithHttpInfo($id, $provider_request, string $contentType = self::contentTypes['circuitsProvidersUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Provider';
        $request = $this->circuitsProvidersUpdateRequest($id, $provider_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'circuitsProvidersUpdate'
     *
     * @param  int $id A unique integer value identifying this provider. (required)
     * @param  \OpenAPI\Client\Model\ProviderRequest $provider_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['circuitsProvidersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function circuitsProvidersUpdateRequest($id, $provider_request, string $contentType = self::contentTypes['circuitsProvidersUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling circuitsProvidersUpdate'
            );
        }

        // verify the required parameter 'provider_request' is set
        if ($provider_request === null || (is_array($provider_request) && count($provider_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_request when calling circuitsProvidersUpdate'
            );
        }


        $resourcePath = '/api/circuits/providers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provider_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provider_request));
            } else {
                $httpBody = $provider_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
