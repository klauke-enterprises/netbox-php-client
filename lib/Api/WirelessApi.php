<?php
/**
 * WirelessApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NetBox REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.1.1 (4.1)
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.8.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * WirelessApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class WirelessApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'wirelessWirelessLanGroupsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLanGroupsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLanGroupsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLanGroupsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLanGroupsDestroy' => [
            'application/json',
        ],
        'wirelessWirelessLanGroupsList' => [
            'application/json',
        ],
        'wirelessWirelessLanGroupsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLanGroupsRetrieve' => [
            'application/json',
        ],
        'wirelessWirelessLanGroupsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLansBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLansBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLansBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLansCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLansDestroy' => [
            'application/json',
        ],
        'wirelessWirelessLansList' => [
            'application/json',
        ],
        'wirelessWirelessLansPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLansRetrieve' => [
            'application/json',
        ],
        'wirelessWirelessLansUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLinksBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLinksBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLinksBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLinksCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLinksDestroy' => [
            'application/json',
        ],
        'wirelessWirelessLinksList' => [
            'application/json',
        ],
        'wirelessWirelessLinksPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'wirelessWirelessLinksRetrieve' => [
            'application/json',
        ],
        'wirelessWirelessLinksUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function wirelessWirelessLanGroupsBulkDestroy($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkDestroy'][0])
    {
        $this->wirelessWirelessLanGroupsBulkDestroyWithHttpInfo($wireless_lan_group_request, $contentType);
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLanGroupsBulkDestroyWithHttpInfo($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkDestroy'][0])
    {
        $request = $this->wirelessWirelessLanGroupsBulkDestroyRequest($wireless_lan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsBulkDestroyAsync($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkDestroy'][0])
    {
        return $this->wirelessWirelessLanGroupsBulkDestroyAsyncWithHttpInfo($wireless_lan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsBulkDestroyAsyncWithHttpInfo($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->wirelessWirelessLanGroupsBulkDestroyRequest($wireless_lan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLanGroupsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLanGroupsBulkDestroyRequest($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkDestroy'][0])
    {

        // verify the required parameter 'wireless_lan_group_request' is set
        if ($wireless_lan_group_request === null || (is_array($wireless_lan_group_request) && count($wireless_lan_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wireless_lan_group_request when calling wirelessWirelessLanGroupsBulkDestroy'
            );
        }


        $resourcePath = '/api/wireless/wireless-lan-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wireless_lan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wireless_lan_group_request));
            } else {
                $httpBody = $wireless_lan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLANGroup[]
     */
    public function wirelessWirelessLanGroupsBulkPartialUpdate($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkPartialUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLanGroupsBulkPartialUpdateWithHttpInfo($wireless_lan_group_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLANGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLanGroupsBulkPartialUpdateWithHttpInfo($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkPartialUpdate'][0])
    {
        $request = $this->wirelessWirelessLanGroupsBulkPartialUpdateRequest($wireless_lan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLANGroup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLANGroup[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLANGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLANGroup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLANGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsBulkPartialUpdateAsync($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkPartialUpdate'][0])
    {
        return $this->wirelessWirelessLanGroupsBulkPartialUpdateAsyncWithHttpInfo($wireless_lan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsBulkPartialUpdateAsyncWithHttpInfo($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLANGroup[]';
        $request = $this->wirelessWirelessLanGroupsBulkPartialUpdateRequest($wireless_lan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLanGroupsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLanGroupsBulkPartialUpdateRequest($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'wireless_lan_group_request' is set
        if ($wireless_lan_group_request === null || (is_array($wireless_lan_group_request) && count($wireless_lan_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wireless_lan_group_request when calling wirelessWirelessLanGroupsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/wireless/wireless-lan-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wireless_lan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wireless_lan_group_request));
            } else {
                $httpBody = $wireless_lan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLANGroup[]
     */
    public function wirelessWirelessLanGroupsBulkUpdate($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLanGroupsBulkUpdateWithHttpInfo($wireless_lan_group_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLANGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLanGroupsBulkUpdateWithHttpInfo($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkUpdate'][0])
    {
        $request = $this->wirelessWirelessLanGroupsBulkUpdateRequest($wireless_lan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLANGroup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLANGroup[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLANGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLANGroup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLANGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsBulkUpdateAsync($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkUpdate'][0])
    {
        return $this->wirelessWirelessLanGroupsBulkUpdateAsyncWithHttpInfo($wireless_lan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLanGroupsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsBulkUpdateAsyncWithHttpInfo($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLANGroup[]';
        $request = $this->wirelessWirelessLanGroupsBulkUpdateRequest($wireless_lan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLanGroupsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\WirelessLANGroupRequest[] $wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLanGroupsBulkUpdateRequest($wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsBulkUpdate'][0])
    {

        // verify the required parameter 'wireless_lan_group_request' is set
        if ($wireless_lan_group_request === null || (is_array($wireless_lan_group_request) && count($wireless_lan_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wireless_lan_group_request when calling wirelessWirelessLanGroupsBulkUpdate'
            );
        }


        $resourcePath = '/api/wireless/wireless-lan-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wireless_lan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wireless_lan_group_request));
            } else {
                $httpBody = $wireless_lan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLanGroupsCreate
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLANGroupRequest $writable_wireless_lan_group_request writable_wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLANGroup
     */
    public function wirelessWirelessLanGroupsCreate($writable_wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsCreate'][0])
    {
        list($response) = $this->wirelessWirelessLanGroupsCreateWithHttpInfo($writable_wireless_lan_group_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLanGroupsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLANGroupRequest $writable_wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLANGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLanGroupsCreateWithHttpInfo($writable_wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsCreate'][0])
    {
        $request = $this->wirelessWirelessLanGroupsCreateRequest($writable_wireless_lan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\WirelessLANGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLANGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLANGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLANGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLANGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLanGroupsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLANGroupRequest $writable_wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsCreateAsync($writable_wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsCreate'][0])
    {
        return $this->wirelessWirelessLanGroupsCreateAsyncWithHttpInfo($writable_wireless_lan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLanGroupsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLANGroupRequest $writable_wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsCreateAsyncWithHttpInfo($writable_wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLANGroup';
        $request = $this->wirelessWirelessLanGroupsCreateRequest($writable_wireless_lan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLanGroupsCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLANGroupRequest $writable_wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLanGroupsCreateRequest($writable_wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsCreate'][0])
    {

        // verify the required parameter 'writable_wireless_lan_group_request' is set
        if ($writable_wireless_lan_group_request === null || (is_array($writable_wireless_lan_group_request) && count($writable_wireless_lan_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_wireless_lan_group_request when calling wirelessWirelessLanGroupsCreate'
            );
        }


        $resourcePath = '/api/wireless/wireless-lan-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_wireless_lan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_wireless_lan_group_request));
            } else {
                $httpBody = $writable_wireless_lan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLanGroupsDestroy
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function wirelessWirelessLanGroupsDestroy($id, string $contentType = self::contentTypes['wirelessWirelessLanGroupsDestroy'][0])
    {
        $this->wirelessWirelessLanGroupsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation wirelessWirelessLanGroupsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLanGroupsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLanGroupsDestroy'][0])
    {
        $request = $this->wirelessWirelessLanGroupsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLanGroupsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsDestroyAsync($id, string $contentType = self::contentTypes['wirelessWirelessLanGroupsDestroy'][0])
    {
        return $this->wirelessWirelessLanGroupsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLanGroupsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLanGroupsDestroy'][0])
    {
        $returnType = '';
        $request = $this->wirelessWirelessLanGroupsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLanGroupsDestroy'
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLanGroupsDestroyRequest($id, string $contentType = self::contentTypes['wirelessWirelessLanGroupsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLanGroupsDestroy'
            );
        }


        $resourcePath = '/api/wireless/wireless-lan-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLanGroupsList
     *
     * @param  string[] $ancestor ancestor (optional)
     * @param  string[] $ancestor__n ancestor__n (optional)
     * @param  string[] $ancestor_id ancestor_id (optional)
     * @param  string[] $ancestor_id__n ancestor_id__n (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent parent (optional)
     * @param  string[] $parent__n parent__n (optional)
     * @param  int[] $parent_id parent_id (optional)
     * @param  int[] $parent_id__n parent_id__n (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug slug (optional)
     * @param  bool $slug__empty slug__empty (optional)
     * @param  string[] $slug__ic slug__ic (optional)
     * @param  string[] $slug__ie slug__ie (optional)
     * @param  string[] $slug__iew slug__iew (optional)
     * @param  string[] $slug__isw slug__isw (optional)
     * @param  string[] $slug__n slug__n (optional)
     * @param  string[] $slug__nic slug__nic (optional)
     * @param  string[] $slug__nie slug__nie (optional)
     * @param  string[] $slug__niew slug__niew (optional)
     * @param  string[] $slug__nisw slug__nisw (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedWirelessLANGroupList
     */
    public function wirelessWirelessLanGroupsList($ancestor = null, $ancestor__n = null, $ancestor_id = null, $ancestor_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $parent = null, $parent__n = null, $parent_id = null, $parent_id__n = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['wirelessWirelessLanGroupsList'][0])
    {
        list($response) = $this->wirelessWirelessLanGroupsListWithHttpInfo($ancestor, $ancestor__n, $ancestor_id, $ancestor_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $parent, $parent__n, $parent_id, $parent_id__n, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLanGroupsListWithHttpInfo
     *
     * @param  string[] $ancestor (optional)
     * @param  string[] $ancestor__n (optional)
     * @param  string[] $ancestor_id (optional)
     * @param  string[] $ancestor_id__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string[] $parent__n (optional)
     * @param  int[] $parent_id (optional)
     * @param  int[] $parent_id__n (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedWirelessLANGroupList, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLanGroupsListWithHttpInfo($ancestor = null, $ancestor__n = null, $ancestor_id = null, $ancestor_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $parent = null, $parent__n = null, $parent_id = null, $parent_id__n = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['wirelessWirelessLanGroupsList'][0])
    {
        $request = $this->wirelessWirelessLanGroupsListRequest($ancestor, $ancestor__n, $ancestor_id, $ancestor_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $parent, $parent__n, $parent_id, $parent_id__n, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedWirelessLANGroupList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedWirelessLANGroupList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedWirelessLANGroupList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedWirelessLANGroupList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedWirelessLANGroupList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLanGroupsListAsync
     *
     * @param  string[] $ancestor (optional)
     * @param  string[] $ancestor__n (optional)
     * @param  string[] $ancestor_id (optional)
     * @param  string[] $ancestor_id__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string[] $parent__n (optional)
     * @param  int[] $parent_id (optional)
     * @param  int[] $parent_id__n (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsListAsync($ancestor = null, $ancestor__n = null, $ancestor_id = null, $ancestor_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $parent = null, $parent__n = null, $parent_id = null, $parent_id__n = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['wirelessWirelessLanGroupsList'][0])
    {
        return $this->wirelessWirelessLanGroupsListAsyncWithHttpInfo($ancestor, $ancestor__n, $ancestor_id, $ancestor_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $parent, $parent__n, $parent_id, $parent_id__n, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLanGroupsListAsyncWithHttpInfo
     *
     * @param  string[] $ancestor (optional)
     * @param  string[] $ancestor__n (optional)
     * @param  string[] $ancestor_id (optional)
     * @param  string[] $ancestor_id__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string[] $parent__n (optional)
     * @param  int[] $parent_id (optional)
     * @param  int[] $parent_id__n (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsListAsyncWithHttpInfo($ancestor = null, $ancestor__n = null, $ancestor_id = null, $ancestor_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $parent = null, $parent__n = null, $parent_id = null, $parent_id__n = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['wirelessWirelessLanGroupsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedWirelessLANGroupList';
        $request = $this->wirelessWirelessLanGroupsListRequest($ancestor, $ancestor__n, $ancestor_id, $ancestor_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $parent, $parent__n, $parent_id, $parent_id__n, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLanGroupsList'
     *
     * @param  string[] $ancestor (optional)
     * @param  string[] $ancestor__n (optional)
     * @param  string[] $ancestor_id (optional)
     * @param  string[] $ancestor_id__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $parent (optional)
     * @param  string[] $parent__n (optional)
     * @param  int[] $parent_id (optional)
     * @param  int[] $parent_id__n (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLanGroupsListRequest($ancestor = null, $ancestor__n = null, $ancestor_id = null, $ancestor_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $parent = null, $parent__n = null, $parent_id = null, $parent_id__n = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['wirelessWirelessLanGroupsList'][0])
    {









































































        $resourcePath = '/api/wireless/wireless-lan-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ancestor,
            'ancestor', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ancestor__n,
            'ancestor__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ancestor_id,
            'ancestor_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ancestor_id__n,
            'ancestor_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent,
            'parent', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent__n,
            'parent__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id,
            'parent_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id__n,
            'parent_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__empty,
            'slug__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ic,
            'slug__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ie,
            'slug__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__iew,
            'slug__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__isw,
            'slug__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__n,
            'slug__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nic,
            'slug__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nie,
            'slug__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__niew,
            'slug__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nisw,
            'slug__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLanGroupsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLANGroupRequest $patched_writable_wireless_lan_group_request patched_writable_wireless_lan_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLANGroup
     */
    public function wirelessWirelessLanGroupsPartialUpdate($id, $patched_writable_wireless_lan_group_request = null, string $contentType = self::contentTypes['wirelessWirelessLanGroupsPartialUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLanGroupsPartialUpdateWithHttpInfo($id, $patched_writable_wireless_lan_group_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLanGroupsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLANGroupRequest $patched_writable_wireless_lan_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLANGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLanGroupsPartialUpdateWithHttpInfo($id, $patched_writable_wireless_lan_group_request = null, string $contentType = self::contentTypes['wirelessWirelessLanGroupsPartialUpdate'][0])
    {
        $request = $this->wirelessWirelessLanGroupsPartialUpdateRequest($id, $patched_writable_wireless_lan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLANGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLANGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLANGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLANGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLANGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLanGroupsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLANGroupRequest $patched_writable_wireless_lan_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsPartialUpdateAsync($id, $patched_writable_wireless_lan_group_request = null, string $contentType = self::contentTypes['wirelessWirelessLanGroupsPartialUpdate'][0])
    {
        return $this->wirelessWirelessLanGroupsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_wireless_lan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLanGroupsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLANGroupRequest $patched_writable_wireless_lan_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_wireless_lan_group_request = null, string $contentType = self::contentTypes['wirelessWirelessLanGroupsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLANGroup';
        $request = $this->wirelessWirelessLanGroupsPartialUpdateRequest($id, $patched_writable_wireless_lan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLanGroupsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLANGroupRequest $patched_writable_wireless_lan_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLanGroupsPartialUpdateRequest($id, $patched_writable_wireless_lan_group_request = null, string $contentType = self::contentTypes['wirelessWirelessLanGroupsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLanGroupsPartialUpdate'
            );
        }



        $resourcePath = '/api/wireless/wireless-lan-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_wireless_lan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_wireless_lan_group_request));
            } else {
                $httpBody = $patched_writable_wireless_lan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLanGroupsRetrieve
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLANGroup
     */
    public function wirelessWirelessLanGroupsRetrieve($id, string $contentType = self::contentTypes['wirelessWirelessLanGroupsRetrieve'][0])
    {
        list($response) = $this->wirelessWirelessLanGroupsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLanGroupsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLANGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLanGroupsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLanGroupsRetrieve'][0])
    {
        $request = $this->wirelessWirelessLanGroupsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLANGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLANGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLANGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLANGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLANGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLanGroupsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsRetrieveAsync($id, string $contentType = self::contentTypes['wirelessWirelessLanGroupsRetrieve'][0])
    {
        return $this->wirelessWirelessLanGroupsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLanGroupsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLanGroupsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLANGroup';
        $request = $this->wirelessWirelessLanGroupsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLanGroupsRetrieve'
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLanGroupsRetrieveRequest($id, string $contentType = self::contentTypes['wirelessWirelessLanGroupsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLanGroupsRetrieve'
            );
        }


        $resourcePath = '/api/wireless/wireless-lan-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLanGroupsUpdate
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLANGroupRequest $writable_wireless_lan_group_request writable_wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLANGroup
     */
    public function wirelessWirelessLanGroupsUpdate($id, $writable_wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLanGroupsUpdateWithHttpInfo($id, $writable_wireless_lan_group_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLanGroupsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLANGroupRequest $writable_wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLANGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLanGroupsUpdateWithHttpInfo($id, $writable_wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsUpdate'][0])
    {
        $request = $this->wirelessWirelessLanGroupsUpdateRequest($id, $writable_wireless_lan_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLANGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLANGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLANGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLANGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLANGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLanGroupsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLANGroupRequest $writable_wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsUpdateAsync($id, $writable_wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsUpdate'][0])
    {
        return $this->wirelessWirelessLanGroupsUpdateAsyncWithHttpInfo($id, $writable_wireless_lan_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLanGroupsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLANGroupRequest $writable_wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLanGroupsUpdateAsyncWithHttpInfo($id, $writable_wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLANGroup';
        $request = $this->wirelessWirelessLanGroupsUpdateRequest($id, $writable_wireless_lan_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLanGroupsUpdate'
     *
     * @param  int $id A unique integer value identifying this wireless LAN group. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLANGroupRequest $writable_wireless_lan_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLanGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLanGroupsUpdateRequest($id, $writable_wireless_lan_group_request, string $contentType = self::contentTypes['wirelessWirelessLanGroupsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLanGroupsUpdate'
            );
        }

        // verify the required parameter 'writable_wireless_lan_group_request' is set
        if ($writable_wireless_lan_group_request === null || (is_array($writable_wireless_lan_group_request) && count($writable_wireless_lan_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_wireless_lan_group_request when calling wirelessWirelessLanGroupsUpdate'
            );
        }


        $resourcePath = '/api/wireless/wireless-lan-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_wireless_lan_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_wireless_lan_group_request));
            } else {
                $httpBody = $writable_wireless_lan_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLansBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function wirelessWirelessLansBulkDestroy($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkDestroy'][0])
    {
        $this->wirelessWirelessLansBulkDestroyWithHttpInfo($wireless_lan_request, $contentType);
    }

    /**
     * Operation wirelessWirelessLansBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLansBulkDestroyWithHttpInfo($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkDestroy'][0])
    {
        $request = $this->wirelessWirelessLansBulkDestroyRequest($wireless_lan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLansBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansBulkDestroyAsync($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkDestroy'][0])
    {
        return $this->wirelessWirelessLansBulkDestroyAsyncWithHttpInfo($wireless_lan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLansBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansBulkDestroyAsyncWithHttpInfo($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->wirelessWirelessLansBulkDestroyRequest($wireless_lan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLansBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLansBulkDestroyRequest($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkDestroy'][0])
    {

        // verify the required parameter 'wireless_lan_request' is set
        if ($wireless_lan_request === null || (is_array($wireless_lan_request) && count($wireless_lan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wireless_lan_request when calling wirelessWirelessLansBulkDestroy'
            );
        }


        $resourcePath = '/api/wireless/wireless-lans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wireless_lan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wireless_lan_request));
            } else {
                $httpBody = $wireless_lan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLansBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLAN[]
     */
    public function wirelessWirelessLansBulkPartialUpdate($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkPartialUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLansBulkPartialUpdateWithHttpInfo($wireless_lan_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLansBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLAN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLansBulkPartialUpdateWithHttpInfo($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkPartialUpdate'][0])
    {
        $request = $this->wirelessWirelessLansBulkPartialUpdateRequest($wireless_lan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLAN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLAN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLAN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLAN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLAN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLansBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansBulkPartialUpdateAsync($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkPartialUpdate'][0])
    {
        return $this->wirelessWirelessLansBulkPartialUpdateAsyncWithHttpInfo($wireless_lan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLansBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansBulkPartialUpdateAsyncWithHttpInfo($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLAN[]';
        $request = $this->wirelessWirelessLansBulkPartialUpdateRequest($wireless_lan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLansBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLansBulkPartialUpdateRequest($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkPartialUpdate'][0])
    {

        // verify the required parameter 'wireless_lan_request' is set
        if ($wireless_lan_request === null || (is_array($wireless_lan_request) && count($wireless_lan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wireless_lan_request when calling wirelessWirelessLansBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/wireless/wireless-lans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wireless_lan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wireless_lan_request));
            } else {
                $httpBody = $wireless_lan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLansBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLAN[]
     */
    public function wirelessWirelessLansBulkUpdate($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLansBulkUpdateWithHttpInfo($wireless_lan_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLansBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLAN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLansBulkUpdateWithHttpInfo($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkUpdate'][0])
    {
        $request = $this->wirelessWirelessLansBulkUpdateRequest($wireless_lan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLAN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLAN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLAN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLAN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLAN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLansBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansBulkUpdateAsync($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkUpdate'][0])
    {
        return $this->wirelessWirelessLansBulkUpdateAsyncWithHttpInfo($wireless_lan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLansBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansBulkUpdateAsyncWithHttpInfo($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLAN[]';
        $request = $this->wirelessWirelessLansBulkUpdateRequest($wireless_lan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLansBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\WirelessLANRequest[] $wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLansBulkUpdateRequest($wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansBulkUpdate'][0])
    {

        // verify the required parameter 'wireless_lan_request' is set
        if ($wireless_lan_request === null || (is_array($wireless_lan_request) && count($wireless_lan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wireless_lan_request when calling wirelessWirelessLansBulkUpdate'
            );
        }


        $resourcePath = '/api/wireless/wireless-lans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wireless_lan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wireless_lan_request));
            } else {
                $httpBody = $wireless_lan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLansCreate
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLANRequest $writable_wireless_lan_request writable_wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLAN
     */
    public function wirelessWirelessLansCreate($writable_wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansCreate'][0])
    {
        list($response) = $this->wirelessWirelessLansCreateWithHttpInfo($writable_wireless_lan_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLansCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLANRequest $writable_wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLAN, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLansCreateWithHttpInfo($writable_wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansCreate'][0])
    {
        $request = $this->wirelessWirelessLansCreateRequest($writable_wireless_lan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\WirelessLAN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLAN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLAN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLAN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLAN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLansCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLANRequest $writable_wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansCreateAsync($writable_wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansCreate'][0])
    {
        return $this->wirelessWirelessLansCreateAsyncWithHttpInfo($writable_wireless_lan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLansCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLANRequest $writable_wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansCreateAsyncWithHttpInfo($writable_wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLAN';
        $request = $this->wirelessWirelessLansCreateRequest($writable_wireless_lan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLansCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLANRequest $writable_wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLansCreateRequest($writable_wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansCreate'][0])
    {

        // verify the required parameter 'writable_wireless_lan_request' is set
        if ($writable_wireless_lan_request === null || (is_array($writable_wireless_lan_request) && count($writable_wireless_lan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_wireless_lan_request when calling wirelessWirelessLansCreate'
            );
        }


        $resourcePath = '/api/wireless/wireless-lans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_wireless_lan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_wireless_lan_request));
            } else {
                $httpBody = $writable_wireless_lan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLansDestroy
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function wirelessWirelessLansDestroy($id, string $contentType = self::contentTypes['wirelessWirelessLansDestroy'][0])
    {
        $this->wirelessWirelessLansDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation wirelessWirelessLansDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLansDestroyWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLansDestroy'][0])
    {
        $request = $this->wirelessWirelessLansDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLansDestroyAsync
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansDestroyAsync($id, string $contentType = self::contentTypes['wirelessWirelessLansDestroy'][0])
    {
        return $this->wirelessWirelessLansDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLansDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLansDestroy'][0])
    {
        $returnType = '';
        $request = $this->wirelessWirelessLansDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLansDestroy'
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLansDestroyRequest($id, string $contentType = self::contentTypes['wirelessWirelessLansDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLansDestroy'
            );
        }


        $resourcePath = '/api/wireless/wireless-lans/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLansList
     *
     * @param  string[] $auth_cipher auth_cipher (optional)
     * @param  string[] $auth_cipher__n auth_cipher__n (optional)
     * @param  string[] $auth_psk auth_psk (optional)
     * @param  bool $auth_psk__empty auth_psk__empty (optional)
     * @param  string[] $auth_psk__ic auth_psk__ic (optional)
     * @param  string[] $auth_psk__ie auth_psk__ie (optional)
     * @param  string[] $auth_psk__iew auth_psk__iew (optional)
     * @param  string[] $auth_psk__isw auth_psk__isw (optional)
     * @param  string[] $auth_psk__n auth_psk__n (optional)
     * @param  string[] $auth_psk__nic auth_psk__nic (optional)
     * @param  string[] $auth_psk__nie auth_psk__nie (optional)
     * @param  string[] $auth_psk__niew auth_psk__niew (optional)
     * @param  string[] $auth_psk__nisw auth_psk__nisw (optional)
     * @param  string[] $auth_type auth_type (optional)
     * @param  string[] $auth_type__n auth_type__n (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $group group (optional)
     * @param  string[] $group__n group__n (optional)
     * @param  string[] $group_id group_id (optional)
     * @param  string[] $group_id__n group_id__n (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  int[] $interface_id interface_id (optional)
     * @param  int[] $interface_id__n interface_id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $ssid ssid (optional)
     * @param  bool $ssid__empty ssid__empty (optional)
     * @param  string[] $ssid__ic ssid__ic (optional)
     * @param  string[] $ssid__ie ssid__ie (optional)
     * @param  string[] $ssid__iew ssid__iew (optional)
     * @param  string[] $ssid__isw ssid__isw (optional)
     * @param  string[] $ssid__n ssid__n (optional)
     * @param  string[] $ssid__nic ssid__nic (optional)
     * @param  string[] $ssid__nie ssid__nie (optional)
     * @param  string[] $ssid__niew ssid__niew (optional)
     * @param  string[] $ssid__nisw ssid__nisw (optional)
     * @param  string[] $status status (optional)
     * @param  string[] $status__n status__n (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group tenant_group (optional)
     * @param  string[] $tenant_group__n tenant_group__n (optional)
     * @param  string[] $tenant_group_id tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  int[] $vlan_id vlan_id (optional)
     * @param  int[] $vlan_id__n vlan_id__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedWirelessLANList
     */
    public function wirelessWirelessLansList($auth_cipher = null, $auth_cipher__n = null, $auth_psk = null, $auth_psk__empty = null, $auth_psk__ic = null, $auth_psk__ie = null, $auth_psk__iew = null, $auth_psk__isw = null, $auth_psk__n = null, $auth_psk__nic = null, $auth_psk__nie = null, $auth_psk__niew = null, $auth_psk__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $ssid = null, $ssid__empty = null, $ssid__ic = null, $ssid__ie = null, $ssid__iew = null, $ssid__isw = null, $ssid__n = null, $ssid__nic = null, $ssid__nie = null, $ssid__niew = null, $ssid__nisw = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vlan_id = null, $vlan_id__n = null, string $contentType = self::contentTypes['wirelessWirelessLansList'][0])
    {
        list($response) = $this->wirelessWirelessLansListWithHttpInfo($auth_cipher, $auth_cipher__n, $auth_psk, $auth_psk__empty, $auth_psk__ic, $auth_psk__ie, $auth_psk__iew, $auth_psk__isw, $auth_psk__n, $auth_psk__nic, $auth_psk__nie, $auth_psk__niew, $auth_psk__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $ssid, $ssid__empty, $ssid__ic, $ssid__ie, $ssid__iew, $ssid__isw, $ssid__n, $ssid__nic, $ssid__nie, $ssid__niew, $ssid__nisw, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vlan_id, $vlan_id__n, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLansListWithHttpInfo
     *
     * @param  string[] $auth_cipher (optional)
     * @param  string[] $auth_cipher__n (optional)
     * @param  string[] $auth_psk (optional)
     * @param  bool $auth_psk__empty (optional)
     * @param  string[] $auth_psk__ic (optional)
     * @param  string[] $auth_psk__ie (optional)
     * @param  string[] $auth_psk__iew (optional)
     * @param  string[] $auth_psk__isw (optional)
     * @param  string[] $auth_psk__n (optional)
     * @param  string[] $auth_psk__nic (optional)
     * @param  string[] $auth_psk__nie (optional)
     * @param  string[] $auth_psk__niew (optional)
     * @param  string[] $auth_psk__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $group (optional)
     * @param  string[] $group__n (optional)
     * @param  string[] $group_id (optional)
     * @param  string[] $group_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_id (optional)
     * @param  int[] $interface_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $ssid (optional)
     * @param  bool $ssid__empty (optional)
     * @param  string[] $ssid__ic (optional)
     * @param  string[] $ssid__ie (optional)
     * @param  string[] $ssid__iew (optional)
     * @param  string[] $ssid__isw (optional)
     * @param  string[] $ssid__n (optional)
     * @param  string[] $ssid__nic (optional)
     * @param  string[] $ssid__nie (optional)
     * @param  string[] $ssid__niew (optional)
     * @param  string[] $ssid__nisw (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vlan_id (optional)
     * @param  int[] $vlan_id__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedWirelessLANList, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLansListWithHttpInfo($auth_cipher = null, $auth_cipher__n = null, $auth_psk = null, $auth_psk__empty = null, $auth_psk__ic = null, $auth_psk__ie = null, $auth_psk__iew = null, $auth_psk__isw = null, $auth_psk__n = null, $auth_psk__nic = null, $auth_psk__nie = null, $auth_psk__niew = null, $auth_psk__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $ssid = null, $ssid__empty = null, $ssid__ic = null, $ssid__ie = null, $ssid__iew = null, $ssid__isw = null, $ssid__n = null, $ssid__nic = null, $ssid__nie = null, $ssid__niew = null, $ssid__nisw = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vlan_id = null, $vlan_id__n = null, string $contentType = self::contentTypes['wirelessWirelessLansList'][0])
    {
        $request = $this->wirelessWirelessLansListRequest($auth_cipher, $auth_cipher__n, $auth_psk, $auth_psk__empty, $auth_psk__ic, $auth_psk__ie, $auth_psk__iew, $auth_psk__isw, $auth_psk__n, $auth_psk__nic, $auth_psk__nie, $auth_psk__niew, $auth_psk__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $ssid, $ssid__empty, $ssid__ic, $ssid__ie, $ssid__iew, $ssid__isw, $ssid__n, $ssid__nic, $ssid__nie, $ssid__niew, $ssid__nisw, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vlan_id, $vlan_id__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedWirelessLANList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedWirelessLANList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedWirelessLANList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedWirelessLANList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedWirelessLANList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLansListAsync
     *
     * @param  string[] $auth_cipher (optional)
     * @param  string[] $auth_cipher__n (optional)
     * @param  string[] $auth_psk (optional)
     * @param  bool $auth_psk__empty (optional)
     * @param  string[] $auth_psk__ic (optional)
     * @param  string[] $auth_psk__ie (optional)
     * @param  string[] $auth_psk__iew (optional)
     * @param  string[] $auth_psk__isw (optional)
     * @param  string[] $auth_psk__n (optional)
     * @param  string[] $auth_psk__nic (optional)
     * @param  string[] $auth_psk__nie (optional)
     * @param  string[] $auth_psk__niew (optional)
     * @param  string[] $auth_psk__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $group (optional)
     * @param  string[] $group__n (optional)
     * @param  string[] $group_id (optional)
     * @param  string[] $group_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_id (optional)
     * @param  int[] $interface_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $ssid (optional)
     * @param  bool $ssid__empty (optional)
     * @param  string[] $ssid__ic (optional)
     * @param  string[] $ssid__ie (optional)
     * @param  string[] $ssid__iew (optional)
     * @param  string[] $ssid__isw (optional)
     * @param  string[] $ssid__n (optional)
     * @param  string[] $ssid__nic (optional)
     * @param  string[] $ssid__nie (optional)
     * @param  string[] $ssid__niew (optional)
     * @param  string[] $ssid__nisw (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vlan_id (optional)
     * @param  int[] $vlan_id__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansListAsync($auth_cipher = null, $auth_cipher__n = null, $auth_psk = null, $auth_psk__empty = null, $auth_psk__ic = null, $auth_psk__ie = null, $auth_psk__iew = null, $auth_psk__isw = null, $auth_psk__n = null, $auth_psk__nic = null, $auth_psk__nie = null, $auth_psk__niew = null, $auth_psk__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $ssid = null, $ssid__empty = null, $ssid__ic = null, $ssid__ie = null, $ssid__iew = null, $ssid__isw = null, $ssid__n = null, $ssid__nic = null, $ssid__nie = null, $ssid__niew = null, $ssid__nisw = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vlan_id = null, $vlan_id__n = null, string $contentType = self::contentTypes['wirelessWirelessLansList'][0])
    {
        return $this->wirelessWirelessLansListAsyncWithHttpInfo($auth_cipher, $auth_cipher__n, $auth_psk, $auth_psk__empty, $auth_psk__ic, $auth_psk__ie, $auth_psk__iew, $auth_psk__isw, $auth_psk__n, $auth_psk__nic, $auth_psk__nie, $auth_psk__niew, $auth_psk__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $ssid, $ssid__empty, $ssid__ic, $ssid__ie, $ssid__iew, $ssid__isw, $ssid__n, $ssid__nic, $ssid__nie, $ssid__niew, $ssid__nisw, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vlan_id, $vlan_id__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLansListAsyncWithHttpInfo
     *
     * @param  string[] $auth_cipher (optional)
     * @param  string[] $auth_cipher__n (optional)
     * @param  string[] $auth_psk (optional)
     * @param  bool $auth_psk__empty (optional)
     * @param  string[] $auth_psk__ic (optional)
     * @param  string[] $auth_psk__ie (optional)
     * @param  string[] $auth_psk__iew (optional)
     * @param  string[] $auth_psk__isw (optional)
     * @param  string[] $auth_psk__n (optional)
     * @param  string[] $auth_psk__nic (optional)
     * @param  string[] $auth_psk__nie (optional)
     * @param  string[] $auth_psk__niew (optional)
     * @param  string[] $auth_psk__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $group (optional)
     * @param  string[] $group__n (optional)
     * @param  string[] $group_id (optional)
     * @param  string[] $group_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_id (optional)
     * @param  int[] $interface_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $ssid (optional)
     * @param  bool $ssid__empty (optional)
     * @param  string[] $ssid__ic (optional)
     * @param  string[] $ssid__ie (optional)
     * @param  string[] $ssid__iew (optional)
     * @param  string[] $ssid__isw (optional)
     * @param  string[] $ssid__n (optional)
     * @param  string[] $ssid__nic (optional)
     * @param  string[] $ssid__nie (optional)
     * @param  string[] $ssid__niew (optional)
     * @param  string[] $ssid__nisw (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vlan_id (optional)
     * @param  int[] $vlan_id__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansListAsyncWithHttpInfo($auth_cipher = null, $auth_cipher__n = null, $auth_psk = null, $auth_psk__empty = null, $auth_psk__ic = null, $auth_psk__ie = null, $auth_psk__iew = null, $auth_psk__isw = null, $auth_psk__n = null, $auth_psk__nic = null, $auth_psk__nie = null, $auth_psk__niew = null, $auth_psk__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $ssid = null, $ssid__empty = null, $ssid__ic = null, $ssid__ie = null, $ssid__iew = null, $ssid__isw = null, $ssid__n = null, $ssid__nic = null, $ssid__nie = null, $ssid__niew = null, $ssid__nisw = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vlan_id = null, $vlan_id__n = null, string $contentType = self::contentTypes['wirelessWirelessLansList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedWirelessLANList';
        $request = $this->wirelessWirelessLansListRequest($auth_cipher, $auth_cipher__n, $auth_psk, $auth_psk__empty, $auth_psk__ic, $auth_psk__ie, $auth_psk__iew, $auth_psk__isw, $auth_psk__n, $auth_psk__nic, $auth_psk__nie, $auth_psk__niew, $auth_psk__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $ssid, $ssid__empty, $ssid__ic, $ssid__ie, $ssid__iew, $ssid__isw, $ssid__n, $ssid__nic, $ssid__nie, $ssid__niew, $ssid__nisw, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $vlan_id, $vlan_id__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLansList'
     *
     * @param  string[] $auth_cipher (optional)
     * @param  string[] $auth_cipher__n (optional)
     * @param  string[] $auth_psk (optional)
     * @param  bool $auth_psk__empty (optional)
     * @param  string[] $auth_psk__ic (optional)
     * @param  string[] $auth_psk__ie (optional)
     * @param  string[] $auth_psk__iew (optional)
     * @param  string[] $auth_psk__isw (optional)
     * @param  string[] $auth_psk__n (optional)
     * @param  string[] $auth_psk__nic (optional)
     * @param  string[] $auth_psk__nie (optional)
     * @param  string[] $auth_psk__niew (optional)
     * @param  string[] $auth_psk__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $group (optional)
     * @param  string[] $group__n (optional)
     * @param  string[] $group_id (optional)
     * @param  string[] $group_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_id (optional)
     * @param  int[] $interface_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $ssid (optional)
     * @param  bool $ssid__empty (optional)
     * @param  string[] $ssid__ic (optional)
     * @param  string[] $ssid__ie (optional)
     * @param  string[] $ssid__iew (optional)
     * @param  string[] $ssid__isw (optional)
     * @param  string[] $ssid__n (optional)
     * @param  string[] $ssid__nic (optional)
     * @param  string[] $ssid__nie (optional)
     * @param  string[] $ssid__niew (optional)
     * @param  string[] $ssid__nisw (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $vlan_id (optional)
     * @param  int[] $vlan_id__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLansListRequest($auth_cipher = null, $auth_cipher__n = null, $auth_psk = null, $auth_psk__empty = null, $auth_psk__ic = null, $auth_psk__ie = null, $auth_psk__iew = null, $auth_psk__isw = null, $auth_psk__n = null, $auth_psk__nic = null, $auth_psk__nie = null, $auth_psk__niew = null, $auth_psk__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $ssid = null, $ssid__empty = null, $ssid__ic = null, $ssid__ie = null, $ssid__iew = null, $ssid__isw = null, $ssid__n = null, $ssid__nic = null, $ssid__nie = null, $ssid__niew = null, $ssid__nisw = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $vlan_id = null, $vlan_id__n = null, string $contentType = self::contentTypes['wirelessWirelessLansList'][0])
    {























































































        $resourcePath = '/api/wireless/wireless-lans/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_cipher,
            'auth_cipher', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_cipher__n,
            'auth_cipher__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk,
            'auth_psk', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__empty,
            'auth_psk__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__ic,
            'auth_psk__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__ie,
            'auth_psk__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__iew,
            'auth_psk__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__isw,
            'auth_psk__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__n,
            'auth_psk__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__nic,
            'auth_psk__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__nie,
            'auth_psk__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__niew,
            'auth_psk__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__nisw,
            'auth_psk__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_type,
            'auth_type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_type__n,
            'auth_type__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group,
            'group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group__n,
            'group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id,
            'group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__n,
            'group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id,
            'interface_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id__n,
            'interface_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid,
            'ssid', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__empty,
            'ssid__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__ic,
            'ssid__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__ie,
            'ssid__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__iew,
            'ssid__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__isw,
            'ssid__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__n,
            'ssid__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__nic,
            'ssid__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__nie,
            'ssid__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__niew,
            'ssid__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__nisw,
            'ssid__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status__n,
            'status__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_id,
            'vlan_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_id__n,
            'vlan_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLansPartialUpdate
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLANRequest $patched_writable_wireless_lan_request patched_writable_wireless_lan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLAN
     */
    public function wirelessWirelessLansPartialUpdate($id, $patched_writable_wireless_lan_request = null, string $contentType = self::contentTypes['wirelessWirelessLansPartialUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLansPartialUpdateWithHttpInfo($id, $patched_writable_wireless_lan_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLansPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLANRequest $patched_writable_wireless_lan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLAN, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLansPartialUpdateWithHttpInfo($id, $patched_writable_wireless_lan_request = null, string $contentType = self::contentTypes['wirelessWirelessLansPartialUpdate'][0])
    {
        $request = $this->wirelessWirelessLansPartialUpdateRequest($id, $patched_writable_wireless_lan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLAN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLAN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLAN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLAN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLAN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLansPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLANRequest $patched_writable_wireless_lan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansPartialUpdateAsync($id, $patched_writable_wireless_lan_request = null, string $contentType = self::contentTypes['wirelessWirelessLansPartialUpdate'][0])
    {
        return $this->wirelessWirelessLansPartialUpdateAsyncWithHttpInfo($id, $patched_writable_wireless_lan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLansPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLANRequest $patched_writable_wireless_lan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansPartialUpdateAsyncWithHttpInfo($id, $patched_writable_wireless_lan_request = null, string $contentType = self::contentTypes['wirelessWirelessLansPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLAN';
        $request = $this->wirelessWirelessLansPartialUpdateRequest($id, $patched_writable_wireless_lan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLansPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLANRequest $patched_writable_wireless_lan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLansPartialUpdateRequest($id, $patched_writable_wireless_lan_request = null, string $contentType = self::contentTypes['wirelessWirelessLansPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLansPartialUpdate'
            );
        }



        $resourcePath = '/api/wireless/wireless-lans/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_wireless_lan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_wireless_lan_request));
            } else {
                $httpBody = $patched_writable_wireless_lan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLansRetrieve
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLAN
     */
    public function wirelessWirelessLansRetrieve($id, string $contentType = self::contentTypes['wirelessWirelessLansRetrieve'][0])
    {
        list($response) = $this->wirelessWirelessLansRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLansRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLAN, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLansRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLansRetrieve'][0])
    {
        $request = $this->wirelessWirelessLansRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLAN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLAN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLAN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLAN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLAN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLansRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansRetrieveAsync($id, string $contentType = self::contentTypes['wirelessWirelessLansRetrieve'][0])
    {
        return $this->wirelessWirelessLansRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLansRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLansRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLAN';
        $request = $this->wirelessWirelessLansRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLansRetrieve'
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLansRetrieveRequest($id, string $contentType = self::contentTypes['wirelessWirelessLansRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLansRetrieve'
            );
        }


        $resourcePath = '/api/wireless/wireless-lans/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLansUpdate
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLANRequest $writable_wireless_lan_request writable_wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLAN
     */
    public function wirelessWirelessLansUpdate($id, $writable_wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLansUpdateWithHttpInfo($id, $writable_wireless_lan_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLansUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLANRequest $writable_wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLAN, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLansUpdateWithHttpInfo($id, $writable_wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansUpdate'][0])
    {
        $request = $this->wirelessWirelessLansUpdateRequest($id, $writable_wireless_lan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLAN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLAN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLAN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLAN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLAN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLansUpdateAsync
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLANRequest $writable_wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansUpdateAsync($id, $writable_wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansUpdate'][0])
    {
        return $this->wirelessWirelessLansUpdateAsyncWithHttpInfo($id, $writable_wireless_lan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLansUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLANRequest $writable_wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLansUpdateAsyncWithHttpInfo($id, $writable_wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLAN';
        $request = $this->wirelessWirelessLansUpdateRequest($id, $writable_wireless_lan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLansUpdate'
     *
     * @param  int $id A unique integer value identifying this wireless LAN. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLANRequest $writable_wireless_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLansUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLansUpdateRequest($id, $writable_wireless_lan_request, string $contentType = self::contentTypes['wirelessWirelessLansUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLansUpdate'
            );
        }

        // verify the required parameter 'writable_wireless_lan_request' is set
        if ($writable_wireless_lan_request === null || (is_array($writable_wireless_lan_request) && count($writable_wireless_lan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_wireless_lan_request when calling wirelessWirelessLansUpdate'
            );
        }


        $resourcePath = '/api/wireless/wireless-lans/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_wireless_lan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_wireless_lan_request));
            } else {
                $httpBody = $writable_wireless_lan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLinksBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function wirelessWirelessLinksBulkDestroy($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkDestroy'][0])
    {
        $this->wirelessWirelessLinksBulkDestroyWithHttpInfo($wireless_link_request, $contentType);
    }

    /**
     * Operation wirelessWirelessLinksBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLinksBulkDestroyWithHttpInfo($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkDestroy'][0])
    {
        $request = $this->wirelessWirelessLinksBulkDestroyRequest($wireless_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLinksBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksBulkDestroyAsync($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkDestroy'][0])
    {
        return $this->wirelessWirelessLinksBulkDestroyAsyncWithHttpInfo($wireless_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLinksBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksBulkDestroyAsyncWithHttpInfo($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->wirelessWirelessLinksBulkDestroyRequest($wireless_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLinksBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLinksBulkDestroyRequest($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkDestroy'][0])
    {

        // verify the required parameter 'wireless_link_request' is set
        if ($wireless_link_request === null || (is_array($wireless_link_request) && count($wireless_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wireless_link_request when calling wirelessWirelessLinksBulkDestroy'
            );
        }


        $resourcePath = '/api/wireless/wireless-links/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wireless_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wireless_link_request));
            } else {
                $httpBody = $wireless_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLinksBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLink[]
     */
    public function wirelessWirelessLinksBulkPartialUpdate($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkPartialUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLinksBulkPartialUpdateWithHttpInfo($wireless_link_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLinksBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLink[], HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLinksBulkPartialUpdateWithHttpInfo($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkPartialUpdate'][0])
    {
        $request = $this->wirelessWirelessLinksBulkPartialUpdateRequest($wireless_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLink[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLink[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLink[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLink[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLink[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLinksBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksBulkPartialUpdateAsync($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkPartialUpdate'][0])
    {
        return $this->wirelessWirelessLinksBulkPartialUpdateAsyncWithHttpInfo($wireless_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLinksBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksBulkPartialUpdateAsyncWithHttpInfo($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLink[]';
        $request = $this->wirelessWirelessLinksBulkPartialUpdateRequest($wireless_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLinksBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLinksBulkPartialUpdateRequest($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkPartialUpdate'][0])
    {

        // verify the required parameter 'wireless_link_request' is set
        if ($wireless_link_request === null || (is_array($wireless_link_request) && count($wireless_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wireless_link_request when calling wirelessWirelessLinksBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/wireless/wireless-links/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wireless_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wireless_link_request));
            } else {
                $httpBody = $wireless_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLinksBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLink[]
     */
    public function wirelessWirelessLinksBulkUpdate($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLinksBulkUpdateWithHttpInfo($wireless_link_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLinksBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLink[], HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLinksBulkUpdateWithHttpInfo($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkUpdate'][0])
    {
        $request = $this->wirelessWirelessLinksBulkUpdateRequest($wireless_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLink[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLink[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLink[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLink[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLink[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLinksBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksBulkUpdateAsync($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkUpdate'][0])
    {
        return $this->wirelessWirelessLinksBulkUpdateAsyncWithHttpInfo($wireless_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLinksBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksBulkUpdateAsyncWithHttpInfo($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLink[]';
        $request = $this->wirelessWirelessLinksBulkUpdateRequest($wireless_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLinksBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\WirelessLinkRequest[] $wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLinksBulkUpdateRequest($wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksBulkUpdate'][0])
    {

        // verify the required parameter 'wireless_link_request' is set
        if ($wireless_link_request === null || (is_array($wireless_link_request) && count($wireless_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wireless_link_request when calling wirelessWirelessLinksBulkUpdate'
            );
        }


        $resourcePath = '/api/wireless/wireless-links/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wireless_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wireless_link_request));
            } else {
                $httpBody = $wireless_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLinksCreate
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLinkRequest $writable_wireless_link_request writable_wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLink
     */
    public function wirelessWirelessLinksCreate($writable_wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksCreate'][0])
    {
        list($response) = $this->wirelessWirelessLinksCreateWithHttpInfo($writable_wireless_link_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLinksCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLinkRequest $writable_wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLinksCreateWithHttpInfo($writable_wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksCreate'][0])
    {
        $request = $this->wirelessWirelessLinksCreateRequest($writable_wireless_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\WirelessLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLinksCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLinkRequest $writable_wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksCreateAsync($writable_wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksCreate'][0])
    {
        return $this->wirelessWirelessLinksCreateAsyncWithHttpInfo($writable_wireless_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLinksCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLinkRequest $writable_wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksCreateAsyncWithHttpInfo($writable_wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLink';
        $request = $this->wirelessWirelessLinksCreateRequest($writable_wireless_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLinksCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableWirelessLinkRequest $writable_wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLinksCreateRequest($writable_wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksCreate'][0])
    {

        // verify the required parameter 'writable_wireless_link_request' is set
        if ($writable_wireless_link_request === null || (is_array($writable_wireless_link_request) && count($writable_wireless_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_wireless_link_request when calling wirelessWirelessLinksCreate'
            );
        }


        $resourcePath = '/api/wireless/wireless-links/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_wireless_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_wireless_link_request));
            } else {
                $httpBody = $writable_wireless_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLinksDestroy
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function wirelessWirelessLinksDestroy($id, string $contentType = self::contentTypes['wirelessWirelessLinksDestroy'][0])
    {
        $this->wirelessWirelessLinksDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation wirelessWirelessLinksDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLinksDestroyWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLinksDestroy'][0])
    {
        $request = $this->wirelessWirelessLinksDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLinksDestroyAsync
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksDestroyAsync($id, string $contentType = self::contentTypes['wirelessWirelessLinksDestroy'][0])
    {
        return $this->wirelessWirelessLinksDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLinksDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLinksDestroy'][0])
    {
        $returnType = '';
        $request = $this->wirelessWirelessLinksDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLinksDestroy'
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLinksDestroyRequest($id, string $contentType = self::contentTypes['wirelessWirelessLinksDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLinksDestroy'
            );
        }


        $resourcePath = '/api/wireless/wireless-links/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLinksList
     *
     * @param  string[] $auth_cipher auth_cipher (optional)
     * @param  string[] $auth_cipher__n auth_cipher__n (optional)
     * @param  string[] $auth_psk auth_psk (optional)
     * @param  bool $auth_psk__empty auth_psk__empty (optional)
     * @param  string[] $auth_psk__ic auth_psk__ic (optional)
     * @param  string[] $auth_psk__ie auth_psk__ie (optional)
     * @param  string[] $auth_psk__iew auth_psk__iew (optional)
     * @param  string[] $auth_psk__isw auth_psk__isw (optional)
     * @param  string[] $auth_psk__n auth_psk__n (optional)
     * @param  string[] $auth_psk__nic auth_psk__nic (optional)
     * @param  string[] $auth_psk__nie auth_psk__nie (optional)
     * @param  string[] $auth_psk__niew auth_psk__niew (optional)
     * @param  string[] $auth_psk__nisw auth_psk__nisw (optional)
     * @param  string[] $auth_type auth_type (optional)
     * @param  string[] $auth_type__n auth_type__n (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  float[] $distance distance (optional)
     * @param  bool $distance__empty distance__empty (optional)
     * @param  float[] $distance__gt distance__gt (optional)
     * @param  float[] $distance__gte distance__gte (optional)
     * @param  float[] $distance__lt distance__lt (optional)
     * @param  float[] $distance__lte distance__lte (optional)
     * @param  float[] $distance__n distance__n (optional)
     * @param  string $distance_unit * &#x60;km&#x60; - Kilometers * &#x60;m&#x60; - Meters * &#x60;mi&#x60; - Miles * &#x60;ft&#x60; - Feet (optional)
     * @param  string $distance_unit__n * &#x60;km&#x60; - Kilometers * &#x60;m&#x60; - Meters * &#x60;mi&#x60; - Miles * &#x60;ft&#x60; - Feet (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  int[] $interface_a_id interface_a_id (optional)
     * @param  int[] $interface_a_id__n interface_a_id__n (optional)
     * @param  int[] $interface_b_id interface_b_id (optional)
     * @param  int[] $interface_b_id__n interface_b_id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $ssid ssid (optional)
     * @param  bool $ssid__empty ssid__empty (optional)
     * @param  string[] $ssid__ic ssid__ic (optional)
     * @param  string[] $ssid__ie ssid__ie (optional)
     * @param  string[] $ssid__iew ssid__iew (optional)
     * @param  string[] $ssid__isw ssid__isw (optional)
     * @param  string[] $ssid__n ssid__n (optional)
     * @param  string[] $ssid__nic ssid__nic (optional)
     * @param  string[] $ssid__nie ssid__nie (optional)
     * @param  string[] $ssid__niew ssid__niew (optional)
     * @param  string[] $ssid__nisw ssid__nisw (optional)
     * @param  string[] $status status (optional)
     * @param  string[] $status__n status__n (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group tenant_group (optional)
     * @param  string[] $tenant_group__n tenant_group__n (optional)
     * @param  string[] $tenant_group_id tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedWirelessLinkList
     */
    public function wirelessWirelessLinksList($auth_cipher = null, $auth_cipher__n = null, $auth_psk = null, $auth_psk__empty = null, $auth_psk__ic = null, $auth_psk__ie = null, $auth_psk__iew = null, $auth_psk__isw = null, $auth_psk__n = null, $auth_psk__nic = null, $auth_psk__nie = null, $auth_psk__niew = null, $auth_psk__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $distance = null, $distance__empty = null, $distance__gt = null, $distance__gte = null, $distance__lt = null, $distance__lte = null, $distance__n = null, $distance_unit = null, $distance_unit__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_a_id = null, $interface_a_id__n = null, $interface_b_id = null, $interface_b_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $ssid = null, $ssid__empty = null, $ssid__ic = null, $ssid__ie = null, $ssid__iew = null, $ssid__isw = null, $ssid__n = null, $ssid__nic = null, $ssid__nie = null, $ssid__niew = null, $ssid__nisw = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['wirelessWirelessLinksList'][0])
    {
        list($response) = $this->wirelessWirelessLinksListWithHttpInfo($auth_cipher, $auth_cipher__n, $auth_psk, $auth_psk__empty, $auth_psk__ic, $auth_psk__ie, $auth_psk__iew, $auth_psk__isw, $auth_psk__n, $auth_psk__nic, $auth_psk__nie, $auth_psk__niew, $auth_psk__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $distance, $distance__empty, $distance__gt, $distance__gte, $distance__lt, $distance__lte, $distance__n, $distance_unit, $distance_unit__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_a_id, $interface_a_id__n, $interface_b_id, $interface_b_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $ssid, $ssid__empty, $ssid__ic, $ssid__ie, $ssid__iew, $ssid__isw, $ssid__n, $ssid__nic, $ssid__nie, $ssid__niew, $ssid__nisw, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLinksListWithHttpInfo
     *
     * @param  string[] $auth_cipher (optional)
     * @param  string[] $auth_cipher__n (optional)
     * @param  string[] $auth_psk (optional)
     * @param  bool $auth_psk__empty (optional)
     * @param  string[] $auth_psk__ic (optional)
     * @param  string[] $auth_psk__ie (optional)
     * @param  string[] $auth_psk__iew (optional)
     * @param  string[] $auth_psk__isw (optional)
     * @param  string[] $auth_psk__n (optional)
     * @param  string[] $auth_psk__nic (optional)
     * @param  string[] $auth_psk__nie (optional)
     * @param  string[] $auth_psk__niew (optional)
     * @param  string[] $auth_psk__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float[] $distance (optional)
     * @param  bool $distance__empty (optional)
     * @param  float[] $distance__gt (optional)
     * @param  float[] $distance__gte (optional)
     * @param  float[] $distance__lt (optional)
     * @param  float[] $distance__lte (optional)
     * @param  float[] $distance__n (optional)
     * @param  string $distance_unit * &#x60;km&#x60; - Kilometers * &#x60;m&#x60; - Meters * &#x60;mi&#x60; - Miles * &#x60;ft&#x60; - Feet (optional)
     * @param  string $distance_unit__n * &#x60;km&#x60; - Kilometers * &#x60;m&#x60; - Meters * &#x60;mi&#x60; - Miles * &#x60;ft&#x60; - Feet (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_a_id (optional)
     * @param  int[] $interface_a_id__n (optional)
     * @param  int[] $interface_b_id (optional)
     * @param  int[] $interface_b_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $ssid (optional)
     * @param  bool $ssid__empty (optional)
     * @param  string[] $ssid__ic (optional)
     * @param  string[] $ssid__ie (optional)
     * @param  string[] $ssid__iew (optional)
     * @param  string[] $ssid__isw (optional)
     * @param  string[] $ssid__n (optional)
     * @param  string[] $ssid__nic (optional)
     * @param  string[] $ssid__nie (optional)
     * @param  string[] $ssid__niew (optional)
     * @param  string[] $ssid__nisw (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedWirelessLinkList, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLinksListWithHttpInfo($auth_cipher = null, $auth_cipher__n = null, $auth_psk = null, $auth_psk__empty = null, $auth_psk__ic = null, $auth_psk__ie = null, $auth_psk__iew = null, $auth_psk__isw = null, $auth_psk__n = null, $auth_psk__nic = null, $auth_psk__nie = null, $auth_psk__niew = null, $auth_psk__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $distance = null, $distance__empty = null, $distance__gt = null, $distance__gte = null, $distance__lt = null, $distance__lte = null, $distance__n = null, $distance_unit = null, $distance_unit__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_a_id = null, $interface_a_id__n = null, $interface_b_id = null, $interface_b_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $ssid = null, $ssid__empty = null, $ssid__ic = null, $ssid__ie = null, $ssid__iew = null, $ssid__isw = null, $ssid__n = null, $ssid__nic = null, $ssid__nie = null, $ssid__niew = null, $ssid__nisw = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['wirelessWirelessLinksList'][0])
    {
        $request = $this->wirelessWirelessLinksListRequest($auth_cipher, $auth_cipher__n, $auth_psk, $auth_psk__empty, $auth_psk__ic, $auth_psk__ie, $auth_psk__iew, $auth_psk__isw, $auth_psk__n, $auth_psk__nic, $auth_psk__nie, $auth_psk__niew, $auth_psk__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $distance, $distance__empty, $distance__gt, $distance__gte, $distance__lt, $distance__lte, $distance__n, $distance_unit, $distance_unit__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_a_id, $interface_a_id__n, $interface_b_id, $interface_b_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $ssid, $ssid__empty, $ssid__ic, $ssid__ie, $ssid__iew, $ssid__isw, $ssid__n, $ssid__nic, $ssid__nie, $ssid__niew, $ssid__nisw, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedWirelessLinkList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedWirelessLinkList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedWirelessLinkList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedWirelessLinkList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedWirelessLinkList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLinksListAsync
     *
     * @param  string[] $auth_cipher (optional)
     * @param  string[] $auth_cipher__n (optional)
     * @param  string[] $auth_psk (optional)
     * @param  bool $auth_psk__empty (optional)
     * @param  string[] $auth_psk__ic (optional)
     * @param  string[] $auth_psk__ie (optional)
     * @param  string[] $auth_psk__iew (optional)
     * @param  string[] $auth_psk__isw (optional)
     * @param  string[] $auth_psk__n (optional)
     * @param  string[] $auth_psk__nic (optional)
     * @param  string[] $auth_psk__nie (optional)
     * @param  string[] $auth_psk__niew (optional)
     * @param  string[] $auth_psk__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float[] $distance (optional)
     * @param  bool $distance__empty (optional)
     * @param  float[] $distance__gt (optional)
     * @param  float[] $distance__gte (optional)
     * @param  float[] $distance__lt (optional)
     * @param  float[] $distance__lte (optional)
     * @param  float[] $distance__n (optional)
     * @param  string $distance_unit * &#x60;km&#x60; - Kilometers * &#x60;m&#x60; - Meters * &#x60;mi&#x60; - Miles * &#x60;ft&#x60; - Feet (optional)
     * @param  string $distance_unit__n * &#x60;km&#x60; - Kilometers * &#x60;m&#x60; - Meters * &#x60;mi&#x60; - Miles * &#x60;ft&#x60; - Feet (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_a_id (optional)
     * @param  int[] $interface_a_id__n (optional)
     * @param  int[] $interface_b_id (optional)
     * @param  int[] $interface_b_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $ssid (optional)
     * @param  bool $ssid__empty (optional)
     * @param  string[] $ssid__ic (optional)
     * @param  string[] $ssid__ie (optional)
     * @param  string[] $ssid__iew (optional)
     * @param  string[] $ssid__isw (optional)
     * @param  string[] $ssid__n (optional)
     * @param  string[] $ssid__nic (optional)
     * @param  string[] $ssid__nie (optional)
     * @param  string[] $ssid__niew (optional)
     * @param  string[] $ssid__nisw (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksListAsync($auth_cipher = null, $auth_cipher__n = null, $auth_psk = null, $auth_psk__empty = null, $auth_psk__ic = null, $auth_psk__ie = null, $auth_psk__iew = null, $auth_psk__isw = null, $auth_psk__n = null, $auth_psk__nic = null, $auth_psk__nie = null, $auth_psk__niew = null, $auth_psk__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $distance = null, $distance__empty = null, $distance__gt = null, $distance__gte = null, $distance__lt = null, $distance__lte = null, $distance__n = null, $distance_unit = null, $distance_unit__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_a_id = null, $interface_a_id__n = null, $interface_b_id = null, $interface_b_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $ssid = null, $ssid__empty = null, $ssid__ic = null, $ssid__ie = null, $ssid__iew = null, $ssid__isw = null, $ssid__n = null, $ssid__nic = null, $ssid__nie = null, $ssid__niew = null, $ssid__nisw = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['wirelessWirelessLinksList'][0])
    {
        return $this->wirelessWirelessLinksListAsyncWithHttpInfo($auth_cipher, $auth_cipher__n, $auth_psk, $auth_psk__empty, $auth_psk__ic, $auth_psk__ie, $auth_psk__iew, $auth_psk__isw, $auth_psk__n, $auth_psk__nic, $auth_psk__nie, $auth_psk__niew, $auth_psk__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $distance, $distance__empty, $distance__gt, $distance__gte, $distance__lt, $distance__lte, $distance__n, $distance_unit, $distance_unit__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_a_id, $interface_a_id__n, $interface_b_id, $interface_b_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $ssid, $ssid__empty, $ssid__ic, $ssid__ie, $ssid__iew, $ssid__isw, $ssid__n, $ssid__nic, $ssid__nie, $ssid__niew, $ssid__nisw, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLinksListAsyncWithHttpInfo
     *
     * @param  string[] $auth_cipher (optional)
     * @param  string[] $auth_cipher__n (optional)
     * @param  string[] $auth_psk (optional)
     * @param  bool $auth_psk__empty (optional)
     * @param  string[] $auth_psk__ic (optional)
     * @param  string[] $auth_psk__ie (optional)
     * @param  string[] $auth_psk__iew (optional)
     * @param  string[] $auth_psk__isw (optional)
     * @param  string[] $auth_psk__n (optional)
     * @param  string[] $auth_psk__nic (optional)
     * @param  string[] $auth_psk__nie (optional)
     * @param  string[] $auth_psk__niew (optional)
     * @param  string[] $auth_psk__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float[] $distance (optional)
     * @param  bool $distance__empty (optional)
     * @param  float[] $distance__gt (optional)
     * @param  float[] $distance__gte (optional)
     * @param  float[] $distance__lt (optional)
     * @param  float[] $distance__lte (optional)
     * @param  float[] $distance__n (optional)
     * @param  string $distance_unit * &#x60;km&#x60; - Kilometers * &#x60;m&#x60; - Meters * &#x60;mi&#x60; - Miles * &#x60;ft&#x60; - Feet (optional)
     * @param  string $distance_unit__n * &#x60;km&#x60; - Kilometers * &#x60;m&#x60; - Meters * &#x60;mi&#x60; - Miles * &#x60;ft&#x60; - Feet (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_a_id (optional)
     * @param  int[] $interface_a_id__n (optional)
     * @param  int[] $interface_b_id (optional)
     * @param  int[] $interface_b_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $ssid (optional)
     * @param  bool $ssid__empty (optional)
     * @param  string[] $ssid__ic (optional)
     * @param  string[] $ssid__ie (optional)
     * @param  string[] $ssid__iew (optional)
     * @param  string[] $ssid__isw (optional)
     * @param  string[] $ssid__n (optional)
     * @param  string[] $ssid__nic (optional)
     * @param  string[] $ssid__nie (optional)
     * @param  string[] $ssid__niew (optional)
     * @param  string[] $ssid__nisw (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksListAsyncWithHttpInfo($auth_cipher = null, $auth_cipher__n = null, $auth_psk = null, $auth_psk__empty = null, $auth_psk__ic = null, $auth_psk__ie = null, $auth_psk__iew = null, $auth_psk__isw = null, $auth_psk__n = null, $auth_psk__nic = null, $auth_psk__nie = null, $auth_psk__niew = null, $auth_psk__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $distance = null, $distance__empty = null, $distance__gt = null, $distance__gte = null, $distance__lt = null, $distance__lte = null, $distance__n = null, $distance_unit = null, $distance_unit__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_a_id = null, $interface_a_id__n = null, $interface_b_id = null, $interface_b_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $ssid = null, $ssid__empty = null, $ssid__ic = null, $ssid__ie = null, $ssid__iew = null, $ssid__isw = null, $ssid__n = null, $ssid__nic = null, $ssid__nie = null, $ssid__niew = null, $ssid__nisw = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['wirelessWirelessLinksList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedWirelessLinkList';
        $request = $this->wirelessWirelessLinksListRequest($auth_cipher, $auth_cipher__n, $auth_psk, $auth_psk__empty, $auth_psk__ic, $auth_psk__ie, $auth_psk__iew, $auth_psk__isw, $auth_psk__n, $auth_psk__nic, $auth_psk__nie, $auth_psk__niew, $auth_psk__nisw, $auth_type, $auth_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $distance, $distance__empty, $distance__gt, $distance__gte, $distance__lt, $distance__lte, $distance__n, $distance_unit, $distance_unit__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface_a_id, $interface_a_id__n, $interface_b_id, $interface_b_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $ssid, $ssid__empty, $ssid__ic, $ssid__ie, $ssid__iew, $ssid__isw, $ssid__n, $ssid__nic, $ssid__nie, $ssid__niew, $ssid__nisw, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLinksList'
     *
     * @param  string[] $auth_cipher (optional)
     * @param  string[] $auth_cipher__n (optional)
     * @param  string[] $auth_psk (optional)
     * @param  bool $auth_psk__empty (optional)
     * @param  string[] $auth_psk__ic (optional)
     * @param  string[] $auth_psk__ie (optional)
     * @param  string[] $auth_psk__iew (optional)
     * @param  string[] $auth_psk__isw (optional)
     * @param  string[] $auth_psk__n (optional)
     * @param  string[] $auth_psk__nic (optional)
     * @param  string[] $auth_psk__nie (optional)
     * @param  string[] $auth_psk__niew (optional)
     * @param  string[] $auth_psk__nisw (optional)
     * @param  string[] $auth_type (optional)
     * @param  string[] $auth_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  float[] $distance (optional)
     * @param  bool $distance__empty (optional)
     * @param  float[] $distance__gt (optional)
     * @param  float[] $distance__gte (optional)
     * @param  float[] $distance__lt (optional)
     * @param  float[] $distance__lte (optional)
     * @param  float[] $distance__n (optional)
     * @param  string $distance_unit * &#x60;km&#x60; - Kilometers * &#x60;m&#x60; - Meters * &#x60;mi&#x60; - Miles * &#x60;ft&#x60; - Feet (optional)
     * @param  string $distance_unit__n * &#x60;km&#x60; - Kilometers * &#x60;m&#x60; - Meters * &#x60;mi&#x60; - Miles * &#x60;ft&#x60; - Feet (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $interface_a_id (optional)
     * @param  int[] $interface_a_id__n (optional)
     * @param  int[] $interface_b_id (optional)
     * @param  int[] $interface_b_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $ssid (optional)
     * @param  bool $ssid__empty (optional)
     * @param  string[] $ssid__ic (optional)
     * @param  string[] $ssid__ie (optional)
     * @param  string[] $ssid__iew (optional)
     * @param  string[] $ssid__isw (optional)
     * @param  string[] $ssid__n (optional)
     * @param  string[] $ssid__nic (optional)
     * @param  string[] $ssid__nie (optional)
     * @param  string[] $ssid__niew (optional)
     * @param  string[] $ssid__nisw (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLinksListRequest($auth_cipher = null, $auth_cipher__n = null, $auth_psk = null, $auth_psk__empty = null, $auth_psk__ic = null, $auth_psk__ie = null, $auth_psk__iew = null, $auth_psk__isw = null, $auth_psk__n = null, $auth_psk__nic = null, $auth_psk__nie = null, $auth_psk__niew = null, $auth_psk__nisw = null, $auth_type = null, $auth_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $distance = null, $distance__empty = null, $distance__gt = null, $distance__gte = null, $distance__lt = null, $distance__lte = null, $distance__n = null, $distance_unit = null, $distance_unit__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface_a_id = null, $interface_a_id__n = null, $interface_b_id = null, $interface_b_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $ssid = null, $ssid__empty = null, $ssid__ic = null, $ssid__ie = null, $ssid__iew = null, $ssid__isw = null, $ssid__n = null, $ssid__nic = null, $ssid__nie = null, $ssid__niew = null, $ssid__nisw = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['wirelessWirelessLinksList'][0])
    {




























































































        $resourcePath = '/api/wireless/wireless-links/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_cipher,
            'auth_cipher', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_cipher__n,
            'auth_cipher__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk,
            'auth_psk', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__empty,
            'auth_psk__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__ic,
            'auth_psk__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__ie,
            'auth_psk__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__iew,
            'auth_psk__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__isw,
            'auth_psk__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__n,
            'auth_psk__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__nic,
            'auth_psk__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__nie,
            'auth_psk__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__niew,
            'auth_psk__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_psk__nisw,
            'auth_psk__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_type,
            'auth_type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_type__n,
            'auth_type__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance,
            'distance', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance__empty,
            'distance__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance__gt,
            'distance__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance__gte,
            'distance__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance__lt,
            'distance__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance__lte,
            'distance__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance__n,
            'distance__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance_unit,
            'distance_unit', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance_unit__n,
            'distance_unit__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_a_id,
            'interface_a_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_a_id__n,
            'interface_a_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_b_id,
            'interface_b_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_b_id__n,
            'interface_b_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid,
            'ssid', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__empty,
            'ssid__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__ic,
            'ssid__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__ie,
            'ssid__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__iew,
            'ssid__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__isw,
            'ssid__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__n,
            'ssid__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__nic,
            'ssid__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__nie,
            'ssid__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__niew,
            'ssid__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid__nisw,
            'ssid__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status__n,
            'status__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLinksPartialUpdate
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLinkRequest $patched_writable_wireless_link_request patched_writable_wireless_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLink
     */
    public function wirelessWirelessLinksPartialUpdate($id, $patched_writable_wireless_link_request = null, string $contentType = self::contentTypes['wirelessWirelessLinksPartialUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLinksPartialUpdateWithHttpInfo($id, $patched_writable_wireless_link_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLinksPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLinkRequest $patched_writable_wireless_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLinksPartialUpdateWithHttpInfo($id, $patched_writable_wireless_link_request = null, string $contentType = self::contentTypes['wirelessWirelessLinksPartialUpdate'][0])
    {
        $request = $this->wirelessWirelessLinksPartialUpdateRequest($id, $patched_writable_wireless_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLinksPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLinkRequest $patched_writable_wireless_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksPartialUpdateAsync($id, $patched_writable_wireless_link_request = null, string $contentType = self::contentTypes['wirelessWirelessLinksPartialUpdate'][0])
    {
        return $this->wirelessWirelessLinksPartialUpdateAsyncWithHttpInfo($id, $patched_writable_wireless_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLinksPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLinkRequest $patched_writable_wireless_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksPartialUpdateAsyncWithHttpInfo($id, $patched_writable_wireless_link_request = null, string $contentType = self::contentTypes['wirelessWirelessLinksPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLink';
        $request = $this->wirelessWirelessLinksPartialUpdateRequest($id, $patched_writable_wireless_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLinksPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableWirelessLinkRequest $patched_writable_wireless_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLinksPartialUpdateRequest($id, $patched_writable_wireless_link_request = null, string $contentType = self::contentTypes['wirelessWirelessLinksPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLinksPartialUpdate'
            );
        }



        $resourcePath = '/api/wireless/wireless-links/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_wireless_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_wireless_link_request));
            } else {
                $httpBody = $patched_writable_wireless_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLinksRetrieve
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLink
     */
    public function wirelessWirelessLinksRetrieve($id, string $contentType = self::contentTypes['wirelessWirelessLinksRetrieve'][0])
    {
        list($response) = $this->wirelessWirelessLinksRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLinksRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLinksRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLinksRetrieve'][0])
    {
        $request = $this->wirelessWirelessLinksRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLinksRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksRetrieveAsync($id, string $contentType = self::contentTypes['wirelessWirelessLinksRetrieve'][0])
    {
        return $this->wirelessWirelessLinksRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLinksRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['wirelessWirelessLinksRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLink';
        $request = $this->wirelessWirelessLinksRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLinksRetrieve'
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLinksRetrieveRequest($id, string $contentType = self::contentTypes['wirelessWirelessLinksRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLinksRetrieve'
            );
        }


        $resourcePath = '/api/wireless/wireless-links/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wirelessWirelessLinksUpdate
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLinkRequest $writable_wireless_link_request writable_wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WirelessLink
     */
    public function wirelessWirelessLinksUpdate($id, $writable_wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksUpdate'][0])
    {
        list($response) = $this->wirelessWirelessLinksUpdateWithHttpInfo($id, $writable_wireless_link_request, $contentType);
        return $response;
    }

    /**
     * Operation wirelessWirelessLinksUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLinkRequest $writable_wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WirelessLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function wirelessWirelessLinksUpdateWithHttpInfo($id, $writable_wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksUpdate'][0])
    {
        $request = $this->wirelessWirelessLinksUpdateRequest($id, $writable_wireless_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WirelessLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WirelessLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WirelessLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\WirelessLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WirelessLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wirelessWirelessLinksUpdateAsync
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLinkRequest $writable_wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksUpdateAsync($id, $writable_wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksUpdate'][0])
    {
        return $this->wirelessWirelessLinksUpdateAsyncWithHttpInfo($id, $writable_wireless_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wirelessWirelessLinksUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLinkRequest $writable_wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wirelessWirelessLinksUpdateAsyncWithHttpInfo($id, $writable_wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WirelessLink';
        $request = $this->wirelessWirelessLinksUpdateRequest($id, $writable_wireless_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wirelessWirelessLinksUpdate'
     *
     * @param  int $id A unique integer value identifying this wireless link. (required)
     * @param  \OpenAPI\Client\Model\WritableWirelessLinkRequest $writable_wireless_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wirelessWirelessLinksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wirelessWirelessLinksUpdateRequest($id, $writable_wireless_link_request, string $contentType = self::contentTypes['wirelessWirelessLinksUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling wirelessWirelessLinksUpdate'
            );
        }

        // verify the required parameter 'writable_wireless_link_request' is set
        if ($writable_wireless_link_request === null || (is_array($writable_wireless_link_request) && count($writable_wireless_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_wireless_link_request when calling wirelessWirelessLinksUpdate'
            );
        }


        $resourcePath = '/api/wireless/wireless-links/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_wireless_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_wireless_link_request));
            } else {
                $httpBody = $writable_wireless_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
