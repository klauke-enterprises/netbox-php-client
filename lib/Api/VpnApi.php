<?php
/**
 * VpnApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NetBox REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.1.1 (4.1)
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.8.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * VpnApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class VpnApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'vpnIkePoliciesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIkePoliciesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIkePoliciesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIkePoliciesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIkePoliciesDestroy' => [
            'application/json',
        ],
        'vpnIkePoliciesList' => [
            'application/json',
        ],
        'vpnIkePoliciesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIkePoliciesRetrieve' => [
            'application/json',
        ],
        'vpnIkePoliciesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIkeProposalsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIkeProposalsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIkeProposalsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIkeProposalsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIkeProposalsDestroy' => [
            'application/json',
        ],
        'vpnIkeProposalsList' => [
            'application/json',
        ],
        'vpnIkeProposalsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIkeProposalsRetrieve' => [
            'application/json',
        ],
        'vpnIkeProposalsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecPoliciesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecPoliciesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecPoliciesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecPoliciesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecPoliciesDestroy' => [
            'application/json',
        ],
        'vpnIpsecPoliciesList' => [
            'application/json',
        ],
        'vpnIpsecPoliciesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecPoliciesRetrieve' => [
            'application/json',
        ],
        'vpnIpsecPoliciesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProfilesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProfilesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProfilesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProfilesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProfilesDestroy' => [
            'application/json',
        ],
        'vpnIpsecProfilesList' => [
            'application/json',
        ],
        'vpnIpsecProfilesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProfilesRetrieve' => [
            'application/json',
        ],
        'vpnIpsecProfilesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProposalsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProposalsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProposalsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProposalsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProposalsDestroy' => [
            'application/json',
        ],
        'vpnIpsecProposalsList' => [
            'application/json',
        ],
        'vpnIpsecProposalsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnIpsecProposalsRetrieve' => [
            'application/json',
        ],
        'vpnIpsecProposalsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnTerminationsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnTerminationsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnTerminationsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnTerminationsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnTerminationsDestroy' => [
            'application/json',
        ],
        'vpnL2vpnTerminationsList' => [
            'application/json',
        ],
        'vpnL2vpnTerminationsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnTerminationsRetrieve' => [
            'application/json',
        ],
        'vpnL2vpnTerminationsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnsDestroy' => [
            'application/json',
        ],
        'vpnL2vpnsList' => [
            'application/json',
        ],
        'vpnL2vpnsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnL2vpnsRetrieve' => [
            'application/json',
        ],
        'vpnL2vpnsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelGroupsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelGroupsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelGroupsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelGroupsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelGroupsDestroy' => [
            'application/json',
        ],
        'vpnTunnelGroupsList' => [
            'application/json',
        ],
        'vpnTunnelGroupsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelGroupsRetrieve' => [
            'application/json',
        ],
        'vpnTunnelGroupsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelTerminationsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelTerminationsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelTerminationsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelTerminationsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelTerminationsDestroy' => [
            'application/json',
        ],
        'vpnTunnelTerminationsList' => [
            'application/json',
        ],
        'vpnTunnelTerminationsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelTerminationsRetrieve' => [
            'application/json',
        ],
        'vpnTunnelTerminationsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelsDestroy' => [
            'application/json',
        ],
        'vpnTunnelsList' => [
            'application/json',
        ],
        'vpnTunnelsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'vpnTunnelsRetrieve' => [
            'application/json',
        ],
        'vpnTunnelsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation vpnIkePoliciesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnIkePoliciesBulkDestroy($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkDestroy'][0])
    {
        $this->vpnIkePoliciesBulkDestroyWithHttpInfo($ike_policy_request, $contentType);
    }

    /**
     * Operation vpnIkePoliciesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkePoliciesBulkDestroyWithHttpInfo($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkDestroy'][0])
    {
        $request = $this->vpnIkePoliciesBulkDestroyRequest($ike_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkePoliciesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesBulkDestroyAsync($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkDestroy'][0])
    {
        return $this->vpnIkePoliciesBulkDestroyAsyncWithHttpInfo($ike_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkePoliciesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesBulkDestroyAsyncWithHttpInfo($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnIkePoliciesBulkDestroyRequest($ike_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkePoliciesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkePoliciesBulkDestroyRequest($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkDestroy'][0])
    {

        // verify the required parameter 'ike_policy_request' is set
        if ($ike_policy_request === null || (is_array($ike_policy_request) && count($ike_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ike_policy_request when calling vpnIkePoliciesBulkDestroy'
            );
        }


        $resourcePath = '/api/vpn/ike-policies/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ike_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ike_policy_request));
            } else {
                $httpBody = $ike_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkePoliciesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEPolicy[]
     */
    public function vpnIkePoliciesBulkPartialUpdate($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkPartialUpdate'][0])
    {
        list($response) = $this->vpnIkePoliciesBulkPartialUpdateWithHttpInfo($ike_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkePoliciesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEPolicy[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkePoliciesBulkPartialUpdateWithHttpInfo($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkPartialUpdate'][0])
    {
        $request = $this->vpnIkePoliciesBulkPartialUpdateRequest($ike_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IKEPolicy[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEPolicy[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEPolicy[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEPolicy[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEPolicy[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkePoliciesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesBulkPartialUpdateAsync($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkPartialUpdate'][0])
    {
        return $this->vpnIkePoliciesBulkPartialUpdateAsyncWithHttpInfo($ike_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkePoliciesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesBulkPartialUpdateAsyncWithHttpInfo($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEPolicy[]';
        $request = $this->vpnIkePoliciesBulkPartialUpdateRequest($ike_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkePoliciesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkePoliciesBulkPartialUpdateRequest($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'ike_policy_request' is set
        if ($ike_policy_request === null || (is_array($ike_policy_request) && count($ike_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ike_policy_request when calling vpnIkePoliciesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/vpn/ike-policies/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ike_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ike_policy_request));
            } else {
                $httpBody = $ike_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkePoliciesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEPolicy[]
     */
    public function vpnIkePoliciesBulkUpdate($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkUpdate'][0])
    {
        list($response) = $this->vpnIkePoliciesBulkUpdateWithHttpInfo($ike_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkePoliciesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEPolicy[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkePoliciesBulkUpdateWithHttpInfo($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkUpdate'][0])
    {
        $request = $this->vpnIkePoliciesBulkUpdateRequest($ike_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IKEPolicy[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEPolicy[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEPolicy[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEPolicy[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEPolicy[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkePoliciesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesBulkUpdateAsync($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkUpdate'][0])
    {
        return $this->vpnIkePoliciesBulkUpdateAsyncWithHttpInfo($ike_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkePoliciesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesBulkUpdateAsyncWithHttpInfo($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEPolicy[]';
        $request = $this->vpnIkePoliciesBulkUpdateRequest($ike_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkePoliciesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\IKEPolicyRequest[] $ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkePoliciesBulkUpdateRequest($ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesBulkUpdate'][0])
    {

        // verify the required parameter 'ike_policy_request' is set
        if ($ike_policy_request === null || (is_array($ike_policy_request) && count($ike_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ike_policy_request when calling vpnIkePoliciesBulkUpdate'
            );
        }


        $resourcePath = '/api/vpn/ike-policies/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ike_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ike_policy_request));
            } else {
                $httpBody = $ike_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkePoliciesCreate
     *
     * @param  \OpenAPI\Client\Model\WritableIKEPolicyRequest $writable_ike_policy_request writable_ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEPolicy
     */
    public function vpnIkePoliciesCreate($writable_ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesCreate'][0])
    {
        list($response) = $this->vpnIkePoliciesCreateWithHttpInfo($writable_ike_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkePoliciesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIKEPolicyRequest $writable_ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkePoliciesCreateWithHttpInfo($writable_ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesCreate'][0])
    {
        $request = $this->vpnIkePoliciesCreateRequest($writable_ike_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\IKEPolicy' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEPolicy' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEPolicy', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEPolicy';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkePoliciesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableIKEPolicyRequest $writable_ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesCreateAsync($writable_ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesCreate'][0])
    {
        return $this->vpnIkePoliciesCreateAsyncWithHttpInfo($writable_ike_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkePoliciesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIKEPolicyRequest $writable_ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesCreateAsyncWithHttpInfo($writable_ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEPolicy';
        $request = $this->vpnIkePoliciesCreateRequest($writable_ike_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkePoliciesCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableIKEPolicyRequest $writable_ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkePoliciesCreateRequest($writable_ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesCreate'][0])
    {

        // verify the required parameter 'writable_ike_policy_request' is set
        if ($writable_ike_policy_request === null || (is_array($writable_ike_policy_request) && count($writable_ike_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ike_policy_request when calling vpnIkePoliciesCreate'
            );
        }


        $resourcePath = '/api/vpn/ike-policies/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ike_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ike_policy_request));
            } else {
                $httpBody = $writable_ike_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkePoliciesDestroy
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnIkePoliciesDestroy($id, string $contentType = self::contentTypes['vpnIkePoliciesDestroy'][0])
    {
        $this->vpnIkePoliciesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation vpnIkePoliciesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkePoliciesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['vpnIkePoliciesDestroy'][0])
    {
        $request = $this->vpnIkePoliciesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkePoliciesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesDestroyAsync($id, string $contentType = self::contentTypes['vpnIkePoliciesDestroy'][0])
    {
        return $this->vpnIkePoliciesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkePoliciesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnIkePoliciesDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnIkePoliciesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkePoliciesDestroy'
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkePoliciesDestroyRequest($id, string $contentType = self::contentTypes['vpnIkePoliciesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIkePoliciesDestroy'
            );
        }


        $resourcePath = '/api/vpn/ike-policies/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkePoliciesList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $ike_proposal ike_proposal (optional)
     * @param  string[] $ike_proposal__n ike_proposal__n (optional)
     * @param  int[] $ike_proposal_id ike_proposal_id (optional)
     * @param  int[] $ike_proposal_id__n ike_proposal_id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mode mode (optional)
     * @param  string[] $mode__n mode__n (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $preshared_key preshared_key (optional)
     * @param  string $preshared_key__ic preshared_key__ic (optional)
     * @param  string $preshared_key__ie preshared_key__ie (optional)
     * @param  string $preshared_key__iew preshared_key__iew (optional)
     * @param  string $preshared_key__isw preshared_key__isw (optional)
     * @param  string $preshared_key__n preshared_key__n (optional)
     * @param  string $preshared_key__nic preshared_key__nic (optional)
     * @param  string $preshared_key__nie preshared_key__nie (optional)
     * @param  string $preshared_key__niew preshared_key__niew (optional)
     * @param  string $preshared_key__nisw preshared_key__nisw (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  int[] $version version (optional)
     * @param  int[] $version__n version__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedIKEPolicyList
     */
    public function vpnIkePoliciesList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_proposal = null, $ike_proposal__n = null, $ike_proposal_id = null, $ike_proposal_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mode = null, $mode__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $preshared_key = null, $preshared_key__ic = null, $preshared_key__ie = null, $preshared_key__iew = null, $preshared_key__isw = null, $preshared_key__n = null, $preshared_key__nic = null, $preshared_key__nie = null, $preshared_key__niew = null, $preshared_key__nisw = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, $version = null, $version__n = null, string $contentType = self::contentTypes['vpnIkePoliciesList'][0])
    {
        list($response) = $this->vpnIkePoliciesListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_proposal, $ike_proposal__n, $ike_proposal_id, $ike_proposal_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mode, $mode__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $preshared_key, $preshared_key__ic, $preshared_key__ie, $preshared_key__iew, $preshared_key__isw, $preshared_key__n, $preshared_key__nic, $preshared_key__nie, $preshared_key__niew, $preshared_key__nisw, $q, $tag, $tag__n, $updated_by_request, $version, $version__n, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkePoliciesListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_proposal (optional)
     * @param  string[] $ike_proposal__n (optional)
     * @param  int[] $ike_proposal_id (optional)
     * @param  int[] $ike_proposal_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mode (optional)
     * @param  string[] $mode__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $preshared_key (optional)
     * @param  string $preshared_key__ic (optional)
     * @param  string $preshared_key__ie (optional)
     * @param  string $preshared_key__iew (optional)
     * @param  string $preshared_key__isw (optional)
     * @param  string $preshared_key__n (optional)
     * @param  string $preshared_key__nic (optional)
     * @param  string $preshared_key__nie (optional)
     * @param  string $preshared_key__niew (optional)
     * @param  string $preshared_key__nisw (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $version (optional)
     * @param  int[] $version__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedIKEPolicyList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkePoliciesListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_proposal = null, $ike_proposal__n = null, $ike_proposal_id = null, $ike_proposal_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mode = null, $mode__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $preshared_key = null, $preshared_key__ic = null, $preshared_key__ie = null, $preshared_key__iew = null, $preshared_key__isw = null, $preshared_key__n = null, $preshared_key__nic = null, $preshared_key__nie = null, $preshared_key__niew = null, $preshared_key__nisw = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, $version = null, $version__n = null, string $contentType = self::contentTypes['vpnIkePoliciesList'][0])
    {
        $request = $this->vpnIkePoliciesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_proposal, $ike_proposal__n, $ike_proposal_id, $ike_proposal_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mode, $mode__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $preshared_key, $preshared_key__ic, $preshared_key__ie, $preshared_key__iew, $preshared_key__isw, $preshared_key__n, $preshared_key__nic, $preshared_key__nie, $preshared_key__niew, $preshared_key__nisw, $q, $tag, $tag__n, $updated_by_request, $version, $version__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedIKEPolicyList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedIKEPolicyList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedIKEPolicyList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedIKEPolicyList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedIKEPolicyList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkePoliciesListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_proposal (optional)
     * @param  string[] $ike_proposal__n (optional)
     * @param  int[] $ike_proposal_id (optional)
     * @param  int[] $ike_proposal_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mode (optional)
     * @param  string[] $mode__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $preshared_key (optional)
     * @param  string $preshared_key__ic (optional)
     * @param  string $preshared_key__ie (optional)
     * @param  string $preshared_key__iew (optional)
     * @param  string $preshared_key__isw (optional)
     * @param  string $preshared_key__n (optional)
     * @param  string $preshared_key__nic (optional)
     * @param  string $preshared_key__nie (optional)
     * @param  string $preshared_key__niew (optional)
     * @param  string $preshared_key__nisw (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $version (optional)
     * @param  int[] $version__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_proposal = null, $ike_proposal__n = null, $ike_proposal_id = null, $ike_proposal_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mode = null, $mode__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $preshared_key = null, $preshared_key__ic = null, $preshared_key__ie = null, $preshared_key__iew = null, $preshared_key__isw = null, $preshared_key__n = null, $preshared_key__nic = null, $preshared_key__nie = null, $preshared_key__niew = null, $preshared_key__nisw = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, $version = null, $version__n = null, string $contentType = self::contentTypes['vpnIkePoliciesList'][0])
    {
        return $this->vpnIkePoliciesListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_proposal, $ike_proposal__n, $ike_proposal_id, $ike_proposal_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mode, $mode__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $preshared_key, $preshared_key__ic, $preshared_key__ie, $preshared_key__iew, $preshared_key__isw, $preshared_key__n, $preshared_key__nic, $preshared_key__nie, $preshared_key__niew, $preshared_key__nisw, $q, $tag, $tag__n, $updated_by_request, $version, $version__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkePoliciesListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_proposal (optional)
     * @param  string[] $ike_proposal__n (optional)
     * @param  int[] $ike_proposal_id (optional)
     * @param  int[] $ike_proposal_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mode (optional)
     * @param  string[] $mode__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $preshared_key (optional)
     * @param  string $preshared_key__ic (optional)
     * @param  string $preshared_key__ie (optional)
     * @param  string $preshared_key__iew (optional)
     * @param  string $preshared_key__isw (optional)
     * @param  string $preshared_key__n (optional)
     * @param  string $preshared_key__nic (optional)
     * @param  string $preshared_key__nie (optional)
     * @param  string $preshared_key__niew (optional)
     * @param  string $preshared_key__nisw (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $version (optional)
     * @param  int[] $version__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_proposal = null, $ike_proposal__n = null, $ike_proposal_id = null, $ike_proposal_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mode = null, $mode__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $preshared_key = null, $preshared_key__ic = null, $preshared_key__ie = null, $preshared_key__iew = null, $preshared_key__isw = null, $preshared_key__n = null, $preshared_key__nic = null, $preshared_key__nie = null, $preshared_key__niew = null, $preshared_key__nisw = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, $version = null, $version__n = null, string $contentType = self::contentTypes['vpnIkePoliciesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedIKEPolicyList';
        $request = $this->vpnIkePoliciesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_proposal, $ike_proposal__n, $ike_proposal_id, $ike_proposal_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mode, $mode__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $preshared_key, $preshared_key__ic, $preshared_key__ie, $preshared_key__iew, $preshared_key__isw, $preshared_key__n, $preshared_key__nic, $preshared_key__nie, $preshared_key__niew, $preshared_key__nisw, $q, $tag, $tag__n, $updated_by_request, $version, $version__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkePoliciesList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_proposal (optional)
     * @param  string[] $ike_proposal__n (optional)
     * @param  int[] $ike_proposal_id (optional)
     * @param  int[] $ike_proposal_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mode (optional)
     * @param  string[] $mode__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $preshared_key (optional)
     * @param  string $preshared_key__ic (optional)
     * @param  string $preshared_key__ie (optional)
     * @param  string $preshared_key__iew (optional)
     * @param  string $preshared_key__isw (optional)
     * @param  string $preshared_key__n (optional)
     * @param  string $preshared_key__nic (optional)
     * @param  string $preshared_key__nie (optional)
     * @param  string $preshared_key__niew (optional)
     * @param  string $preshared_key__nisw (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $version (optional)
     * @param  int[] $version__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkePoliciesListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_proposal = null, $ike_proposal__n = null, $ike_proposal_id = null, $ike_proposal_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mode = null, $mode__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $preshared_key = null, $preshared_key__ic = null, $preshared_key__ie = null, $preshared_key__iew = null, $preshared_key__isw = null, $preshared_key__n = null, $preshared_key__nic = null, $preshared_key__nie = null, $preshared_key__niew = null, $preshared_key__nisw = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, $version = null, $version__n = null, string $contentType = self::contentTypes['vpnIkePoliciesList'][0])
    {








































































        $resourcePath = '/api/vpn/ike-policies/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_proposal,
            'ike_proposal', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_proposal__n,
            'ike_proposal__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_proposal_id,
            'ike_proposal_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_proposal_id__n,
            'ike_proposal_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mode,
            'mode', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mode__n,
            'mode__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $preshared_key,
            'preshared_key', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $preshared_key__ic,
            'preshared_key__ic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $preshared_key__ie,
            'preshared_key__ie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $preshared_key__iew,
            'preshared_key__iew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $preshared_key__isw,
            'preshared_key__isw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $preshared_key__n,
            'preshared_key__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $preshared_key__nic,
            'preshared_key__nic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $preshared_key__nie,
            'preshared_key__nie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $preshared_key__niew,
            'preshared_key__niew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $preshared_key__nisw,
            'preshared_key__nisw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version__n,
            'version__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkePoliciesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIKEPolicyRequest $patched_writable_ike_policy_request patched_writable_ike_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEPolicy
     */
    public function vpnIkePoliciesPartialUpdate($id, $patched_writable_ike_policy_request = null, string $contentType = self::contentTypes['vpnIkePoliciesPartialUpdate'][0])
    {
        list($response) = $this->vpnIkePoliciesPartialUpdateWithHttpInfo($id, $patched_writable_ike_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkePoliciesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIKEPolicyRequest $patched_writable_ike_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkePoliciesPartialUpdateWithHttpInfo($id, $patched_writable_ike_policy_request = null, string $contentType = self::contentTypes['vpnIkePoliciesPartialUpdate'][0])
    {
        $request = $this->vpnIkePoliciesPartialUpdateRequest($id, $patched_writable_ike_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IKEPolicy' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEPolicy' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEPolicy', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEPolicy';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkePoliciesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIKEPolicyRequest $patched_writable_ike_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesPartialUpdateAsync($id, $patched_writable_ike_policy_request = null, string $contentType = self::contentTypes['vpnIkePoliciesPartialUpdate'][0])
    {
        return $this->vpnIkePoliciesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ike_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkePoliciesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIKEPolicyRequest $patched_writable_ike_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ike_policy_request = null, string $contentType = self::contentTypes['vpnIkePoliciesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEPolicy';
        $request = $this->vpnIkePoliciesPartialUpdateRequest($id, $patched_writable_ike_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkePoliciesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIKEPolicyRequest $patched_writable_ike_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkePoliciesPartialUpdateRequest($id, $patched_writable_ike_policy_request = null, string $contentType = self::contentTypes['vpnIkePoliciesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIkePoliciesPartialUpdate'
            );
        }



        $resourcePath = '/api/vpn/ike-policies/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_ike_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_ike_policy_request));
            } else {
                $httpBody = $patched_writable_ike_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkePoliciesRetrieve
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEPolicy
     */
    public function vpnIkePoliciesRetrieve($id, string $contentType = self::contentTypes['vpnIkePoliciesRetrieve'][0])
    {
        list($response) = $this->vpnIkePoliciesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkePoliciesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkePoliciesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['vpnIkePoliciesRetrieve'][0])
    {
        $request = $this->vpnIkePoliciesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IKEPolicy' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEPolicy' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEPolicy', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEPolicy';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkePoliciesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesRetrieveAsync($id, string $contentType = self::contentTypes['vpnIkePoliciesRetrieve'][0])
    {
        return $this->vpnIkePoliciesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkePoliciesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnIkePoliciesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEPolicy';
        $request = $this->vpnIkePoliciesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkePoliciesRetrieve'
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkePoliciesRetrieveRequest($id, string $contentType = self::contentTypes['vpnIkePoliciesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIkePoliciesRetrieve'
            );
        }


        $resourcePath = '/api/vpn/ike-policies/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkePoliciesUpdate
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  \OpenAPI\Client\Model\WritableIKEPolicyRequest $writable_ike_policy_request writable_ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEPolicy
     */
    public function vpnIkePoliciesUpdate($id, $writable_ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesUpdate'][0])
    {
        list($response) = $this->vpnIkePoliciesUpdateWithHttpInfo($id, $writable_ike_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkePoliciesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  \OpenAPI\Client\Model\WritableIKEPolicyRequest $writable_ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkePoliciesUpdateWithHttpInfo($id, $writable_ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesUpdate'][0])
    {
        $request = $this->vpnIkePoliciesUpdateRequest($id, $writable_ike_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IKEPolicy' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEPolicy' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEPolicy', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEPolicy';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkePoliciesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  \OpenAPI\Client\Model\WritableIKEPolicyRequest $writable_ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesUpdateAsync($id, $writable_ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesUpdate'][0])
    {
        return $this->vpnIkePoliciesUpdateAsyncWithHttpInfo($id, $writable_ike_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkePoliciesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  \OpenAPI\Client\Model\WritableIKEPolicyRequest $writable_ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkePoliciesUpdateAsyncWithHttpInfo($id, $writable_ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEPolicy';
        $request = $this->vpnIkePoliciesUpdateRequest($id, $writable_ike_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkePoliciesUpdate'
     *
     * @param  int $id A unique integer value identifying this IKE policy. (required)
     * @param  \OpenAPI\Client\Model\WritableIKEPolicyRequest $writable_ike_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkePoliciesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkePoliciesUpdateRequest($id, $writable_ike_policy_request, string $contentType = self::contentTypes['vpnIkePoliciesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIkePoliciesUpdate'
            );
        }

        // verify the required parameter 'writable_ike_policy_request' is set
        if ($writable_ike_policy_request === null || (is_array($writable_ike_policy_request) && count($writable_ike_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ike_policy_request when calling vpnIkePoliciesUpdate'
            );
        }


        $resourcePath = '/api/vpn/ike-policies/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ike_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ike_policy_request));
            } else {
                $httpBody = $writable_ike_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkeProposalsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnIkeProposalsBulkDestroy($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkDestroy'][0])
    {
        $this->vpnIkeProposalsBulkDestroyWithHttpInfo($ike_proposal_request, $contentType);
    }

    /**
     * Operation vpnIkeProposalsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkeProposalsBulkDestroyWithHttpInfo($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkDestroy'][0])
    {
        $request = $this->vpnIkeProposalsBulkDestroyRequest($ike_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkeProposalsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsBulkDestroyAsync($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkDestroy'][0])
    {
        return $this->vpnIkeProposalsBulkDestroyAsyncWithHttpInfo($ike_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkeProposalsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsBulkDestroyAsyncWithHttpInfo($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnIkeProposalsBulkDestroyRequest($ike_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkeProposalsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkeProposalsBulkDestroyRequest($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkDestroy'][0])
    {

        // verify the required parameter 'ike_proposal_request' is set
        if ($ike_proposal_request === null || (is_array($ike_proposal_request) && count($ike_proposal_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ike_proposal_request when calling vpnIkeProposalsBulkDestroy'
            );
        }


        $resourcePath = '/api/vpn/ike-proposals/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ike_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ike_proposal_request));
            } else {
                $httpBody = $ike_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkeProposalsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEProposal[]
     */
    public function vpnIkeProposalsBulkPartialUpdate($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkPartialUpdate'][0])
    {
        list($response) = $this->vpnIkeProposalsBulkPartialUpdateWithHttpInfo($ike_proposal_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkeProposalsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEProposal[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkeProposalsBulkPartialUpdateWithHttpInfo($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkPartialUpdate'][0])
    {
        $request = $this->vpnIkeProposalsBulkPartialUpdateRequest($ike_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IKEProposal[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEProposal[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEProposal[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEProposal[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEProposal[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkeProposalsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsBulkPartialUpdateAsync($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkPartialUpdate'][0])
    {
        return $this->vpnIkeProposalsBulkPartialUpdateAsyncWithHttpInfo($ike_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkeProposalsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsBulkPartialUpdateAsyncWithHttpInfo($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEProposal[]';
        $request = $this->vpnIkeProposalsBulkPartialUpdateRequest($ike_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkeProposalsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkeProposalsBulkPartialUpdateRequest($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'ike_proposal_request' is set
        if ($ike_proposal_request === null || (is_array($ike_proposal_request) && count($ike_proposal_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ike_proposal_request when calling vpnIkeProposalsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/vpn/ike-proposals/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ike_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ike_proposal_request));
            } else {
                $httpBody = $ike_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkeProposalsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEProposal[]
     */
    public function vpnIkeProposalsBulkUpdate($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkUpdate'][0])
    {
        list($response) = $this->vpnIkeProposalsBulkUpdateWithHttpInfo($ike_proposal_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkeProposalsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEProposal[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkeProposalsBulkUpdateWithHttpInfo($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkUpdate'][0])
    {
        $request = $this->vpnIkeProposalsBulkUpdateRequest($ike_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IKEProposal[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEProposal[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEProposal[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEProposal[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEProposal[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkeProposalsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsBulkUpdateAsync($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkUpdate'][0])
    {
        return $this->vpnIkeProposalsBulkUpdateAsyncWithHttpInfo($ike_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkeProposalsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsBulkUpdateAsyncWithHttpInfo($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEProposal[]';
        $request = $this->vpnIkeProposalsBulkUpdateRequest($ike_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkeProposalsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\IKEProposalRequest[] $ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkeProposalsBulkUpdateRequest($ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsBulkUpdate'][0])
    {

        // verify the required parameter 'ike_proposal_request' is set
        if ($ike_proposal_request === null || (is_array($ike_proposal_request) && count($ike_proposal_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ike_proposal_request when calling vpnIkeProposalsBulkUpdate'
            );
        }


        $resourcePath = '/api/vpn/ike-proposals/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ike_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ike_proposal_request));
            } else {
                $httpBody = $ike_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkeProposalsCreate
     *
     * @param  \OpenAPI\Client\Model\WritableIKEProposalRequest $writable_ike_proposal_request writable_ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEProposal
     */
    public function vpnIkeProposalsCreate($writable_ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsCreate'][0])
    {
        list($response) = $this->vpnIkeProposalsCreateWithHttpInfo($writable_ike_proposal_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkeProposalsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIKEProposalRequest $writable_ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEProposal, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkeProposalsCreateWithHttpInfo($writable_ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsCreate'][0])
    {
        $request = $this->vpnIkeProposalsCreateRequest($writable_ike_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\IKEProposal' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEProposal' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEProposal', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEProposal';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEProposal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkeProposalsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableIKEProposalRequest $writable_ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsCreateAsync($writable_ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsCreate'][0])
    {
        return $this->vpnIkeProposalsCreateAsyncWithHttpInfo($writable_ike_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkeProposalsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIKEProposalRequest $writable_ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsCreateAsyncWithHttpInfo($writable_ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEProposal';
        $request = $this->vpnIkeProposalsCreateRequest($writable_ike_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkeProposalsCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableIKEProposalRequest $writable_ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkeProposalsCreateRequest($writable_ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsCreate'][0])
    {

        // verify the required parameter 'writable_ike_proposal_request' is set
        if ($writable_ike_proposal_request === null || (is_array($writable_ike_proposal_request) && count($writable_ike_proposal_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ike_proposal_request when calling vpnIkeProposalsCreate'
            );
        }


        $resourcePath = '/api/vpn/ike-proposals/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ike_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ike_proposal_request));
            } else {
                $httpBody = $writable_ike_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkeProposalsDestroy
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnIkeProposalsDestroy($id, string $contentType = self::contentTypes['vpnIkeProposalsDestroy'][0])
    {
        $this->vpnIkeProposalsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation vpnIkeProposalsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkeProposalsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['vpnIkeProposalsDestroy'][0])
    {
        $request = $this->vpnIkeProposalsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkeProposalsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsDestroyAsync($id, string $contentType = self::contentTypes['vpnIkeProposalsDestroy'][0])
    {
        return $this->vpnIkeProposalsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkeProposalsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnIkeProposalsDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnIkeProposalsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkeProposalsDestroy'
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkeProposalsDestroyRequest($id, string $contentType = self::contentTypes['vpnIkeProposalsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIkeProposalsDestroy'
            );
        }


        $resourcePath = '/api/vpn/ike-proposals/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkeProposalsList
     *
     * @param  string[] $authentication_algorithm authentication_algorithm (optional)
     * @param  string[] $authentication_algorithm__n authentication_algorithm__n (optional)
     * @param  string[] $authentication_method authentication_method (optional)
     * @param  string[] $authentication_method__n authentication_method__n (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $encryption_algorithm encryption_algorithm (optional)
     * @param  string[] $encryption_algorithm__n encryption_algorithm__n (optional)
     * @param  int[] $group Diffie-Hellman group ID (optional)
     * @param  int[] $group__n Diffie-Hellman group ID (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $ike_policy IKE policy (name) (optional)
     * @param  string[] $ike_policy__n IKE policy (name) (optional)
     * @param  int[] $ike_policy_id IKE policy (ID) (optional)
     * @param  int[] $ike_policy_id__n IKE policy (ID) (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $sa_lifetime sa_lifetime (optional)
     * @param  bool $sa_lifetime__empty sa_lifetime__empty (optional)
     * @param  int[] $sa_lifetime__gt sa_lifetime__gt (optional)
     * @param  int[] $sa_lifetime__gte sa_lifetime__gte (optional)
     * @param  int[] $sa_lifetime__lt sa_lifetime__lt (optional)
     * @param  int[] $sa_lifetime__lte sa_lifetime__lte (optional)
     * @param  int[] $sa_lifetime__n sa_lifetime__n (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedIKEProposalList
     */
    public function vpnIkeProposalsList($authentication_algorithm = null, $authentication_algorithm__n = null, $authentication_method = null, $authentication_method__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encryption_algorithm = null, $encryption_algorithm__n = null, $group = null, $group__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_policy = null, $ike_policy__n = null, $ike_policy_id = null, $ike_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $sa_lifetime = null, $sa_lifetime__empty = null, $sa_lifetime__gt = null, $sa_lifetime__gte = null, $sa_lifetime__lt = null, $sa_lifetime__lte = null, $sa_lifetime__n = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIkeProposalsList'][0])
    {
        list($response) = $this->vpnIkeProposalsListWithHttpInfo($authentication_algorithm, $authentication_algorithm__n, $authentication_method, $authentication_method__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encryption_algorithm, $encryption_algorithm__n, $group, $group__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_policy, $ike_policy__n, $ike_policy_id, $ike_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $sa_lifetime, $sa_lifetime__empty, $sa_lifetime__gt, $sa_lifetime__gte, $sa_lifetime__lt, $sa_lifetime__lte, $sa_lifetime__n, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkeProposalsListWithHttpInfo
     *
     * @param  string[] $authentication_algorithm (optional)
     * @param  string[] $authentication_algorithm__n (optional)
     * @param  string[] $authentication_method (optional)
     * @param  string[] $authentication_method__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encryption_algorithm (optional)
     * @param  string[] $encryption_algorithm__n (optional)
     * @param  int[] $group Diffie-Hellman group ID (optional)
     * @param  int[] $group__n Diffie-Hellman group ID (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_policy IKE policy (name) (optional)
     * @param  string[] $ike_policy__n IKE policy (name) (optional)
     * @param  int[] $ike_policy_id IKE policy (ID) (optional)
     * @param  int[] $ike_policy_id__n IKE policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $sa_lifetime (optional)
     * @param  bool $sa_lifetime__empty (optional)
     * @param  int[] $sa_lifetime__gt (optional)
     * @param  int[] $sa_lifetime__gte (optional)
     * @param  int[] $sa_lifetime__lt (optional)
     * @param  int[] $sa_lifetime__lte (optional)
     * @param  int[] $sa_lifetime__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedIKEProposalList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkeProposalsListWithHttpInfo($authentication_algorithm = null, $authentication_algorithm__n = null, $authentication_method = null, $authentication_method__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encryption_algorithm = null, $encryption_algorithm__n = null, $group = null, $group__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_policy = null, $ike_policy__n = null, $ike_policy_id = null, $ike_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $sa_lifetime = null, $sa_lifetime__empty = null, $sa_lifetime__gt = null, $sa_lifetime__gte = null, $sa_lifetime__lt = null, $sa_lifetime__lte = null, $sa_lifetime__n = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIkeProposalsList'][0])
    {
        $request = $this->vpnIkeProposalsListRequest($authentication_algorithm, $authentication_algorithm__n, $authentication_method, $authentication_method__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encryption_algorithm, $encryption_algorithm__n, $group, $group__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_policy, $ike_policy__n, $ike_policy_id, $ike_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $sa_lifetime, $sa_lifetime__empty, $sa_lifetime__gt, $sa_lifetime__gte, $sa_lifetime__lt, $sa_lifetime__lte, $sa_lifetime__n, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedIKEProposalList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedIKEProposalList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedIKEProposalList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedIKEProposalList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedIKEProposalList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkeProposalsListAsync
     *
     * @param  string[] $authentication_algorithm (optional)
     * @param  string[] $authentication_algorithm__n (optional)
     * @param  string[] $authentication_method (optional)
     * @param  string[] $authentication_method__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encryption_algorithm (optional)
     * @param  string[] $encryption_algorithm__n (optional)
     * @param  int[] $group Diffie-Hellman group ID (optional)
     * @param  int[] $group__n Diffie-Hellman group ID (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_policy IKE policy (name) (optional)
     * @param  string[] $ike_policy__n IKE policy (name) (optional)
     * @param  int[] $ike_policy_id IKE policy (ID) (optional)
     * @param  int[] $ike_policy_id__n IKE policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $sa_lifetime (optional)
     * @param  bool $sa_lifetime__empty (optional)
     * @param  int[] $sa_lifetime__gt (optional)
     * @param  int[] $sa_lifetime__gte (optional)
     * @param  int[] $sa_lifetime__lt (optional)
     * @param  int[] $sa_lifetime__lte (optional)
     * @param  int[] $sa_lifetime__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsListAsync($authentication_algorithm = null, $authentication_algorithm__n = null, $authentication_method = null, $authentication_method__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encryption_algorithm = null, $encryption_algorithm__n = null, $group = null, $group__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_policy = null, $ike_policy__n = null, $ike_policy_id = null, $ike_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $sa_lifetime = null, $sa_lifetime__empty = null, $sa_lifetime__gt = null, $sa_lifetime__gte = null, $sa_lifetime__lt = null, $sa_lifetime__lte = null, $sa_lifetime__n = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIkeProposalsList'][0])
    {
        return $this->vpnIkeProposalsListAsyncWithHttpInfo($authentication_algorithm, $authentication_algorithm__n, $authentication_method, $authentication_method__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encryption_algorithm, $encryption_algorithm__n, $group, $group__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_policy, $ike_policy__n, $ike_policy_id, $ike_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $sa_lifetime, $sa_lifetime__empty, $sa_lifetime__gt, $sa_lifetime__gte, $sa_lifetime__lt, $sa_lifetime__lte, $sa_lifetime__n, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkeProposalsListAsyncWithHttpInfo
     *
     * @param  string[] $authentication_algorithm (optional)
     * @param  string[] $authentication_algorithm__n (optional)
     * @param  string[] $authentication_method (optional)
     * @param  string[] $authentication_method__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encryption_algorithm (optional)
     * @param  string[] $encryption_algorithm__n (optional)
     * @param  int[] $group Diffie-Hellman group ID (optional)
     * @param  int[] $group__n Diffie-Hellman group ID (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_policy IKE policy (name) (optional)
     * @param  string[] $ike_policy__n IKE policy (name) (optional)
     * @param  int[] $ike_policy_id IKE policy (ID) (optional)
     * @param  int[] $ike_policy_id__n IKE policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $sa_lifetime (optional)
     * @param  bool $sa_lifetime__empty (optional)
     * @param  int[] $sa_lifetime__gt (optional)
     * @param  int[] $sa_lifetime__gte (optional)
     * @param  int[] $sa_lifetime__lt (optional)
     * @param  int[] $sa_lifetime__lte (optional)
     * @param  int[] $sa_lifetime__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsListAsyncWithHttpInfo($authentication_algorithm = null, $authentication_algorithm__n = null, $authentication_method = null, $authentication_method__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encryption_algorithm = null, $encryption_algorithm__n = null, $group = null, $group__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_policy = null, $ike_policy__n = null, $ike_policy_id = null, $ike_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $sa_lifetime = null, $sa_lifetime__empty = null, $sa_lifetime__gt = null, $sa_lifetime__gte = null, $sa_lifetime__lt = null, $sa_lifetime__lte = null, $sa_lifetime__n = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIkeProposalsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedIKEProposalList';
        $request = $this->vpnIkeProposalsListRequest($authentication_algorithm, $authentication_algorithm__n, $authentication_method, $authentication_method__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encryption_algorithm, $encryption_algorithm__n, $group, $group__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_policy, $ike_policy__n, $ike_policy_id, $ike_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $sa_lifetime, $sa_lifetime__empty, $sa_lifetime__gt, $sa_lifetime__gte, $sa_lifetime__lt, $sa_lifetime__lte, $sa_lifetime__n, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkeProposalsList'
     *
     * @param  string[] $authentication_algorithm (optional)
     * @param  string[] $authentication_algorithm__n (optional)
     * @param  string[] $authentication_method (optional)
     * @param  string[] $authentication_method__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encryption_algorithm (optional)
     * @param  string[] $encryption_algorithm__n (optional)
     * @param  int[] $group Diffie-Hellman group ID (optional)
     * @param  int[] $group__n Diffie-Hellman group ID (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_policy IKE policy (name) (optional)
     * @param  string[] $ike_policy__n IKE policy (name) (optional)
     * @param  int[] $ike_policy_id IKE policy (ID) (optional)
     * @param  int[] $ike_policy_id__n IKE policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $sa_lifetime (optional)
     * @param  bool $sa_lifetime__empty (optional)
     * @param  int[] $sa_lifetime__gt (optional)
     * @param  int[] $sa_lifetime__gte (optional)
     * @param  int[] $sa_lifetime__lt (optional)
     * @param  int[] $sa_lifetime__lte (optional)
     * @param  int[] $sa_lifetime__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkeProposalsListRequest($authentication_algorithm = null, $authentication_algorithm__n = null, $authentication_method = null, $authentication_method__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encryption_algorithm = null, $encryption_algorithm__n = null, $group = null, $group__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_policy = null, $ike_policy__n = null, $ike_policy_id = null, $ike_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $sa_lifetime = null, $sa_lifetime__empty = null, $sa_lifetime__gt = null, $sa_lifetime__gte = null, $sa_lifetime__lt = null, $sa_lifetime__lte = null, $sa_lifetime__n = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIkeProposalsList'][0])
    {









































































        $resourcePath = '/api/vpn/ike-proposals/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $authentication_algorithm,
            'authentication_algorithm', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $authentication_algorithm__n,
            'authentication_algorithm__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $authentication_method,
            'authentication_method', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $authentication_method__n,
            'authentication_method__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $encryption_algorithm,
            'encryption_algorithm', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $encryption_algorithm__n,
            'encryption_algorithm__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group,
            'group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group__n,
            'group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_policy,
            'ike_policy', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_policy__n,
            'ike_policy__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_policy_id,
            'ike_policy_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_policy_id__n,
            'ike_policy_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime,
            'sa_lifetime', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime__empty,
            'sa_lifetime__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime__gt,
            'sa_lifetime__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime__gte,
            'sa_lifetime__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime__lt,
            'sa_lifetime__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime__lte,
            'sa_lifetime__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime__n,
            'sa_lifetime__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkeProposalsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIKEProposalRequest $patched_writable_ike_proposal_request patched_writable_ike_proposal_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEProposal
     */
    public function vpnIkeProposalsPartialUpdate($id, $patched_writable_ike_proposal_request = null, string $contentType = self::contentTypes['vpnIkeProposalsPartialUpdate'][0])
    {
        list($response) = $this->vpnIkeProposalsPartialUpdateWithHttpInfo($id, $patched_writable_ike_proposal_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkeProposalsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIKEProposalRequest $patched_writable_ike_proposal_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEProposal, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkeProposalsPartialUpdateWithHttpInfo($id, $patched_writable_ike_proposal_request = null, string $contentType = self::contentTypes['vpnIkeProposalsPartialUpdate'][0])
    {
        $request = $this->vpnIkeProposalsPartialUpdateRequest($id, $patched_writable_ike_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IKEProposal' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEProposal' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEProposal', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEProposal';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEProposal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkeProposalsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIKEProposalRequest $patched_writable_ike_proposal_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsPartialUpdateAsync($id, $patched_writable_ike_proposal_request = null, string $contentType = self::contentTypes['vpnIkeProposalsPartialUpdate'][0])
    {
        return $this->vpnIkeProposalsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ike_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkeProposalsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIKEProposalRequest $patched_writable_ike_proposal_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ike_proposal_request = null, string $contentType = self::contentTypes['vpnIkeProposalsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEProposal';
        $request = $this->vpnIkeProposalsPartialUpdateRequest($id, $patched_writable_ike_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkeProposalsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIKEProposalRequest $patched_writable_ike_proposal_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkeProposalsPartialUpdateRequest($id, $patched_writable_ike_proposal_request = null, string $contentType = self::contentTypes['vpnIkeProposalsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIkeProposalsPartialUpdate'
            );
        }



        $resourcePath = '/api/vpn/ike-proposals/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_ike_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_ike_proposal_request));
            } else {
                $httpBody = $patched_writable_ike_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkeProposalsRetrieve
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEProposal
     */
    public function vpnIkeProposalsRetrieve($id, string $contentType = self::contentTypes['vpnIkeProposalsRetrieve'][0])
    {
        list($response) = $this->vpnIkeProposalsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkeProposalsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEProposal, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkeProposalsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['vpnIkeProposalsRetrieve'][0])
    {
        $request = $this->vpnIkeProposalsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IKEProposal' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEProposal' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEProposal', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEProposal';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEProposal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkeProposalsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsRetrieveAsync($id, string $contentType = self::contentTypes['vpnIkeProposalsRetrieve'][0])
    {
        return $this->vpnIkeProposalsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkeProposalsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnIkeProposalsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEProposal';
        $request = $this->vpnIkeProposalsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkeProposalsRetrieve'
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkeProposalsRetrieveRequest($id, string $contentType = self::contentTypes['vpnIkeProposalsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIkeProposalsRetrieve'
            );
        }


        $resourcePath = '/api/vpn/ike-proposals/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIkeProposalsUpdate
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  \OpenAPI\Client\Model\WritableIKEProposalRequest $writable_ike_proposal_request writable_ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IKEProposal
     */
    public function vpnIkeProposalsUpdate($id, $writable_ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsUpdate'][0])
    {
        list($response) = $this->vpnIkeProposalsUpdateWithHttpInfo($id, $writable_ike_proposal_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIkeProposalsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  \OpenAPI\Client\Model\WritableIKEProposalRequest $writable_ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IKEProposal, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIkeProposalsUpdateWithHttpInfo($id, $writable_ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsUpdate'][0])
    {
        $request = $this->vpnIkeProposalsUpdateRequest($id, $writable_ike_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IKEProposal' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IKEProposal' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IKEProposal', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IKEProposal';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IKEProposal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIkeProposalsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  \OpenAPI\Client\Model\WritableIKEProposalRequest $writable_ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsUpdateAsync($id, $writable_ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsUpdate'][0])
    {
        return $this->vpnIkeProposalsUpdateAsyncWithHttpInfo($id, $writable_ike_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIkeProposalsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  \OpenAPI\Client\Model\WritableIKEProposalRequest $writable_ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIkeProposalsUpdateAsyncWithHttpInfo($id, $writable_ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IKEProposal';
        $request = $this->vpnIkeProposalsUpdateRequest($id, $writable_ike_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIkeProposalsUpdate'
     *
     * @param  int $id A unique integer value identifying this IKE proposal. (required)
     * @param  \OpenAPI\Client\Model\WritableIKEProposalRequest $writable_ike_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIkeProposalsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIkeProposalsUpdateRequest($id, $writable_ike_proposal_request, string $contentType = self::contentTypes['vpnIkeProposalsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIkeProposalsUpdate'
            );
        }

        // verify the required parameter 'writable_ike_proposal_request' is set
        if ($writable_ike_proposal_request === null || (is_array($writable_ike_proposal_request) && count($writable_ike_proposal_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ike_proposal_request when calling vpnIkeProposalsUpdate'
            );
        }


        $resourcePath = '/api/vpn/ike-proposals/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ike_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ike_proposal_request));
            } else {
                $httpBody = $writable_ike_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecPoliciesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnIpsecPoliciesBulkDestroy($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkDestroy'][0])
    {
        $this->vpnIpsecPoliciesBulkDestroyWithHttpInfo($ip_sec_policy_request, $contentType);
    }

    /**
     * Operation vpnIpsecPoliciesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecPoliciesBulkDestroyWithHttpInfo($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkDestroy'][0])
    {
        $request = $this->vpnIpsecPoliciesBulkDestroyRequest($ip_sec_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecPoliciesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesBulkDestroyAsync($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkDestroy'][0])
    {
        return $this->vpnIpsecPoliciesBulkDestroyAsyncWithHttpInfo($ip_sec_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecPoliciesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesBulkDestroyAsyncWithHttpInfo($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnIpsecPoliciesBulkDestroyRequest($ip_sec_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecPoliciesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecPoliciesBulkDestroyRequest($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkDestroy'][0])
    {

        // verify the required parameter 'ip_sec_policy_request' is set
        if ($ip_sec_policy_request === null || (is_array($ip_sec_policy_request) && count($ip_sec_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_sec_policy_request when calling vpnIpsecPoliciesBulkDestroy'
            );
        }


        $resourcePath = '/api/vpn/ipsec-policies/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_sec_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_sec_policy_request));
            } else {
                $httpBody = $ip_sec_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecPoliciesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecPolicy[]
     */
    public function vpnIpsecPoliciesBulkPartialUpdate($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkPartialUpdate'][0])
    {
        list($response) = $this->vpnIpsecPoliciesBulkPartialUpdateWithHttpInfo($ip_sec_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecPoliciesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecPolicy[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecPoliciesBulkPartialUpdateWithHttpInfo($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkPartialUpdate'][0])
    {
        $request = $this->vpnIpsecPoliciesBulkPartialUpdateRequest($ip_sec_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecPolicy[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecPolicy[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecPolicy[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecPolicy[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecPolicy[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecPoliciesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesBulkPartialUpdateAsync($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkPartialUpdate'][0])
    {
        return $this->vpnIpsecPoliciesBulkPartialUpdateAsyncWithHttpInfo($ip_sec_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecPoliciesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesBulkPartialUpdateAsyncWithHttpInfo($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecPolicy[]';
        $request = $this->vpnIpsecPoliciesBulkPartialUpdateRequest($ip_sec_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecPoliciesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecPoliciesBulkPartialUpdateRequest($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'ip_sec_policy_request' is set
        if ($ip_sec_policy_request === null || (is_array($ip_sec_policy_request) && count($ip_sec_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_sec_policy_request when calling vpnIpsecPoliciesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-policies/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_sec_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_sec_policy_request));
            } else {
                $httpBody = $ip_sec_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecPoliciesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecPolicy[]
     */
    public function vpnIpsecPoliciesBulkUpdate($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkUpdate'][0])
    {
        list($response) = $this->vpnIpsecPoliciesBulkUpdateWithHttpInfo($ip_sec_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecPoliciesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecPolicy[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecPoliciesBulkUpdateWithHttpInfo($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkUpdate'][0])
    {
        $request = $this->vpnIpsecPoliciesBulkUpdateRequest($ip_sec_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecPolicy[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecPolicy[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecPolicy[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecPolicy[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecPolicy[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecPoliciesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesBulkUpdateAsync($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkUpdate'][0])
    {
        return $this->vpnIpsecPoliciesBulkUpdateAsyncWithHttpInfo($ip_sec_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecPoliciesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesBulkUpdateAsyncWithHttpInfo($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecPolicy[]';
        $request = $this->vpnIpsecPoliciesBulkUpdateRequest($ip_sec_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecPoliciesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\IPSecPolicyRequest[] $ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecPoliciesBulkUpdateRequest($ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesBulkUpdate'][0])
    {

        // verify the required parameter 'ip_sec_policy_request' is set
        if ($ip_sec_policy_request === null || (is_array($ip_sec_policy_request) && count($ip_sec_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_sec_policy_request when calling vpnIpsecPoliciesBulkUpdate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-policies/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_sec_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_sec_policy_request));
            } else {
                $httpBody = $ip_sec_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecPoliciesCreate
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecPolicyRequest $writable_ip_sec_policy_request writable_ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecPolicy
     */
    public function vpnIpsecPoliciesCreate($writable_ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesCreate'][0])
    {
        list($response) = $this->vpnIpsecPoliciesCreateWithHttpInfo($writable_ip_sec_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecPoliciesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecPolicyRequest $writable_ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecPoliciesCreateWithHttpInfo($writable_ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesCreate'][0])
    {
        $request = $this->vpnIpsecPoliciesCreateRequest($writable_ip_sec_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\IPSecPolicy' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecPolicy' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecPolicy', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecPolicy';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecPoliciesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecPolicyRequest $writable_ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesCreateAsync($writable_ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesCreate'][0])
    {
        return $this->vpnIpsecPoliciesCreateAsyncWithHttpInfo($writable_ip_sec_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecPoliciesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecPolicyRequest $writable_ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesCreateAsyncWithHttpInfo($writable_ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecPolicy';
        $request = $this->vpnIpsecPoliciesCreateRequest($writable_ip_sec_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecPoliciesCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecPolicyRequest $writable_ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecPoliciesCreateRequest($writable_ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesCreate'][0])
    {

        // verify the required parameter 'writable_ip_sec_policy_request' is set
        if ($writable_ip_sec_policy_request === null || (is_array($writable_ip_sec_policy_request) && count($writable_ip_sec_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ip_sec_policy_request when calling vpnIpsecPoliciesCreate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-policies/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ip_sec_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ip_sec_policy_request));
            } else {
                $httpBody = $writable_ip_sec_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecPoliciesDestroy
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnIpsecPoliciesDestroy($id, string $contentType = self::contentTypes['vpnIpsecPoliciesDestroy'][0])
    {
        $this->vpnIpsecPoliciesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation vpnIpsecPoliciesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecPoliciesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecPoliciesDestroy'][0])
    {
        $request = $this->vpnIpsecPoliciesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecPoliciesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesDestroyAsync($id, string $contentType = self::contentTypes['vpnIpsecPoliciesDestroy'][0])
    {
        return $this->vpnIpsecPoliciesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecPoliciesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecPoliciesDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnIpsecPoliciesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecPoliciesDestroy'
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecPoliciesDestroyRequest($id, string $contentType = self::contentTypes['vpnIpsecPoliciesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecPoliciesDestroy'
            );
        }


        $resourcePath = '/api/vpn/ipsec-policies/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecPoliciesList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $ipsec_proposal ipsec_proposal (optional)
     * @param  string[] $ipsec_proposal__n ipsec_proposal__n (optional)
     * @param  int[] $ipsec_proposal_id ipsec_proposal_id (optional)
     * @param  int[] $ipsec_proposal_id__n ipsec_proposal_id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $pfs_group Diffie-Hellman group for Perfect Forward Secrecy (optional)
     * @param  int[] $pfs_group__n Diffie-Hellman group for Perfect Forward Secrecy (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedIPSecPolicyList
     */
    public function vpnIpsecPoliciesList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_proposal = null, $ipsec_proposal__n = null, $ipsec_proposal_id = null, $ipsec_proposal_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $pfs_group = null, $pfs_group__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecPoliciesList'][0])
    {
        list($response) = $this->vpnIpsecPoliciesListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_proposal, $ipsec_proposal__n, $ipsec_proposal_id, $ipsec_proposal_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $pfs_group, $pfs_group__n, $q, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecPoliciesListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_proposal (optional)
     * @param  string[] $ipsec_proposal__n (optional)
     * @param  int[] $ipsec_proposal_id (optional)
     * @param  int[] $ipsec_proposal_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $pfs_group Diffie-Hellman group for Perfect Forward Secrecy (optional)
     * @param  int[] $pfs_group__n Diffie-Hellman group for Perfect Forward Secrecy (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedIPSecPolicyList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecPoliciesListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_proposal = null, $ipsec_proposal__n = null, $ipsec_proposal_id = null, $ipsec_proposal_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $pfs_group = null, $pfs_group__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecPoliciesList'][0])
    {
        $request = $this->vpnIpsecPoliciesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_proposal, $ipsec_proposal__n, $ipsec_proposal_id, $ipsec_proposal_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $pfs_group, $pfs_group__n, $q, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedIPSecPolicyList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedIPSecPolicyList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedIPSecPolicyList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedIPSecPolicyList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedIPSecPolicyList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecPoliciesListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_proposal (optional)
     * @param  string[] $ipsec_proposal__n (optional)
     * @param  int[] $ipsec_proposal_id (optional)
     * @param  int[] $ipsec_proposal_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $pfs_group Diffie-Hellman group for Perfect Forward Secrecy (optional)
     * @param  int[] $pfs_group__n Diffie-Hellman group for Perfect Forward Secrecy (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_proposal = null, $ipsec_proposal__n = null, $ipsec_proposal_id = null, $ipsec_proposal_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $pfs_group = null, $pfs_group__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecPoliciesList'][0])
    {
        return $this->vpnIpsecPoliciesListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_proposal, $ipsec_proposal__n, $ipsec_proposal_id, $ipsec_proposal_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $pfs_group, $pfs_group__n, $q, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecPoliciesListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_proposal (optional)
     * @param  string[] $ipsec_proposal__n (optional)
     * @param  int[] $ipsec_proposal_id (optional)
     * @param  int[] $ipsec_proposal_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $pfs_group Diffie-Hellman group for Perfect Forward Secrecy (optional)
     * @param  int[] $pfs_group__n Diffie-Hellman group for Perfect Forward Secrecy (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_proposal = null, $ipsec_proposal__n = null, $ipsec_proposal_id = null, $ipsec_proposal_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $pfs_group = null, $pfs_group__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecPoliciesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedIPSecPolicyList';
        $request = $this->vpnIpsecPoliciesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_proposal, $ipsec_proposal__n, $ipsec_proposal_id, $ipsec_proposal_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $pfs_group, $pfs_group__n, $q, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecPoliciesList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_proposal (optional)
     * @param  string[] $ipsec_proposal__n (optional)
     * @param  int[] $ipsec_proposal_id (optional)
     * @param  int[] $ipsec_proposal_id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $pfs_group Diffie-Hellman group for Perfect Forward Secrecy (optional)
     * @param  int[] $pfs_group__n Diffie-Hellman group for Perfect Forward Secrecy (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecPoliciesListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_proposal = null, $ipsec_proposal__n = null, $ipsec_proposal_id = null, $ipsec_proposal_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $pfs_group = null, $pfs_group__n = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecPoliciesList'][0])
    {




























































        $resourcePath = '/api/vpn/ipsec-policies/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_proposal,
            'ipsec_proposal', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_proposal__n,
            'ipsec_proposal__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_proposal_id,
            'ipsec_proposal_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_proposal_id__n,
            'ipsec_proposal_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pfs_group,
            'pfs_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pfs_group__n,
            'pfs_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecPoliciesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecPolicyRequest $patched_writable_ip_sec_policy_request patched_writable_ip_sec_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecPolicy
     */
    public function vpnIpsecPoliciesPartialUpdate($id, $patched_writable_ip_sec_policy_request = null, string $contentType = self::contentTypes['vpnIpsecPoliciesPartialUpdate'][0])
    {
        list($response) = $this->vpnIpsecPoliciesPartialUpdateWithHttpInfo($id, $patched_writable_ip_sec_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecPoliciesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecPolicyRequest $patched_writable_ip_sec_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecPoliciesPartialUpdateWithHttpInfo($id, $patched_writable_ip_sec_policy_request = null, string $contentType = self::contentTypes['vpnIpsecPoliciesPartialUpdate'][0])
    {
        $request = $this->vpnIpsecPoliciesPartialUpdateRequest($id, $patched_writable_ip_sec_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecPolicy' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecPolicy' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecPolicy', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecPolicy';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecPoliciesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecPolicyRequest $patched_writable_ip_sec_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesPartialUpdateAsync($id, $patched_writable_ip_sec_policy_request = null, string $contentType = self::contentTypes['vpnIpsecPoliciesPartialUpdate'][0])
    {
        return $this->vpnIpsecPoliciesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ip_sec_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecPoliciesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecPolicyRequest $patched_writable_ip_sec_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ip_sec_policy_request = null, string $contentType = self::contentTypes['vpnIpsecPoliciesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecPolicy';
        $request = $this->vpnIpsecPoliciesPartialUpdateRequest($id, $patched_writable_ip_sec_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecPoliciesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecPolicyRequest $patched_writable_ip_sec_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecPoliciesPartialUpdateRequest($id, $patched_writable_ip_sec_policy_request = null, string $contentType = self::contentTypes['vpnIpsecPoliciesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecPoliciesPartialUpdate'
            );
        }



        $resourcePath = '/api/vpn/ipsec-policies/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_ip_sec_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_ip_sec_policy_request));
            } else {
                $httpBody = $patched_writable_ip_sec_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecPoliciesRetrieve
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecPolicy
     */
    public function vpnIpsecPoliciesRetrieve($id, string $contentType = self::contentTypes['vpnIpsecPoliciesRetrieve'][0])
    {
        list($response) = $this->vpnIpsecPoliciesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecPoliciesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecPoliciesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecPoliciesRetrieve'][0])
    {
        $request = $this->vpnIpsecPoliciesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecPolicy' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecPolicy' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecPolicy', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecPolicy';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecPoliciesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesRetrieveAsync($id, string $contentType = self::contentTypes['vpnIpsecPoliciesRetrieve'][0])
    {
        return $this->vpnIpsecPoliciesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecPoliciesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecPoliciesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecPolicy';
        $request = $this->vpnIpsecPoliciesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecPoliciesRetrieve'
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecPoliciesRetrieveRequest($id, string $contentType = self::contentTypes['vpnIpsecPoliciesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecPoliciesRetrieve'
            );
        }


        $resourcePath = '/api/vpn/ipsec-policies/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecPoliciesUpdate
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecPolicyRequest $writable_ip_sec_policy_request writable_ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecPolicy
     */
    public function vpnIpsecPoliciesUpdate($id, $writable_ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesUpdate'][0])
    {
        list($response) = $this->vpnIpsecPoliciesUpdateWithHttpInfo($id, $writable_ip_sec_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecPoliciesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecPolicyRequest $writable_ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecPoliciesUpdateWithHttpInfo($id, $writable_ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesUpdate'][0])
    {
        $request = $this->vpnIpsecPoliciesUpdateRequest($id, $writable_ip_sec_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecPolicy' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecPolicy' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecPolicy', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecPolicy';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecPoliciesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecPolicyRequest $writable_ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesUpdateAsync($id, $writable_ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesUpdate'][0])
    {
        return $this->vpnIpsecPoliciesUpdateAsyncWithHttpInfo($id, $writable_ip_sec_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecPoliciesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecPolicyRequest $writable_ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecPoliciesUpdateAsyncWithHttpInfo($id, $writable_ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecPolicy';
        $request = $this->vpnIpsecPoliciesUpdateRequest($id, $writable_ip_sec_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecPoliciesUpdate'
     *
     * @param  int $id A unique integer value identifying this IPSec policy. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecPolicyRequest $writable_ip_sec_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecPoliciesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecPoliciesUpdateRequest($id, $writable_ip_sec_policy_request, string $contentType = self::contentTypes['vpnIpsecPoliciesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecPoliciesUpdate'
            );
        }

        // verify the required parameter 'writable_ip_sec_policy_request' is set
        if ($writable_ip_sec_policy_request === null || (is_array($writable_ip_sec_policy_request) && count($writable_ip_sec_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ip_sec_policy_request when calling vpnIpsecPoliciesUpdate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-policies/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ip_sec_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ip_sec_policy_request));
            } else {
                $httpBody = $writable_ip_sec_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProfilesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnIpsecProfilesBulkDestroy($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkDestroy'][0])
    {
        $this->vpnIpsecProfilesBulkDestroyWithHttpInfo($ip_sec_profile_request, $contentType);
    }

    /**
     * Operation vpnIpsecProfilesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProfilesBulkDestroyWithHttpInfo($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkDestroy'][0])
    {
        $request = $this->vpnIpsecProfilesBulkDestroyRequest($ip_sec_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProfilesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesBulkDestroyAsync($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkDestroy'][0])
    {
        return $this->vpnIpsecProfilesBulkDestroyAsyncWithHttpInfo($ip_sec_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProfilesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesBulkDestroyAsyncWithHttpInfo($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnIpsecProfilesBulkDestroyRequest($ip_sec_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProfilesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProfilesBulkDestroyRequest($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkDestroy'][0])
    {

        // verify the required parameter 'ip_sec_profile_request' is set
        if ($ip_sec_profile_request === null || (is_array($ip_sec_profile_request) && count($ip_sec_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_sec_profile_request when calling vpnIpsecProfilesBulkDestroy'
            );
        }


        $resourcePath = '/api/vpn/ipsec-profiles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_sec_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_sec_profile_request));
            } else {
                $httpBody = $ip_sec_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProfilesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProfile[]
     */
    public function vpnIpsecProfilesBulkPartialUpdate($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkPartialUpdate'][0])
    {
        list($response) = $this->vpnIpsecProfilesBulkPartialUpdateWithHttpInfo($ip_sec_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProfilesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProfile[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProfilesBulkPartialUpdateWithHttpInfo($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkPartialUpdate'][0])
    {
        $request = $this->vpnIpsecProfilesBulkPartialUpdateRequest($ip_sec_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecProfile[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProfile[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProfile[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProfile[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProfile[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProfilesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesBulkPartialUpdateAsync($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkPartialUpdate'][0])
    {
        return $this->vpnIpsecProfilesBulkPartialUpdateAsyncWithHttpInfo($ip_sec_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProfilesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesBulkPartialUpdateAsyncWithHttpInfo($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProfile[]';
        $request = $this->vpnIpsecProfilesBulkPartialUpdateRequest($ip_sec_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProfilesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProfilesBulkPartialUpdateRequest($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'ip_sec_profile_request' is set
        if ($ip_sec_profile_request === null || (is_array($ip_sec_profile_request) && count($ip_sec_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_sec_profile_request when calling vpnIpsecProfilesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-profiles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_sec_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_sec_profile_request));
            } else {
                $httpBody = $ip_sec_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProfilesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProfile[]
     */
    public function vpnIpsecProfilesBulkUpdate($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkUpdate'][0])
    {
        list($response) = $this->vpnIpsecProfilesBulkUpdateWithHttpInfo($ip_sec_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProfilesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProfile[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProfilesBulkUpdateWithHttpInfo($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkUpdate'][0])
    {
        $request = $this->vpnIpsecProfilesBulkUpdateRequest($ip_sec_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecProfile[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProfile[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProfile[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProfile[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProfile[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProfilesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesBulkUpdateAsync($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkUpdate'][0])
    {
        return $this->vpnIpsecProfilesBulkUpdateAsyncWithHttpInfo($ip_sec_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProfilesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesBulkUpdateAsyncWithHttpInfo($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProfile[]';
        $request = $this->vpnIpsecProfilesBulkUpdateRequest($ip_sec_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProfilesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\IPSecProfileRequest[] $ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProfilesBulkUpdateRequest($ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesBulkUpdate'][0])
    {

        // verify the required parameter 'ip_sec_profile_request' is set
        if ($ip_sec_profile_request === null || (is_array($ip_sec_profile_request) && count($ip_sec_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_sec_profile_request when calling vpnIpsecProfilesBulkUpdate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-profiles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_sec_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_sec_profile_request));
            } else {
                $httpBody = $ip_sec_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProfilesCreate
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecProfileRequest $writable_ip_sec_profile_request writable_ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProfile
     */
    public function vpnIpsecProfilesCreate($writable_ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesCreate'][0])
    {
        list($response) = $this->vpnIpsecProfilesCreateWithHttpInfo($writable_ip_sec_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProfilesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecProfileRequest $writable_ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProfilesCreateWithHttpInfo($writable_ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesCreate'][0])
    {
        $request = $this->vpnIpsecProfilesCreateRequest($writable_ip_sec_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\IPSecProfile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProfile' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProfile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProfilesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecProfileRequest $writable_ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesCreateAsync($writable_ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesCreate'][0])
    {
        return $this->vpnIpsecProfilesCreateAsyncWithHttpInfo($writable_ip_sec_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProfilesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecProfileRequest $writable_ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesCreateAsyncWithHttpInfo($writable_ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProfile';
        $request = $this->vpnIpsecProfilesCreateRequest($writable_ip_sec_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProfilesCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecProfileRequest $writable_ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProfilesCreateRequest($writable_ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesCreate'][0])
    {

        // verify the required parameter 'writable_ip_sec_profile_request' is set
        if ($writable_ip_sec_profile_request === null || (is_array($writable_ip_sec_profile_request) && count($writable_ip_sec_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ip_sec_profile_request when calling vpnIpsecProfilesCreate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-profiles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ip_sec_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ip_sec_profile_request));
            } else {
                $httpBody = $writable_ip_sec_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProfilesDestroy
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnIpsecProfilesDestroy($id, string $contentType = self::contentTypes['vpnIpsecProfilesDestroy'][0])
    {
        $this->vpnIpsecProfilesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation vpnIpsecProfilesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProfilesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecProfilesDestroy'][0])
    {
        $request = $this->vpnIpsecProfilesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProfilesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesDestroyAsync($id, string $contentType = self::contentTypes['vpnIpsecProfilesDestroy'][0])
    {
        return $this->vpnIpsecProfilesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProfilesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecProfilesDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnIpsecProfilesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProfilesDestroy'
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProfilesDestroyRequest($id, string $contentType = self::contentTypes['vpnIpsecProfilesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecProfilesDestroy'
            );
        }


        $resourcePath = '/api/vpn/ipsec-profiles/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProfilesList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $ike_policy IKE policy (name) (optional)
     * @param  string[] $ike_policy__n IKE policy (name) (optional)
     * @param  int[] $ike_policy_id IKE policy (ID) (optional)
     * @param  int[] $ike_policy_id__n IKE policy (ID) (optional)
     * @param  string[] $ipsec_policy IPSec policy (name) (optional)
     * @param  string[] $ipsec_policy__n IPSec policy (name) (optional)
     * @param  int[] $ipsec_policy_id IPSec policy (ID) (optional)
     * @param  int[] $ipsec_policy_id__n IPSec policy (ID) (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mode mode (optional)
     * @param  string[] $mode__n mode__n (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedIPSecProfileList
     */
    public function vpnIpsecProfilesList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_policy = null, $ike_policy__n = null, $ike_policy_id = null, $ike_policy_id__n = null, $ipsec_policy = null, $ipsec_policy__n = null, $ipsec_policy_id = null, $ipsec_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mode = null, $mode__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecProfilesList'][0])
    {
        list($response) = $this->vpnIpsecProfilesListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_policy, $ike_policy__n, $ike_policy_id, $ike_policy_id__n, $ipsec_policy, $ipsec_policy__n, $ipsec_policy_id, $ipsec_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mode, $mode__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProfilesListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_policy IKE policy (name) (optional)
     * @param  string[] $ike_policy__n IKE policy (name) (optional)
     * @param  int[] $ike_policy_id IKE policy (ID) (optional)
     * @param  int[] $ike_policy_id__n IKE policy (ID) (optional)
     * @param  string[] $ipsec_policy IPSec policy (name) (optional)
     * @param  string[] $ipsec_policy__n IPSec policy (name) (optional)
     * @param  int[] $ipsec_policy_id IPSec policy (ID) (optional)
     * @param  int[] $ipsec_policy_id__n IPSec policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mode (optional)
     * @param  string[] $mode__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedIPSecProfileList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProfilesListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_policy = null, $ike_policy__n = null, $ike_policy_id = null, $ike_policy_id__n = null, $ipsec_policy = null, $ipsec_policy__n = null, $ipsec_policy_id = null, $ipsec_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mode = null, $mode__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecProfilesList'][0])
    {
        $request = $this->vpnIpsecProfilesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_policy, $ike_policy__n, $ike_policy_id, $ike_policy_id__n, $ipsec_policy, $ipsec_policy__n, $ipsec_policy_id, $ipsec_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mode, $mode__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedIPSecProfileList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedIPSecProfileList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedIPSecProfileList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedIPSecProfileList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedIPSecProfileList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProfilesListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_policy IKE policy (name) (optional)
     * @param  string[] $ike_policy__n IKE policy (name) (optional)
     * @param  int[] $ike_policy_id IKE policy (ID) (optional)
     * @param  int[] $ike_policy_id__n IKE policy (ID) (optional)
     * @param  string[] $ipsec_policy IPSec policy (name) (optional)
     * @param  string[] $ipsec_policy__n IPSec policy (name) (optional)
     * @param  int[] $ipsec_policy_id IPSec policy (ID) (optional)
     * @param  int[] $ipsec_policy_id__n IPSec policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mode (optional)
     * @param  string[] $mode__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_policy = null, $ike_policy__n = null, $ike_policy_id = null, $ike_policy_id__n = null, $ipsec_policy = null, $ipsec_policy__n = null, $ipsec_policy_id = null, $ipsec_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mode = null, $mode__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecProfilesList'][0])
    {
        return $this->vpnIpsecProfilesListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_policy, $ike_policy__n, $ike_policy_id, $ike_policy_id__n, $ipsec_policy, $ipsec_policy__n, $ipsec_policy_id, $ipsec_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mode, $mode__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProfilesListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_policy IKE policy (name) (optional)
     * @param  string[] $ike_policy__n IKE policy (name) (optional)
     * @param  int[] $ike_policy_id IKE policy (ID) (optional)
     * @param  int[] $ike_policy_id__n IKE policy (ID) (optional)
     * @param  string[] $ipsec_policy IPSec policy (name) (optional)
     * @param  string[] $ipsec_policy__n IPSec policy (name) (optional)
     * @param  int[] $ipsec_policy_id IPSec policy (ID) (optional)
     * @param  int[] $ipsec_policy_id__n IPSec policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mode (optional)
     * @param  string[] $mode__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_policy = null, $ike_policy__n = null, $ike_policy_id = null, $ike_policy_id__n = null, $ipsec_policy = null, $ipsec_policy__n = null, $ipsec_policy_id = null, $ipsec_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mode = null, $mode__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecProfilesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedIPSecProfileList';
        $request = $this->vpnIpsecProfilesListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ike_policy, $ike_policy__n, $ike_policy_id, $ike_policy_id__n, $ipsec_policy, $ipsec_policy__n, $ipsec_policy_id, $ipsec_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mode, $mode__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProfilesList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ike_policy IKE policy (name) (optional)
     * @param  string[] $ike_policy__n IKE policy (name) (optional)
     * @param  int[] $ike_policy_id IKE policy (ID) (optional)
     * @param  int[] $ike_policy_id__n IKE policy (ID) (optional)
     * @param  string[] $ipsec_policy IPSec policy (name) (optional)
     * @param  string[] $ipsec_policy__n IPSec policy (name) (optional)
     * @param  int[] $ipsec_policy_id IPSec policy (ID) (optional)
     * @param  int[] $ipsec_policy_id__n IPSec policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mode (optional)
     * @param  string[] $mode__n (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProfilesListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ike_policy = null, $ike_policy__n = null, $ike_policy_id = null, $ike_policy_id__n = null, $ipsec_policy = null, $ipsec_policy__n = null, $ipsec_policy_id = null, $ipsec_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mode = null, $mode__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecProfilesList'][0])
    {
































































        $resourcePath = '/api/vpn/ipsec-profiles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_policy,
            'ike_policy', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_policy__n,
            'ike_policy__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_policy_id,
            'ike_policy_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ike_policy_id__n,
            'ike_policy_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_policy,
            'ipsec_policy', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_policy__n,
            'ipsec_policy__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_policy_id,
            'ipsec_policy_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_policy_id__n,
            'ipsec_policy_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mode,
            'mode', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mode__n,
            'mode__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProfilesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecProfileRequest $patched_writable_ip_sec_profile_request patched_writable_ip_sec_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProfile
     */
    public function vpnIpsecProfilesPartialUpdate($id, $patched_writable_ip_sec_profile_request = null, string $contentType = self::contentTypes['vpnIpsecProfilesPartialUpdate'][0])
    {
        list($response) = $this->vpnIpsecProfilesPartialUpdateWithHttpInfo($id, $patched_writable_ip_sec_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProfilesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecProfileRequest $patched_writable_ip_sec_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProfilesPartialUpdateWithHttpInfo($id, $patched_writable_ip_sec_profile_request = null, string $contentType = self::contentTypes['vpnIpsecProfilesPartialUpdate'][0])
    {
        $request = $this->vpnIpsecProfilesPartialUpdateRequest($id, $patched_writable_ip_sec_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecProfile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProfile' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProfile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProfilesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecProfileRequest $patched_writable_ip_sec_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesPartialUpdateAsync($id, $patched_writable_ip_sec_profile_request = null, string $contentType = self::contentTypes['vpnIpsecProfilesPartialUpdate'][0])
    {
        return $this->vpnIpsecProfilesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ip_sec_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProfilesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecProfileRequest $patched_writable_ip_sec_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ip_sec_profile_request = null, string $contentType = self::contentTypes['vpnIpsecProfilesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProfile';
        $request = $this->vpnIpsecProfilesPartialUpdateRequest($id, $patched_writable_ip_sec_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProfilesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecProfileRequest $patched_writable_ip_sec_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProfilesPartialUpdateRequest($id, $patched_writable_ip_sec_profile_request = null, string $contentType = self::contentTypes['vpnIpsecProfilesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecProfilesPartialUpdate'
            );
        }



        $resourcePath = '/api/vpn/ipsec-profiles/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_ip_sec_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_ip_sec_profile_request));
            } else {
                $httpBody = $patched_writable_ip_sec_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProfilesRetrieve
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProfile
     */
    public function vpnIpsecProfilesRetrieve($id, string $contentType = self::contentTypes['vpnIpsecProfilesRetrieve'][0])
    {
        list($response) = $this->vpnIpsecProfilesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProfilesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProfilesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecProfilesRetrieve'][0])
    {
        $request = $this->vpnIpsecProfilesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecProfile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProfile' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProfile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProfilesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesRetrieveAsync($id, string $contentType = self::contentTypes['vpnIpsecProfilesRetrieve'][0])
    {
        return $this->vpnIpsecProfilesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProfilesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecProfilesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProfile';
        $request = $this->vpnIpsecProfilesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProfilesRetrieve'
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProfilesRetrieveRequest($id, string $contentType = self::contentTypes['vpnIpsecProfilesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecProfilesRetrieve'
            );
        }


        $resourcePath = '/api/vpn/ipsec-profiles/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProfilesUpdate
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecProfileRequest $writable_ip_sec_profile_request writable_ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProfile
     */
    public function vpnIpsecProfilesUpdate($id, $writable_ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesUpdate'][0])
    {
        list($response) = $this->vpnIpsecProfilesUpdateWithHttpInfo($id, $writable_ip_sec_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProfilesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecProfileRequest $writable_ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProfilesUpdateWithHttpInfo($id, $writable_ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesUpdate'][0])
    {
        $request = $this->vpnIpsecProfilesUpdateRequest($id, $writable_ip_sec_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecProfile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProfile' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProfile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProfilesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecProfileRequest $writable_ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesUpdateAsync($id, $writable_ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesUpdate'][0])
    {
        return $this->vpnIpsecProfilesUpdateAsyncWithHttpInfo($id, $writable_ip_sec_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProfilesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecProfileRequest $writable_ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProfilesUpdateAsyncWithHttpInfo($id, $writable_ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProfile';
        $request = $this->vpnIpsecProfilesUpdateRequest($id, $writable_ip_sec_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProfilesUpdate'
     *
     * @param  int $id A unique integer value identifying this IPSec profile. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecProfileRequest $writable_ip_sec_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProfilesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProfilesUpdateRequest($id, $writable_ip_sec_profile_request, string $contentType = self::contentTypes['vpnIpsecProfilesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecProfilesUpdate'
            );
        }

        // verify the required parameter 'writable_ip_sec_profile_request' is set
        if ($writable_ip_sec_profile_request === null || (is_array($writable_ip_sec_profile_request) && count($writable_ip_sec_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ip_sec_profile_request when calling vpnIpsecProfilesUpdate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-profiles/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ip_sec_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ip_sec_profile_request));
            } else {
                $httpBody = $writable_ip_sec_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProposalsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnIpsecProposalsBulkDestroy($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkDestroy'][0])
    {
        $this->vpnIpsecProposalsBulkDestroyWithHttpInfo($ip_sec_proposal_request, $contentType);
    }

    /**
     * Operation vpnIpsecProposalsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProposalsBulkDestroyWithHttpInfo($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkDestroy'][0])
    {
        $request = $this->vpnIpsecProposalsBulkDestroyRequest($ip_sec_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProposalsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsBulkDestroyAsync($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkDestroy'][0])
    {
        return $this->vpnIpsecProposalsBulkDestroyAsyncWithHttpInfo($ip_sec_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProposalsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsBulkDestroyAsyncWithHttpInfo($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnIpsecProposalsBulkDestroyRequest($ip_sec_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProposalsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProposalsBulkDestroyRequest($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkDestroy'][0])
    {

        // verify the required parameter 'ip_sec_proposal_request' is set
        if ($ip_sec_proposal_request === null || (is_array($ip_sec_proposal_request) && count($ip_sec_proposal_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_sec_proposal_request when calling vpnIpsecProposalsBulkDestroy'
            );
        }


        $resourcePath = '/api/vpn/ipsec-proposals/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_sec_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_sec_proposal_request));
            } else {
                $httpBody = $ip_sec_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProposalsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProposal[]
     */
    public function vpnIpsecProposalsBulkPartialUpdate($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkPartialUpdate'][0])
    {
        list($response) = $this->vpnIpsecProposalsBulkPartialUpdateWithHttpInfo($ip_sec_proposal_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProposalsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProposal[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProposalsBulkPartialUpdateWithHttpInfo($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkPartialUpdate'][0])
    {
        $request = $this->vpnIpsecProposalsBulkPartialUpdateRequest($ip_sec_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecProposal[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProposal[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProposal[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProposal[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProposal[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProposalsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsBulkPartialUpdateAsync($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkPartialUpdate'][0])
    {
        return $this->vpnIpsecProposalsBulkPartialUpdateAsyncWithHttpInfo($ip_sec_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProposalsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsBulkPartialUpdateAsyncWithHttpInfo($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProposal[]';
        $request = $this->vpnIpsecProposalsBulkPartialUpdateRequest($ip_sec_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProposalsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProposalsBulkPartialUpdateRequest($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'ip_sec_proposal_request' is set
        if ($ip_sec_proposal_request === null || (is_array($ip_sec_proposal_request) && count($ip_sec_proposal_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_sec_proposal_request when calling vpnIpsecProposalsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-proposals/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_sec_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_sec_proposal_request));
            } else {
                $httpBody = $ip_sec_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProposalsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProposal[]
     */
    public function vpnIpsecProposalsBulkUpdate($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkUpdate'][0])
    {
        list($response) = $this->vpnIpsecProposalsBulkUpdateWithHttpInfo($ip_sec_proposal_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProposalsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProposal[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProposalsBulkUpdateWithHttpInfo($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkUpdate'][0])
    {
        $request = $this->vpnIpsecProposalsBulkUpdateRequest($ip_sec_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecProposal[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProposal[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProposal[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProposal[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProposal[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProposalsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsBulkUpdateAsync($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkUpdate'][0])
    {
        return $this->vpnIpsecProposalsBulkUpdateAsyncWithHttpInfo($ip_sec_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProposalsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsBulkUpdateAsyncWithHttpInfo($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProposal[]';
        $request = $this->vpnIpsecProposalsBulkUpdateRequest($ip_sec_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProposalsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\IPSecProposalRequest[] $ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProposalsBulkUpdateRequest($ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsBulkUpdate'][0])
    {

        // verify the required parameter 'ip_sec_proposal_request' is set
        if ($ip_sec_proposal_request === null || (is_array($ip_sec_proposal_request) && count($ip_sec_proposal_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_sec_proposal_request when calling vpnIpsecProposalsBulkUpdate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-proposals/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ip_sec_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ip_sec_proposal_request));
            } else {
                $httpBody = $ip_sec_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProposalsCreate
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecProposalRequest $writable_ip_sec_proposal_request writable_ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProposal
     */
    public function vpnIpsecProposalsCreate($writable_ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsCreate'][0])
    {
        list($response) = $this->vpnIpsecProposalsCreateWithHttpInfo($writable_ip_sec_proposal_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProposalsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecProposalRequest $writable_ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProposal, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProposalsCreateWithHttpInfo($writable_ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsCreate'][0])
    {
        $request = $this->vpnIpsecProposalsCreateRequest($writable_ip_sec_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\IPSecProposal' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProposal' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProposal', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProposal';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProposal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProposalsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecProposalRequest $writable_ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsCreateAsync($writable_ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsCreate'][0])
    {
        return $this->vpnIpsecProposalsCreateAsyncWithHttpInfo($writable_ip_sec_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProposalsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecProposalRequest $writable_ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsCreateAsyncWithHttpInfo($writable_ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProposal';
        $request = $this->vpnIpsecProposalsCreateRequest($writable_ip_sec_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProposalsCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableIPSecProposalRequest $writable_ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProposalsCreateRequest($writable_ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsCreate'][0])
    {

        // verify the required parameter 'writable_ip_sec_proposal_request' is set
        if ($writable_ip_sec_proposal_request === null || (is_array($writable_ip_sec_proposal_request) && count($writable_ip_sec_proposal_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ip_sec_proposal_request when calling vpnIpsecProposalsCreate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-proposals/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ip_sec_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ip_sec_proposal_request));
            } else {
                $httpBody = $writable_ip_sec_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProposalsDestroy
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnIpsecProposalsDestroy($id, string $contentType = self::contentTypes['vpnIpsecProposalsDestroy'][0])
    {
        $this->vpnIpsecProposalsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation vpnIpsecProposalsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProposalsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecProposalsDestroy'][0])
    {
        $request = $this->vpnIpsecProposalsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProposalsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsDestroyAsync($id, string $contentType = self::contentTypes['vpnIpsecProposalsDestroy'][0])
    {
        return $this->vpnIpsecProposalsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProposalsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecProposalsDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnIpsecProposalsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProposalsDestroy'
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProposalsDestroyRequest($id, string $contentType = self::contentTypes['vpnIpsecProposalsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecProposalsDestroy'
            );
        }


        $resourcePath = '/api/vpn/ipsec-proposals/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProposalsList
     *
     * @param  string[] $authentication_algorithm authentication_algorithm (optional)
     * @param  string[] $authentication_algorithm__n authentication_algorithm__n (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $encryption_algorithm encryption_algorithm (optional)
     * @param  string[] $encryption_algorithm__n encryption_algorithm__n (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $ipsec_policy IPSec policy (name) (optional)
     * @param  string[] $ipsec_policy__n IPSec policy (name) (optional)
     * @param  int[] $ipsec_policy_id IPSec policy (ID) (optional)
     * @param  int[] $ipsec_policy_id__n IPSec policy (ID) (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $sa_lifetime_data sa_lifetime_data (optional)
     * @param  bool $sa_lifetime_data__empty sa_lifetime_data__empty (optional)
     * @param  int[] $sa_lifetime_data__gt sa_lifetime_data__gt (optional)
     * @param  int[] $sa_lifetime_data__gte sa_lifetime_data__gte (optional)
     * @param  int[] $sa_lifetime_data__lt sa_lifetime_data__lt (optional)
     * @param  int[] $sa_lifetime_data__lte sa_lifetime_data__lte (optional)
     * @param  int[] $sa_lifetime_data__n sa_lifetime_data__n (optional)
     * @param  int[] $sa_lifetime_seconds sa_lifetime_seconds (optional)
     * @param  bool $sa_lifetime_seconds__empty sa_lifetime_seconds__empty (optional)
     * @param  int[] $sa_lifetime_seconds__gt sa_lifetime_seconds__gt (optional)
     * @param  int[] $sa_lifetime_seconds__gte sa_lifetime_seconds__gte (optional)
     * @param  int[] $sa_lifetime_seconds__lt sa_lifetime_seconds__lt (optional)
     * @param  int[] $sa_lifetime_seconds__lte sa_lifetime_seconds__lte (optional)
     * @param  int[] $sa_lifetime_seconds__n sa_lifetime_seconds__n (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedIPSecProposalList
     */
    public function vpnIpsecProposalsList($authentication_algorithm = null, $authentication_algorithm__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encryption_algorithm = null, $encryption_algorithm__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_policy = null, $ipsec_policy__n = null, $ipsec_policy_id = null, $ipsec_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $sa_lifetime_data = null, $sa_lifetime_data__empty = null, $sa_lifetime_data__gt = null, $sa_lifetime_data__gte = null, $sa_lifetime_data__lt = null, $sa_lifetime_data__lte = null, $sa_lifetime_data__n = null, $sa_lifetime_seconds = null, $sa_lifetime_seconds__empty = null, $sa_lifetime_seconds__gt = null, $sa_lifetime_seconds__gte = null, $sa_lifetime_seconds__lt = null, $sa_lifetime_seconds__lte = null, $sa_lifetime_seconds__n = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecProposalsList'][0])
    {
        list($response) = $this->vpnIpsecProposalsListWithHttpInfo($authentication_algorithm, $authentication_algorithm__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encryption_algorithm, $encryption_algorithm__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_policy, $ipsec_policy__n, $ipsec_policy_id, $ipsec_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $sa_lifetime_data, $sa_lifetime_data__empty, $sa_lifetime_data__gt, $sa_lifetime_data__gte, $sa_lifetime_data__lt, $sa_lifetime_data__lte, $sa_lifetime_data__n, $sa_lifetime_seconds, $sa_lifetime_seconds__empty, $sa_lifetime_seconds__gt, $sa_lifetime_seconds__gte, $sa_lifetime_seconds__lt, $sa_lifetime_seconds__lte, $sa_lifetime_seconds__n, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProposalsListWithHttpInfo
     *
     * @param  string[] $authentication_algorithm (optional)
     * @param  string[] $authentication_algorithm__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encryption_algorithm (optional)
     * @param  string[] $encryption_algorithm__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_policy IPSec policy (name) (optional)
     * @param  string[] $ipsec_policy__n IPSec policy (name) (optional)
     * @param  int[] $ipsec_policy_id IPSec policy (ID) (optional)
     * @param  int[] $ipsec_policy_id__n IPSec policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $sa_lifetime_data (optional)
     * @param  bool $sa_lifetime_data__empty (optional)
     * @param  int[] $sa_lifetime_data__gt (optional)
     * @param  int[] $sa_lifetime_data__gte (optional)
     * @param  int[] $sa_lifetime_data__lt (optional)
     * @param  int[] $sa_lifetime_data__lte (optional)
     * @param  int[] $sa_lifetime_data__n (optional)
     * @param  int[] $sa_lifetime_seconds (optional)
     * @param  bool $sa_lifetime_seconds__empty (optional)
     * @param  int[] $sa_lifetime_seconds__gt (optional)
     * @param  int[] $sa_lifetime_seconds__gte (optional)
     * @param  int[] $sa_lifetime_seconds__lt (optional)
     * @param  int[] $sa_lifetime_seconds__lte (optional)
     * @param  int[] $sa_lifetime_seconds__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedIPSecProposalList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProposalsListWithHttpInfo($authentication_algorithm = null, $authentication_algorithm__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encryption_algorithm = null, $encryption_algorithm__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_policy = null, $ipsec_policy__n = null, $ipsec_policy_id = null, $ipsec_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $sa_lifetime_data = null, $sa_lifetime_data__empty = null, $sa_lifetime_data__gt = null, $sa_lifetime_data__gte = null, $sa_lifetime_data__lt = null, $sa_lifetime_data__lte = null, $sa_lifetime_data__n = null, $sa_lifetime_seconds = null, $sa_lifetime_seconds__empty = null, $sa_lifetime_seconds__gt = null, $sa_lifetime_seconds__gte = null, $sa_lifetime_seconds__lt = null, $sa_lifetime_seconds__lte = null, $sa_lifetime_seconds__n = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecProposalsList'][0])
    {
        $request = $this->vpnIpsecProposalsListRequest($authentication_algorithm, $authentication_algorithm__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encryption_algorithm, $encryption_algorithm__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_policy, $ipsec_policy__n, $ipsec_policy_id, $ipsec_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $sa_lifetime_data, $sa_lifetime_data__empty, $sa_lifetime_data__gt, $sa_lifetime_data__gte, $sa_lifetime_data__lt, $sa_lifetime_data__lte, $sa_lifetime_data__n, $sa_lifetime_seconds, $sa_lifetime_seconds__empty, $sa_lifetime_seconds__gt, $sa_lifetime_seconds__gte, $sa_lifetime_seconds__lt, $sa_lifetime_seconds__lte, $sa_lifetime_seconds__n, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedIPSecProposalList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedIPSecProposalList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedIPSecProposalList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedIPSecProposalList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedIPSecProposalList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProposalsListAsync
     *
     * @param  string[] $authentication_algorithm (optional)
     * @param  string[] $authentication_algorithm__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encryption_algorithm (optional)
     * @param  string[] $encryption_algorithm__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_policy IPSec policy (name) (optional)
     * @param  string[] $ipsec_policy__n IPSec policy (name) (optional)
     * @param  int[] $ipsec_policy_id IPSec policy (ID) (optional)
     * @param  int[] $ipsec_policy_id__n IPSec policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $sa_lifetime_data (optional)
     * @param  bool $sa_lifetime_data__empty (optional)
     * @param  int[] $sa_lifetime_data__gt (optional)
     * @param  int[] $sa_lifetime_data__gte (optional)
     * @param  int[] $sa_lifetime_data__lt (optional)
     * @param  int[] $sa_lifetime_data__lte (optional)
     * @param  int[] $sa_lifetime_data__n (optional)
     * @param  int[] $sa_lifetime_seconds (optional)
     * @param  bool $sa_lifetime_seconds__empty (optional)
     * @param  int[] $sa_lifetime_seconds__gt (optional)
     * @param  int[] $sa_lifetime_seconds__gte (optional)
     * @param  int[] $sa_lifetime_seconds__lt (optional)
     * @param  int[] $sa_lifetime_seconds__lte (optional)
     * @param  int[] $sa_lifetime_seconds__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsListAsync($authentication_algorithm = null, $authentication_algorithm__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encryption_algorithm = null, $encryption_algorithm__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_policy = null, $ipsec_policy__n = null, $ipsec_policy_id = null, $ipsec_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $sa_lifetime_data = null, $sa_lifetime_data__empty = null, $sa_lifetime_data__gt = null, $sa_lifetime_data__gte = null, $sa_lifetime_data__lt = null, $sa_lifetime_data__lte = null, $sa_lifetime_data__n = null, $sa_lifetime_seconds = null, $sa_lifetime_seconds__empty = null, $sa_lifetime_seconds__gt = null, $sa_lifetime_seconds__gte = null, $sa_lifetime_seconds__lt = null, $sa_lifetime_seconds__lte = null, $sa_lifetime_seconds__n = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecProposalsList'][0])
    {
        return $this->vpnIpsecProposalsListAsyncWithHttpInfo($authentication_algorithm, $authentication_algorithm__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encryption_algorithm, $encryption_algorithm__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_policy, $ipsec_policy__n, $ipsec_policy_id, $ipsec_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $sa_lifetime_data, $sa_lifetime_data__empty, $sa_lifetime_data__gt, $sa_lifetime_data__gte, $sa_lifetime_data__lt, $sa_lifetime_data__lte, $sa_lifetime_data__n, $sa_lifetime_seconds, $sa_lifetime_seconds__empty, $sa_lifetime_seconds__gt, $sa_lifetime_seconds__gte, $sa_lifetime_seconds__lt, $sa_lifetime_seconds__lte, $sa_lifetime_seconds__n, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProposalsListAsyncWithHttpInfo
     *
     * @param  string[] $authentication_algorithm (optional)
     * @param  string[] $authentication_algorithm__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encryption_algorithm (optional)
     * @param  string[] $encryption_algorithm__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_policy IPSec policy (name) (optional)
     * @param  string[] $ipsec_policy__n IPSec policy (name) (optional)
     * @param  int[] $ipsec_policy_id IPSec policy (ID) (optional)
     * @param  int[] $ipsec_policy_id__n IPSec policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $sa_lifetime_data (optional)
     * @param  bool $sa_lifetime_data__empty (optional)
     * @param  int[] $sa_lifetime_data__gt (optional)
     * @param  int[] $sa_lifetime_data__gte (optional)
     * @param  int[] $sa_lifetime_data__lt (optional)
     * @param  int[] $sa_lifetime_data__lte (optional)
     * @param  int[] $sa_lifetime_data__n (optional)
     * @param  int[] $sa_lifetime_seconds (optional)
     * @param  bool $sa_lifetime_seconds__empty (optional)
     * @param  int[] $sa_lifetime_seconds__gt (optional)
     * @param  int[] $sa_lifetime_seconds__gte (optional)
     * @param  int[] $sa_lifetime_seconds__lt (optional)
     * @param  int[] $sa_lifetime_seconds__lte (optional)
     * @param  int[] $sa_lifetime_seconds__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsListAsyncWithHttpInfo($authentication_algorithm = null, $authentication_algorithm__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encryption_algorithm = null, $encryption_algorithm__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_policy = null, $ipsec_policy__n = null, $ipsec_policy_id = null, $ipsec_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $sa_lifetime_data = null, $sa_lifetime_data__empty = null, $sa_lifetime_data__gt = null, $sa_lifetime_data__gte = null, $sa_lifetime_data__lt = null, $sa_lifetime_data__lte = null, $sa_lifetime_data__n = null, $sa_lifetime_seconds = null, $sa_lifetime_seconds__empty = null, $sa_lifetime_seconds__gt = null, $sa_lifetime_seconds__gte = null, $sa_lifetime_seconds__lt = null, $sa_lifetime_seconds__lte = null, $sa_lifetime_seconds__n = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecProposalsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedIPSecProposalList';
        $request = $this->vpnIpsecProposalsListRequest($authentication_algorithm, $authentication_algorithm__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encryption_algorithm, $encryption_algorithm__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_policy, $ipsec_policy__n, $ipsec_policy_id, $ipsec_policy_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $sa_lifetime_data, $sa_lifetime_data__empty, $sa_lifetime_data__gt, $sa_lifetime_data__gte, $sa_lifetime_data__lt, $sa_lifetime_data__lte, $sa_lifetime_data__n, $sa_lifetime_seconds, $sa_lifetime_seconds__empty, $sa_lifetime_seconds__gt, $sa_lifetime_seconds__gte, $sa_lifetime_seconds__lt, $sa_lifetime_seconds__lte, $sa_lifetime_seconds__n, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProposalsList'
     *
     * @param  string[] $authentication_algorithm (optional)
     * @param  string[] $authentication_algorithm__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encryption_algorithm (optional)
     * @param  string[] $encryption_algorithm__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_policy IPSec policy (name) (optional)
     * @param  string[] $ipsec_policy__n IPSec policy (name) (optional)
     * @param  int[] $ipsec_policy_id IPSec policy (ID) (optional)
     * @param  int[] $ipsec_policy_id__n IPSec policy (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $sa_lifetime_data (optional)
     * @param  bool $sa_lifetime_data__empty (optional)
     * @param  int[] $sa_lifetime_data__gt (optional)
     * @param  int[] $sa_lifetime_data__gte (optional)
     * @param  int[] $sa_lifetime_data__lt (optional)
     * @param  int[] $sa_lifetime_data__lte (optional)
     * @param  int[] $sa_lifetime_data__n (optional)
     * @param  int[] $sa_lifetime_seconds (optional)
     * @param  bool $sa_lifetime_seconds__empty (optional)
     * @param  int[] $sa_lifetime_seconds__gt (optional)
     * @param  int[] $sa_lifetime_seconds__gte (optional)
     * @param  int[] $sa_lifetime_seconds__lt (optional)
     * @param  int[] $sa_lifetime_seconds__lte (optional)
     * @param  int[] $sa_lifetime_seconds__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProposalsListRequest($authentication_algorithm = null, $authentication_algorithm__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encryption_algorithm = null, $encryption_algorithm__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_policy = null, $ipsec_policy__n = null, $ipsec_policy_id = null, $ipsec_policy_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $sa_lifetime_data = null, $sa_lifetime_data__empty = null, $sa_lifetime_data__gt = null, $sa_lifetime_data__gte = null, $sa_lifetime_data__lt = null, $sa_lifetime_data__lte = null, $sa_lifetime_data__n = null, $sa_lifetime_seconds = null, $sa_lifetime_seconds__empty = null, $sa_lifetime_seconds__gt = null, $sa_lifetime_seconds__gte = null, $sa_lifetime_seconds__lt = null, $sa_lifetime_seconds__lte = null, $sa_lifetime_seconds__n = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnIpsecProposalsList'][0])
    {












































































        $resourcePath = '/api/vpn/ipsec-proposals/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $authentication_algorithm,
            'authentication_algorithm', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $authentication_algorithm__n,
            'authentication_algorithm__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $encryption_algorithm,
            'encryption_algorithm', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $encryption_algorithm__n,
            'encryption_algorithm__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_policy,
            'ipsec_policy', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_policy__n,
            'ipsec_policy__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_policy_id,
            'ipsec_policy_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_policy_id__n,
            'ipsec_policy_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_data,
            'sa_lifetime_data', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_data__empty,
            'sa_lifetime_data__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_data__gt,
            'sa_lifetime_data__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_data__gte,
            'sa_lifetime_data__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_data__lt,
            'sa_lifetime_data__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_data__lte,
            'sa_lifetime_data__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_data__n,
            'sa_lifetime_data__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_seconds,
            'sa_lifetime_seconds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_seconds__empty,
            'sa_lifetime_seconds__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_seconds__gt,
            'sa_lifetime_seconds__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_seconds__gte,
            'sa_lifetime_seconds__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_seconds__lt,
            'sa_lifetime_seconds__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_seconds__lte,
            'sa_lifetime_seconds__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sa_lifetime_seconds__n,
            'sa_lifetime_seconds__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProposalsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecProposalRequest $patched_writable_ip_sec_proposal_request patched_writable_ip_sec_proposal_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProposal
     */
    public function vpnIpsecProposalsPartialUpdate($id, $patched_writable_ip_sec_proposal_request = null, string $contentType = self::contentTypes['vpnIpsecProposalsPartialUpdate'][0])
    {
        list($response) = $this->vpnIpsecProposalsPartialUpdateWithHttpInfo($id, $patched_writable_ip_sec_proposal_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProposalsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecProposalRequest $patched_writable_ip_sec_proposal_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProposal, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProposalsPartialUpdateWithHttpInfo($id, $patched_writable_ip_sec_proposal_request = null, string $contentType = self::contentTypes['vpnIpsecProposalsPartialUpdate'][0])
    {
        $request = $this->vpnIpsecProposalsPartialUpdateRequest($id, $patched_writable_ip_sec_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecProposal' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProposal' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProposal', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProposal';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProposal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProposalsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecProposalRequest $patched_writable_ip_sec_proposal_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsPartialUpdateAsync($id, $patched_writable_ip_sec_proposal_request = null, string $contentType = self::contentTypes['vpnIpsecProposalsPartialUpdate'][0])
    {
        return $this->vpnIpsecProposalsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ip_sec_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProposalsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecProposalRequest $patched_writable_ip_sec_proposal_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_ip_sec_proposal_request = null, string $contentType = self::contentTypes['vpnIpsecProposalsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProposal';
        $request = $this->vpnIpsecProposalsPartialUpdateRequest($id, $patched_writable_ip_sec_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProposalsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableIPSecProposalRequest $patched_writable_ip_sec_proposal_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProposalsPartialUpdateRequest($id, $patched_writable_ip_sec_proposal_request = null, string $contentType = self::contentTypes['vpnIpsecProposalsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecProposalsPartialUpdate'
            );
        }



        $resourcePath = '/api/vpn/ipsec-proposals/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_ip_sec_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_ip_sec_proposal_request));
            } else {
                $httpBody = $patched_writable_ip_sec_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProposalsRetrieve
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProposal
     */
    public function vpnIpsecProposalsRetrieve($id, string $contentType = self::contentTypes['vpnIpsecProposalsRetrieve'][0])
    {
        list($response) = $this->vpnIpsecProposalsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProposalsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProposal, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProposalsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecProposalsRetrieve'][0])
    {
        $request = $this->vpnIpsecProposalsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecProposal' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProposal' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProposal', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProposal';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProposal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProposalsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsRetrieveAsync($id, string $contentType = self::contentTypes['vpnIpsecProposalsRetrieve'][0])
    {
        return $this->vpnIpsecProposalsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProposalsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnIpsecProposalsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProposal';
        $request = $this->vpnIpsecProposalsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProposalsRetrieve'
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProposalsRetrieveRequest($id, string $contentType = self::contentTypes['vpnIpsecProposalsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecProposalsRetrieve'
            );
        }


        $resourcePath = '/api/vpn/ipsec-proposals/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnIpsecProposalsUpdate
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecProposalRequest $writable_ip_sec_proposal_request writable_ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IPSecProposal
     */
    public function vpnIpsecProposalsUpdate($id, $writable_ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsUpdate'][0])
    {
        list($response) = $this->vpnIpsecProposalsUpdateWithHttpInfo($id, $writable_ip_sec_proposal_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnIpsecProposalsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecProposalRequest $writable_ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IPSecProposal, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnIpsecProposalsUpdateWithHttpInfo($id, $writable_ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsUpdate'][0])
    {
        $request = $this->vpnIpsecProposalsUpdateRequest($id, $writable_ip_sec_proposal_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\IPSecProposal' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\IPSecProposal' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\IPSecProposal', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\IPSecProposal';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IPSecProposal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnIpsecProposalsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecProposalRequest $writable_ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsUpdateAsync($id, $writable_ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsUpdate'][0])
    {
        return $this->vpnIpsecProposalsUpdateAsyncWithHttpInfo($id, $writable_ip_sec_proposal_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnIpsecProposalsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecProposalRequest $writable_ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnIpsecProposalsUpdateAsyncWithHttpInfo($id, $writable_ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IPSecProposal';
        $request = $this->vpnIpsecProposalsUpdateRequest($id, $writable_ip_sec_proposal_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnIpsecProposalsUpdate'
     *
     * @param  int $id A unique integer value identifying this IPSec proposal. (required)
     * @param  \OpenAPI\Client\Model\WritableIPSecProposalRequest $writable_ip_sec_proposal_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnIpsecProposalsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnIpsecProposalsUpdateRequest($id, $writable_ip_sec_proposal_request, string $contentType = self::contentTypes['vpnIpsecProposalsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnIpsecProposalsUpdate'
            );
        }

        // verify the required parameter 'writable_ip_sec_proposal_request' is set
        if ($writable_ip_sec_proposal_request === null || (is_array($writable_ip_sec_proposal_request) && count($writable_ip_sec_proposal_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_ip_sec_proposal_request when calling vpnIpsecProposalsUpdate'
            );
        }


        $resourcePath = '/api/vpn/ipsec-proposals/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_ip_sec_proposal_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_ip_sec_proposal_request));
            } else {
                $httpBody = $writable_ip_sec_proposal_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnTerminationsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnL2vpnTerminationsBulkDestroy($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkDestroy'][0])
    {
        $this->vpnL2vpnTerminationsBulkDestroyWithHttpInfo($l2_vpn_termination_request, $contentType);
    }

    /**
     * Operation vpnL2vpnTerminationsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnTerminationsBulkDestroyWithHttpInfo($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkDestroy'][0])
    {
        $request = $this->vpnL2vpnTerminationsBulkDestroyRequest($l2_vpn_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnTerminationsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsBulkDestroyAsync($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkDestroy'][0])
    {
        return $this->vpnL2vpnTerminationsBulkDestroyAsyncWithHttpInfo($l2_vpn_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnTerminationsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsBulkDestroyAsyncWithHttpInfo($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnL2vpnTerminationsBulkDestroyRequest($l2_vpn_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnTerminationsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnTerminationsBulkDestroyRequest($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkDestroy'][0])
    {

        // verify the required parameter 'l2_vpn_termination_request' is set
        if ($l2_vpn_termination_request === null || (is_array($l2_vpn_termination_request) && count($l2_vpn_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $l2_vpn_termination_request when calling vpnL2vpnTerminationsBulkDestroy'
            );
        }


        $resourcePath = '/api/vpn/l2vpn-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($l2_vpn_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($l2_vpn_termination_request));
            } else {
                $httpBody = $l2_vpn_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnTerminationsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPNTermination[]
     */
    public function vpnL2vpnTerminationsBulkPartialUpdate($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkPartialUpdate'][0])
    {
        list($response) = $this->vpnL2vpnTerminationsBulkPartialUpdateWithHttpInfo($l2_vpn_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnTerminationsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPNTermination[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnTerminationsBulkPartialUpdateWithHttpInfo($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkPartialUpdate'][0])
    {
        $request = $this->vpnL2vpnTerminationsBulkPartialUpdateRequest($l2_vpn_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\L2VPNTermination[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPNTermination[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPNTermination[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPNTermination[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPNTermination[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnTerminationsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsBulkPartialUpdateAsync($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkPartialUpdate'][0])
    {
        return $this->vpnL2vpnTerminationsBulkPartialUpdateAsyncWithHttpInfo($l2_vpn_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnTerminationsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsBulkPartialUpdateAsyncWithHttpInfo($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPNTermination[]';
        $request = $this->vpnL2vpnTerminationsBulkPartialUpdateRequest($l2_vpn_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnTerminationsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnTerminationsBulkPartialUpdateRequest($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'l2_vpn_termination_request' is set
        if ($l2_vpn_termination_request === null || (is_array($l2_vpn_termination_request) && count($l2_vpn_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $l2_vpn_termination_request when calling vpnL2vpnTerminationsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/vpn/l2vpn-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($l2_vpn_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($l2_vpn_termination_request));
            } else {
                $httpBody = $l2_vpn_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnTerminationsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPNTermination[]
     */
    public function vpnL2vpnTerminationsBulkUpdate($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkUpdate'][0])
    {
        list($response) = $this->vpnL2vpnTerminationsBulkUpdateWithHttpInfo($l2_vpn_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnTerminationsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPNTermination[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnTerminationsBulkUpdateWithHttpInfo($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkUpdate'][0])
    {
        $request = $this->vpnL2vpnTerminationsBulkUpdateRequest($l2_vpn_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\L2VPNTermination[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPNTermination[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPNTermination[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPNTermination[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPNTermination[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnTerminationsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsBulkUpdateAsync($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkUpdate'][0])
    {
        return $this->vpnL2vpnTerminationsBulkUpdateAsyncWithHttpInfo($l2_vpn_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnTerminationsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsBulkUpdateAsyncWithHttpInfo($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPNTermination[]';
        $request = $this->vpnL2vpnTerminationsBulkUpdateRequest($l2_vpn_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnTerminationsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest[] $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnTerminationsBulkUpdateRequest($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsBulkUpdate'][0])
    {

        // verify the required parameter 'l2_vpn_termination_request' is set
        if ($l2_vpn_termination_request === null || (is_array($l2_vpn_termination_request) && count($l2_vpn_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $l2_vpn_termination_request when calling vpnL2vpnTerminationsBulkUpdate'
            );
        }


        $resourcePath = '/api/vpn/l2vpn-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($l2_vpn_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($l2_vpn_termination_request));
            } else {
                $httpBody = $l2_vpn_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnTerminationsCreate
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest $l2_vpn_termination_request l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPNTermination
     */
    public function vpnL2vpnTerminationsCreate($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsCreate'][0])
    {
        list($response) = $this->vpnL2vpnTerminationsCreateWithHttpInfo($l2_vpn_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnTerminationsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPNTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnTerminationsCreateWithHttpInfo($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsCreate'][0])
    {
        $request = $this->vpnL2vpnTerminationsCreateRequest($l2_vpn_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\L2VPNTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPNTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPNTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPNTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPNTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnTerminationsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsCreateAsync($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsCreate'][0])
    {
        return $this->vpnL2vpnTerminationsCreateAsyncWithHttpInfo($l2_vpn_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnTerminationsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsCreateAsyncWithHttpInfo($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPNTermination';
        $request = $this->vpnL2vpnTerminationsCreateRequest($l2_vpn_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnTerminationsCreate'
     *
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnTerminationsCreateRequest($l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsCreate'][0])
    {

        // verify the required parameter 'l2_vpn_termination_request' is set
        if ($l2_vpn_termination_request === null || (is_array($l2_vpn_termination_request) && count($l2_vpn_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $l2_vpn_termination_request when calling vpnL2vpnTerminationsCreate'
            );
        }


        $resourcePath = '/api/vpn/l2vpn-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($l2_vpn_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($l2_vpn_termination_request));
            } else {
                $httpBody = $l2_vpn_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnTerminationsDestroy
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnL2vpnTerminationsDestroy($id, string $contentType = self::contentTypes['vpnL2vpnTerminationsDestroy'][0])
    {
        $this->vpnL2vpnTerminationsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation vpnL2vpnTerminationsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnTerminationsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['vpnL2vpnTerminationsDestroy'][0])
    {
        $request = $this->vpnL2vpnTerminationsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnTerminationsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsDestroyAsync($id, string $contentType = self::contentTypes['vpnL2vpnTerminationsDestroy'][0])
    {
        return $this->vpnL2vpnTerminationsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnTerminationsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnL2vpnTerminationsDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnL2vpnTerminationsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnTerminationsDestroy'
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnTerminationsDestroyRequest($id, string $contentType = self::contentTypes['vpnL2vpnTerminationsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnL2vpnTerminationsDestroy'
            );
        }


        $resourcePath = '/api/vpn/l2vpn-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnTerminationsList
     *
     * @param  int[] $assigned_object_id assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n assigned_object_id__n (optional)
     * @param  string $assigned_object_type assigned_object_type (optional)
     * @param  string $assigned_object_type__n assigned_object_type__n (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $device Device (name) (optional)
     * @param  string[] $device__n Device (name) (optional)
     * @param  int[] $device_id Device (ID) (optional)
     * @param  int[] $device_id__n Device (ID) (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  string[] $l2vpn L2VPN (slug) (optional)
     * @param  string[] $l2vpn__n L2VPN (slug) (optional)
     * @param  int[] $l2vpn_id L2VPN (ID) (optional)
     * @param  int[] $l2vpn_id__n L2VPN (ID) (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $region region (optional)
     * @param  int[] $region_id region_id (optional)
     * @param  string[] $site site (optional)
     * @param  int[] $site_id site_id (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string[] $virtual_machine Virtual machine (name) (optional)
     * @param  string[] $virtual_machine__n Virtual machine (name) (optional)
     * @param  int[] $virtual_machine_id Virtual machine (ID) (optional)
     * @param  int[] $virtual_machine_id__n Virtual machine (ID) (optional)
     * @param  string[] $vlan VLAN (name) (optional)
     * @param  string[] $vlan__n VLAN (name) (optional)
     * @param  int[] $vlan_id VLAN (ID) (optional)
     * @param  int[] $vlan_id__n VLAN (ID) (optional)
     * @param  int $vlan_vid VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__empty VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__n VLAN number (1-4094) (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM Interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM Interface (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedL2VPNTerminationList
     */
    public function vpnL2vpnTerminationsList($assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $device = null, $device__n = null, $device_id = null, $device_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $l2vpn = null, $l2vpn__n = null, $l2vpn_id = null, $l2vpn_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $region = null, $region_id = null, $site = null, $site_id = null, $tag = null, $tag__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine__n = null, $virtual_machine_id = null, $virtual_machine_id__n = null, $vlan = null, $vlan__n = null, $vlan_id = null, $vlan_id__n = null, $vlan_vid = null, $vlan_vid__empty = null, $vlan_vid__gt = null, $vlan_vid__gte = null, $vlan_vid__lt = null, $vlan_vid__lte = null, $vlan_vid__n = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, string $contentType = self::contentTypes['vpnL2vpnTerminationsList'][0])
    {
        list($response) = $this->vpnL2vpnTerminationsListWithHttpInfo($assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $device, $device__n, $device_id, $device_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $l2vpn, $l2vpn__n, $l2vpn_id, $l2vpn_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $region, $region_id, $site, $site_id, $tag, $tag__n, $updated_by_request, $virtual_machine, $virtual_machine__n, $virtual_machine_id, $virtual_machine_id__n, $vlan, $vlan__n, $vlan_id, $vlan_id__n, $vlan_vid, $vlan_vid__empty, $vlan_vid__gt, $vlan_vid__gte, $vlan_vid__lt, $vlan_vid__lte, $vlan_vid__n, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnTerminationsListWithHttpInfo
     *
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  string $assigned_object_type (optional)
     * @param  string $assigned_object_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $device Device (name) (optional)
     * @param  string[] $device__n Device (name) (optional)
     * @param  int[] $device_id Device (ID) (optional)
     * @param  int[] $device_id__n Device (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  string[] $l2vpn L2VPN (slug) (optional)
     * @param  string[] $l2vpn__n L2VPN (slug) (optional)
     * @param  int[] $l2vpn_id L2VPN (ID) (optional)
     * @param  int[] $l2vpn_id__n L2VPN (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $region (optional)
     * @param  int[] $region_id (optional)
     * @param  string[] $site (optional)
     * @param  int[] $site_id (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine Virtual machine (name) (optional)
     * @param  string[] $virtual_machine__n Virtual machine (name) (optional)
     * @param  int[] $virtual_machine_id Virtual machine (ID) (optional)
     * @param  int[] $virtual_machine_id__n Virtual machine (ID) (optional)
     * @param  string[] $vlan VLAN (name) (optional)
     * @param  string[] $vlan__n VLAN (name) (optional)
     * @param  int[] $vlan_id VLAN (ID) (optional)
     * @param  int[] $vlan_id__n VLAN (ID) (optional)
     * @param  int $vlan_vid VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__empty VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__n VLAN number (1-4094) (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM Interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM Interface (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedL2VPNTerminationList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnTerminationsListWithHttpInfo($assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $device = null, $device__n = null, $device_id = null, $device_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $l2vpn = null, $l2vpn__n = null, $l2vpn_id = null, $l2vpn_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $region = null, $region_id = null, $site = null, $site_id = null, $tag = null, $tag__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine__n = null, $virtual_machine_id = null, $virtual_machine_id__n = null, $vlan = null, $vlan__n = null, $vlan_id = null, $vlan_id__n = null, $vlan_vid = null, $vlan_vid__empty = null, $vlan_vid__gt = null, $vlan_vid__gte = null, $vlan_vid__lt = null, $vlan_vid__lte = null, $vlan_vid__n = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, string $contentType = self::contentTypes['vpnL2vpnTerminationsList'][0])
    {
        $request = $this->vpnL2vpnTerminationsListRequest($assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $device, $device__n, $device_id, $device_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $l2vpn, $l2vpn__n, $l2vpn_id, $l2vpn_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $region, $region_id, $site, $site_id, $tag, $tag__n, $updated_by_request, $virtual_machine, $virtual_machine__n, $virtual_machine_id, $virtual_machine_id__n, $vlan, $vlan__n, $vlan_id, $vlan_id__n, $vlan_vid, $vlan_vid__empty, $vlan_vid__gt, $vlan_vid__gte, $vlan_vid__lt, $vlan_vid__lte, $vlan_vid__n, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedL2VPNTerminationList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedL2VPNTerminationList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedL2VPNTerminationList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedL2VPNTerminationList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedL2VPNTerminationList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnTerminationsListAsync
     *
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  string $assigned_object_type (optional)
     * @param  string $assigned_object_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $device Device (name) (optional)
     * @param  string[] $device__n Device (name) (optional)
     * @param  int[] $device_id Device (ID) (optional)
     * @param  int[] $device_id__n Device (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  string[] $l2vpn L2VPN (slug) (optional)
     * @param  string[] $l2vpn__n L2VPN (slug) (optional)
     * @param  int[] $l2vpn_id L2VPN (ID) (optional)
     * @param  int[] $l2vpn_id__n L2VPN (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $region (optional)
     * @param  int[] $region_id (optional)
     * @param  string[] $site (optional)
     * @param  int[] $site_id (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine Virtual machine (name) (optional)
     * @param  string[] $virtual_machine__n Virtual machine (name) (optional)
     * @param  int[] $virtual_machine_id Virtual machine (ID) (optional)
     * @param  int[] $virtual_machine_id__n Virtual machine (ID) (optional)
     * @param  string[] $vlan VLAN (name) (optional)
     * @param  string[] $vlan__n VLAN (name) (optional)
     * @param  int[] $vlan_id VLAN (ID) (optional)
     * @param  int[] $vlan_id__n VLAN (ID) (optional)
     * @param  int $vlan_vid VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__empty VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__n VLAN number (1-4094) (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM Interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM Interface (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsListAsync($assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $device = null, $device__n = null, $device_id = null, $device_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $l2vpn = null, $l2vpn__n = null, $l2vpn_id = null, $l2vpn_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $region = null, $region_id = null, $site = null, $site_id = null, $tag = null, $tag__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine__n = null, $virtual_machine_id = null, $virtual_machine_id__n = null, $vlan = null, $vlan__n = null, $vlan_id = null, $vlan_id__n = null, $vlan_vid = null, $vlan_vid__empty = null, $vlan_vid__gt = null, $vlan_vid__gte = null, $vlan_vid__lt = null, $vlan_vid__lte = null, $vlan_vid__n = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, string $contentType = self::contentTypes['vpnL2vpnTerminationsList'][0])
    {
        return $this->vpnL2vpnTerminationsListAsyncWithHttpInfo($assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $device, $device__n, $device_id, $device_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $l2vpn, $l2vpn__n, $l2vpn_id, $l2vpn_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $region, $region_id, $site, $site_id, $tag, $tag__n, $updated_by_request, $virtual_machine, $virtual_machine__n, $virtual_machine_id, $virtual_machine_id__n, $vlan, $vlan__n, $vlan_id, $vlan_id__n, $vlan_vid, $vlan_vid__empty, $vlan_vid__gt, $vlan_vid__gte, $vlan_vid__lt, $vlan_vid__lte, $vlan_vid__n, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnTerminationsListAsyncWithHttpInfo
     *
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  string $assigned_object_type (optional)
     * @param  string $assigned_object_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $device Device (name) (optional)
     * @param  string[] $device__n Device (name) (optional)
     * @param  int[] $device_id Device (ID) (optional)
     * @param  int[] $device_id__n Device (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  string[] $l2vpn L2VPN (slug) (optional)
     * @param  string[] $l2vpn__n L2VPN (slug) (optional)
     * @param  int[] $l2vpn_id L2VPN (ID) (optional)
     * @param  int[] $l2vpn_id__n L2VPN (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $region (optional)
     * @param  int[] $region_id (optional)
     * @param  string[] $site (optional)
     * @param  int[] $site_id (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine Virtual machine (name) (optional)
     * @param  string[] $virtual_machine__n Virtual machine (name) (optional)
     * @param  int[] $virtual_machine_id Virtual machine (ID) (optional)
     * @param  int[] $virtual_machine_id__n Virtual machine (ID) (optional)
     * @param  string[] $vlan VLAN (name) (optional)
     * @param  string[] $vlan__n VLAN (name) (optional)
     * @param  int[] $vlan_id VLAN (ID) (optional)
     * @param  int[] $vlan_id__n VLAN (ID) (optional)
     * @param  int $vlan_vid VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__empty VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__n VLAN number (1-4094) (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM Interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM Interface (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsListAsyncWithHttpInfo($assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $device = null, $device__n = null, $device_id = null, $device_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $l2vpn = null, $l2vpn__n = null, $l2vpn_id = null, $l2vpn_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $region = null, $region_id = null, $site = null, $site_id = null, $tag = null, $tag__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine__n = null, $virtual_machine_id = null, $virtual_machine_id__n = null, $vlan = null, $vlan__n = null, $vlan_id = null, $vlan_id__n = null, $vlan_vid = null, $vlan_vid__empty = null, $vlan_vid__gt = null, $vlan_vid__gte = null, $vlan_vid__lt = null, $vlan_vid__lte = null, $vlan_vid__n = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, string $contentType = self::contentTypes['vpnL2vpnTerminationsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedL2VPNTerminationList';
        $request = $this->vpnL2vpnTerminationsListRequest($assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $device, $device__n, $device_id, $device_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $l2vpn, $l2vpn__n, $l2vpn_id, $l2vpn_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $region, $region_id, $site, $site_id, $tag, $tag__n, $updated_by_request, $virtual_machine, $virtual_machine__n, $virtual_machine_id, $virtual_machine_id__n, $vlan, $vlan__n, $vlan_id, $vlan_id__n, $vlan_vid, $vlan_vid__empty, $vlan_vid__gt, $vlan_vid__gte, $vlan_vid__lt, $vlan_vid__lte, $vlan_vid__n, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnTerminationsList'
     *
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  string $assigned_object_type (optional)
     * @param  string $assigned_object_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $device Device (name) (optional)
     * @param  string[] $device__n Device (name) (optional)
     * @param  int[] $device_id Device (ID) (optional)
     * @param  int[] $device_id__n Device (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  string[] $l2vpn L2VPN (slug) (optional)
     * @param  string[] $l2vpn__n L2VPN (slug) (optional)
     * @param  int[] $l2vpn_id L2VPN (ID) (optional)
     * @param  int[] $l2vpn_id__n L2VPN (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $region (optional)
     * @param  int[] $region_id (optional)
     * @param  string[] $site (optional)
     * @param  int[] $site_id (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $virtual_machine Virtual machine (name) (optional)
     * @param  string[] $virtual_machine__n Virtual machine (name) (optional)
     * @param  int[] $virtual_machine_id Virtual machine (ID) (optional)
     * @param  int[] $virtual_machine_id__n Virtual machine (ID) (optional)
     * @param  string[] $vlan VLAN (name) (optional)
     * @param  string[] $vlan__n VLAN (name) (optional)
     * @param  int[] $vlan_id VLAN (ID) (optional)
     * @param  int[] $vlan_id__n VLAN (ID) (optional)
     * @param  int $vlan_vid VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__empty VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__gte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lt VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__lte VLAN number (1-4094) (optional)
     * @param  int $vlan_vid__n VLAN number (1-4094) (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM Interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM Interface (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnTerminationsListRequest($assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $device = null, $device__n = null, $device_id = null, $device_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $l2vpn = null, $l2vpn__n = null, $l2vpn_id = null, $l2vpn_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $region = null, $region_id = null, $site = null, $site_id = null, $tag = null, $tag__n = null, $updated_by_request = null, $virtual_machine = null, $virtual_machine__n = null, $virtual_machine_id = null, $virtual_machine_id__n = null, $vlan = null, $vlan__n = null, $vlan_id = null, $vlan_id__n = null, $vlan_vid = null, $vlan_vid__empty = null, $vlan_vid__gt = null, $vlan_vid__gte = null, $vlan_vid__lt = null, $vlan_vid__lte = null, $vlan_vid__n = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, string $contentType = self::contentTypes['vpnL2vpnTerminationsList'][0])
    {












































































        $resourcePath = '/api/vpn/l2vpn-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id,
            'assigned_object_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__empty,
            'assigned_object_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__gt,
            'assigned_object_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__gte,
            'assigned_object_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__lt,
            'assigned_object_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__lte,
            'assigned_object_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__n,
            'assigned_object_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_type,
            'assigned_object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_type__n,
            'assigned_object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device,
            'device', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device__n,
            'device__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'device_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id__n,
            'device_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface,
            'interface', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface__n,
            'interface__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id,
            'interface_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id__n,
            'interface_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $l2vpn,
            'l2vpn', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $l2vpn__n,
            'l2vpn__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $l2vpn_id,
            'l2vpn_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $l2vpn_id__n,
            'l2vpn_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region,
            'region', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region_id,
            'region_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site,
            'site', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id,
            'site_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine,
            'virtual_machine', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine__n,
            'virtual_machine__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine_id,
            'virtual_machine_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $virtual_machine_id__n,
            'virtual_machine_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan,
            'vlan', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan__n,
            'vlan__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_id,
            'vlan_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_id__n,
            'vlan_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid,
            'vlan_vid', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__empty,
            'vlan_vid__empty', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__gt,
            'vlan_vid__gt', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__gte,
            'vlan_vid__gte', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__lt,
            'vlan_vid__lt', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__lte,
            'vlan_vid__lte', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan_vid__n,
            'vlan_vid__n', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface,
            'vminterface', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface__n,
            'vminterface__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface_id,
            'vminterface_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface_id__n,
            'vminterface_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnTerminationsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedL2VPNTerminationRequest $patched_l2_vpn_termination_request patched_l2_vpn_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPNTermination
     */
    public function vpnL2vpnTerminationsPartialUpdate($id, $patched_l2_vpn_termination_request = null, string $contentType = self::contentTypes['vpnL2vpnTerminationsPartialUpdate'][0])
    {
        list($response) = $this->vpnL2vpnTerminationsPartialUpdateWithHttpInfo($id, $patched_l2_vpn_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnTerminationsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedL2VPNTerminationRequest $patched_l2_vpn_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPNTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnTerminationsPartialUpdateWithHttpInfo($id, $patched_l2_vpn_termination_request = null, string $contentType = self::contentTypes['vpnL2vpnTerminationsPartialUpdate'][0])
    {
        $request = $this->vpnL2vpnTerminationsPartialUpdateRequest($id, $patched_l2_vpn_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\L2VPNTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPNTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPNTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPNTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPNTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnTerminationsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedL2VPNTerminationRequest $patched_l2_vpn_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsPartialUpdateAsync($id, $patched_l2_vpn_termination_request = null, string $contentType = self::contentTypes['vpnL2vpnTerminationsPartialUpdate'][0])
    {
        return $this->vpnL2vpnTerminationsPartialUpdateAsyncWithHttpInfo($id, $patched_l2_vpn_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnTerminationsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedL2VPNTerminationRequest $patched_l2_vpn_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsPartialUpdateAsyncWithHttpInfo($id, $patched_l2_vpn_termination_request = null, string $contentType = self::contentTypes['vpnL2vpnTerminationsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPNTermination';
        $request = $this->vpnL2vpnTerminationsPartialUpdateRequest($id, $patched_l2_vpn_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnTerminationsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedL2VPNTerminationRequest $patched_l2_vpn_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnTerminationsPartialUpdateRequest($id, $patched_l2_vpn_termination_request = null, string $contentType = self::contentTypes['vpnL2vpnTerminationsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnL2vpnTerminationsPartialUpdate'
            );
        }



        $resourcePath = '/api/vpn/l2vpn-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_l2_vpn_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_l2_vpn_termination_request));
            } else {
                $httpBody = $patched_l2_vpn_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnTerminationsRetrieve
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPNTermination
     */
    public function vpnL2vpnTerminationsRetrieve($id, string $contentType = self::contentTypes['vpnL2vpnTerminationsRetrieve'][0])
    {
        list($response) = $this->vpnL2vpnTerminationsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnTerminationsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPNTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnTerminationsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['vpnL2vpnTerminationsRetrieve'][0])
    {
        $request = $this->vpnL2vpnTerminationsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\L2VPNTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPNTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPNTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPNTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPNTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnTerminationsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsRetrieveAsync($id, string $contentType = self::contentTypes['vpnL2vpnTerminationsRetrieve'][0])
    {
        return $this->vpnL2vpnTerminationsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnTerminationsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnL2vpnTerminationsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPNTermination';
        $request = $this->vpnL2vpnTerminationsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnTerminationsRetrieve'
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnTerminationsRetrieveRequest($id, string $contentType = self::contentTypes['vpnL2vpnTerminationsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnL2vpnTerminationsRetrieve'
            );
        }


        $resourcePath = '/api/vpn/l2vpn-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnTerminationsUpdate
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest $l2_vpn_termination_request l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPNTermination
     */
    public function vpnL2vpnTerminationsUpdate($id, $l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsUpdate'][0])
    {
        list($response) = $this->vpnL2vpnTerminationsUpdateWithHttpInfo($id, $l2_vpn_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnTerminationsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPNTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnTerminationsUpdateWithHttpInfo($id, $l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsUpdate'][0])
    {
        $request = $this->vpnL2vpnTerminationsUpdateRequest($id, $l2_vpn_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\L2VPNTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPNTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPNTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPNTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPNTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnTerminationsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsUpdateAsync($id, $l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsUpdate'][0])
    {
        return $this->vpnL2vpnTerminationsUpdateAsyncWithHttpInfo($id, $l2_vpn_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnTerminationsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnTerminationsUpdateAsyncWithHttpInfo($id, $l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPNTermination';
        $request = $this->vpnL2vpnTerminationsUpdateRequest($id, $l2_vpn_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnTerminationsUpdate'
     *
     * @param  int $id A unique integer value identifying this L2VPN termination. (required)
     * @param  \OpenAPI\Client\Model\L2VPNTerminationRequest $l2_vpn_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnTerminationsUpdateRequest($id, $l2_vpn_termination_request, string $contentType = self::contentTypes['vpnL2vpnTerminationsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnL2vpnTerminationsUpdate'
            );
        }

        // verify the required parameter 'l2_vpn_termination_request' is set
        if ($l2_vpn_termination_request === null || (is_array($l2_vpn_termination_request) && count($l2_vpn_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $l2_vpn_termination_request when calling vpnL2vpnTerminationsUpdate'
            );
        }


        $resourcePath = '/api/vpn/l2vpn-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($l2_vpn_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($l2_vpn_termination_request));
            } else {
                $httpBody = $l2_vpn_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnL2vpnsBulkDestroy($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkDestroy'][0])
    {
        $this->vpnL2vpnsBulkDestroyWithHttpInfo($l2_vpn_request, $contentType);
    }

    /**
     * Operation vpnL2vpnsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnsBulkDestroyWithHttpInfo($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkDestroy'][0])
    {
        $request = $this->vpnL2vpnsBulkDestroyRequest($l2_vpn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsBulkDestroyAsync($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkDestroy'][0])
    {
        return $this->vpnL2vpnsBulkDestroyAsyncWithHttpInfo($l2_vpn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsBulkDestroyAsyncWithHttpInfo($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnL2vpnsBulkDestroyRequest($l2_vpn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnsBulkDestroyRequest($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkDestroy'][0])
    {

        // verify the required parameter 'l2_vpn_request' is set
        if ($l2_vpn_request === null || (is_array($l2_vpn_request) && count($l2_vpn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $l2_vpn_request when calling vpnL2vpnsBulkDestroy'
            );
        }


        $resourcePath = '/api/vpn/l2vpns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($l2_vpn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($l2_vpn_request));
            } else {
                $httpBody = $l2_vpn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPN[]
     */
    public function vpnL2vpnsBulkPartialUpdate($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkPartialUpdate'][0])
    {
        list($response) = $this->vpnL2vpnsBulkPartialUpdateWithHttpInfo($l2_vpn_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnsBulkPartialUpdateWithHttpInfo($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkPartialUpdate'][0])
    {
        $request = $this->vpnL2vpnsBulkPartialUpdateRequest($l2_vpn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\L2VPN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsBulkPartialUpdateAsync($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkPartialUpdate'][0])
    {
        return $this->vpnL2vpnsBulkPartialUpdateAsyncWithHttpInfo($l2_vpn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsBulkPartialUpdateAsyncWithHttpInfo($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPN[]';
        $request = $this->vpnL2vpnsBulkPartialUpdateRequest($l2_vpn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnsBulkPartialUpdateRequest($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'l2_vpn_request' is set
        if ($l2_vpn_request === null || (is_array($l2_vpn_request) && count($l2_vpn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $l2_vpn_request when calling vpnL2vpnsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/vpn/l2vpns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($l2_vpn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($l2_vpn_request));
            } else {
                $httpBody = $l2_vpn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPN[]
     */
    public function vpnL2vpnsBulkUpdate($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkUpdate'][0])
    {
        list($response) = $this->vpnL2vpnsBulkUpdateWithHttpInfo($l2_vpn_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPN[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnsBulkUpdateWithHttpInfo($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkUpdate'][0])
    {
        $request = $this->vpnL2vpnsBulkUpdateRequest($l2_vpn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\L2VPN[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPN[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPN[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPN[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPN[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsBulkUpdateAsync($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkUpdate'][0])
    {
        return $this->vpnL2vpnsBulkUpdateAsyncWithHttpInfo($l2_vpn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsBulkUpdateAsyncWithHttpInfo($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPN[]';
        $request = $this->vpnL2vpnsBulkUpdateRequest($l2_vpn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\L2VPNRequest[] $l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnsBulkUpdateRequest($l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsBulkUpdate'][0])
    {

        // verify the required parameter 'l2_vpn_request' is set
        if ($l2_vpn_request === null || (is_array($l2_vpn_request) && count($l2_vpn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $l2_vpn_request when calling vpnL2vpnsBulkUpdate'
            );
        }


        $resourcePath = '/api/vpn/l2vpns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($l2_vpn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($l2_vpn_request));
            } else {
                $httpBody = $l2_vpn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnsCreate
     *
     * @param  \OpenAPI\Client\Model\WritableL2VPNRequest $writable_l2_vpn_request writable_l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPN
     */
    public function vpnL2vpnsCreate($writable_l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsCreate'][0])
    {
        list($response) = $this->vpnL2vpnsCreateWithHttpInfo($writable_l2_vpn_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableL2VPNRequest $writable_l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPN, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnsCreateWithHttpInfo($writable_l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsCreate'][0])
    {
        $request = $this->vpnL2vpnsCreateRequest($writable_l2_vpn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\L2VPN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableL2VPNRequest $writable_l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsCreateAsync($writable_l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsCreate'][0])
    {
        return $this->vpnL2vpnsCreateAsyncWithHttpInfo($writable_l2_vpn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableL2VPNRequest $writable_l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsCreateAsyncWithHttpInfo($writable_l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPN';
        $request = $this->vpnL2vpnsCreateRequest($writable_l2_vpn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnsCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableL2VPNRequest $writable_l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnsCreateRequest($writable_l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsCreate'][0])
    {

        // verify the required parameter 'writable_l2_vpn_request' is set
        if ($writable_l2_vpn_request === null || (is_array($writable_l2_vpn_request) && count($writable_l2_vpn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_l2_vpn_request when calling vpnL2vpnsCreate'
            );
        }


        $resourcePath = '/api/vpn/l2vpns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_l2_vpn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_l2_vpn_request));
            } else {
                $httpBody = $writable_l2_vpn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnsDestroy
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnL2vpnsDestroy($id, string $contentType = self::contentTypes['vpnL2vpnsDestroy'][0])
    {
        $this->vpnL2vpnsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation vpnL2vpnsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['vpnL2vpnsDestroy'][0])
    {
        $request = $this->vpnL2vpnsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsDestroyAsync($id, string $contentType = self::contentTypes['vpnL2vpnsDestroy'][0])
    {
        return $this->vpnL2vpnsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnL2vpnsDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnL2vpnsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnsDestroy'
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnsDestroyRequest($id, string $contentType = self::contentTypes['vpnL2vpnsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnL2vpnsDestroy'
            );
        }


        $resourcePath = '/api/vpn/l2vpns/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnsList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $export_target Export target (name) (optional)
     * @param  string[] $export_target__n Export target (name) (optional)
     * @param  int[] $export_target_id Export target (optional)
     * @param  int[] $export_target_id__n Export target (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  int[] $identifier identifier (optional)
     * @param  bool $identifier__empty identifier__empty (optional)
     * @param  int[] $identifier__gt identifier__gt (optional)
     * @param  int[] $identifier__gte identifier__gte (optional)
     * @param  int[] $identifier__lt identifier__lt (optional)
     * @param  int[] $identifier__lte identifier__lte (optional)
     * @param  int[] $identifier__n identifier__n (optional)
     * @param  string[] $import_target Import target (name) (optional)
     * @param  string[] $import_target__n Import target (name) (optional)
     * @param  int[] $import_target_id Import target (optional)
     * @param  int[] $import_target_id__n Import target (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug slug (optional)
     * @param  bool $slug__empty slug__empty (optional)
     * @param  string[] $slug__ic slug__ic (optional)
     * @param  string[] $slug__ie slug__ie (optional)
     * @param  string[] $slug__iew slug__iew (optional)
     * @param  string[] $slug__isw slug__isw (optional)
     * @param  string[] $slug__n slug__n (optional)
     * @param  string[] $slug__nic slug__nic (optional)
     * @param  string[] $slug__nie slug__nie (optional)
     * @param  string[] $slug__niew slug__niew (optional)
     * @param  string[] $slug__nisw slug__nisw (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group tenant_group (optional)
     * @param  string[] $tenant_group__n tenant_group__n (optional)
     * @param  string[] $tenant_group_id tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string[] $type type (optional)
     * @param  string[] $type__n type__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedL2VPNList
     */
    public function vpnL2vpnsList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $export_target = null, $export_target__n = null, $export_target_id = null, $export_target_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $identifier = null, $identifier__empty = null, $identifier__gt = null, $identifier__gte = null, $identifier__lt = null, $identifier__lte = null, $identifier__n = null, $import_target = null, $import_target__n = null, $import_target_id = null, $import_target_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $type = null, $type__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnL2vpnsList'][0])
    {
        list($response) = $this->vpnL2vpnsListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $export_target, $export_target__n, $export_target_id, $export_target_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $identifier, $identifier__empty, $identifier__gt, $identifier__gte, $identifier__lt, $identifier__lte, $identifier__n, $import_target, $import_target__n, $import_target_id, $import_target_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $type, $type__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnsListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $export_target Export target (name) (optional)
     * @param  string[] $export_target__n Export target (name) (optional)
     * @param  int[] $export_target_id Export target (optional)
     * @param  int[] $export_target_id__n Export target (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $identifier (optional)
     * @param  bool $identifier__empty (optional)
     * @param  int[] $identifier__gt (optional)
     * @param  int[] $identifier__gte (optional)
     * @param  int[] $identifier__lt (optional)
     * @param  int[] $identifier__lte (optional)
     * @param  int[] $identifier__n (optional)
     * @param  string[] $import_target Import target (name) (optional)
     * @param  string[] $import_target__n Import target (name) (optional)
     * @param  int[] $import_target_id Import target (optional)
     * @param  int[] $import_target_id__n Import target (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string[] $type (optional)
     * @param  string[] $type__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedL2VPNList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnsListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $export_target = null, $export_target__n = null, $export_target_id = null, $export_target_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $identifier = null, $identifier__empty = null, $identifier__gt = null, $identifier__gte = null, $identifier__lt = null, $identifier__lte = null, $identifier__n = null, $import_target = null, $import_target__n = null, $import_target_id = null, $import_target_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $type = null, $type__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnL2vpnsList'][0])
    {
        $request = $this->vpnL2vpnsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $export_target, $export_target__n, $export_target_id, $export_target_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $identifier, $identifier__empty, $identifier__gt, $identifier__gte, $identifier__lt, $identifier__lte, $identifier__n, $import_target, $import_target__n, $import_target_id, $import_target_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $type, $type__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedL2VPNList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedL2VPNList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedL2VPNList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedL2VPNList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedL2VPNList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnsListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $export_target Export target (name) (optional)
     * @param  string[] $export_target__n Export target (name) (optional)
     * @param  int[] $export_target_id Export target (optional)
     * @param  int[] $export_target_id__n Export target (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $identifier (optional)
     * @param  bool $identifier__empty (optional)
     * @param  int[] $identifier__gt (optional)
     * @param  int[] $identifier__gte (optional)
     * @param  int[] $identifier__lt (optional)
     * @param  int[] $identifier__lte (optional)
     * @param  int[] $identifier__n (optional)
     * @param  string[] $import_target Import target (name) (optional)
     * @param  string[] $import_target__n Import target (name) (optional)
     * @param  int[] $import_target_id Import target (optional)
     * @param  int[] $import_target_id__n Import target (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string[] $type (optional)
     * @param  string[] $type__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $export_target = null, $export_target__n = null, $export_target_id = null, $export_target_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $identifier = null, $identifier__empty = null, $identifier__gt = null, $identifier__gte = null, $identifier__lt = null, $identifier__lte = null, $identifier__n = null, $import_target = null, $import_target__n = null, $import_target_id = null, $import_target_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $type = null, $type__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnL2vpnsList'][0])
    {
        return $this->vpnL2vpnsListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $export_target, $export_target__n, $export_target_id, $export_target_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $identifier, $identifier__empty, $identifier__gt, $identifier__gte, $identifier__lt, $identifier__lte, $identifier__n, $import_target, $import_target__n, $import_target_id, $import_target_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $type, $type__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnsListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $export_target Export target (name) (optional)
     * @param  string[] $export_target__n Export target (name) (optional)
     * @param  int[] $export_target_id Export target (optional)
     * @param  int[] $export_target_id__n Export target (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $identifier (optional)
     * @param  bool $identifier__empty (optional)
     * @param  int[] $identifier__gt (optional)
     * @param  int[] $identifier__gte (optional)
     * @param  int[] $identifier__lt (optional)
     * @param  int[] $identifier__lte (optional)
     * @param  int[] $identifier__n (optional)
     * @param  string[] $import_target Import target (name) (optional)
     * @param  string[] $import_target__n Import target (name) (optional)
     * @param  int[] $import_target_id Import target (optional)
     * @param  int[] $import_target_id__n Import target (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string[] $type (optional)
     * @param  string[] $type__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $export_target = null, $export_target__n = null, $export_target_id = null, $export_target_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $identifier = null, $identifier__empty = null, $identifier__gt = null, $identifier__gte = null, $identifier__lt = null, $identifier__lte = null, $identifier__n = null, $import_target = null, $import_target__n = null, $import_target_id = null, $import_target_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $type = null, $type__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnL2vpnsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedL2VPNList';
        $request = $this->vpnL2vpnsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $export_target, $export_target__n, $export_target_id, $export_target_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $identifier, $identifier__empty, $identifier__gt, $identifier__gte, $identifier__lt, $identifier__lte, $identifier__n, $import_target, $import_target__n, $import_target_id, $import_target_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $type, $type__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnsList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $export_target Export target (name) (optional)
     * @param  string[] $export_target__n Export target (name) (optional)
     * @param  int[] $export_target_id Export target (optional)
     * @param  int[] $export_target_id__n Export target (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $identifier (optional)
     * @param  bool $identifier__empty (optional)
     * @param  int[] $identifier__gt (optional)
     * @param  int[] $identifier__gte (optional)
     * @param  int[] $identifier__lt (optional)
     * @param  int[] $identifier__lte (optional)
     * @param  int[] $identifier__n (optional)
     * @param  string[] $import_target Import target (name) (optional)
     * @param  string[] $import_target__n Import target (name) (optional)
     * @param  int[] $import_target_id Import target (optional)
     * @param  int[] $import_target_id__n Import target (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  string[] $type (optional)
     * @param  string[] $type__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnsListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $export_target = null, $export_target__n = null, $export_target_id = null, $export_target_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $identifier = null, $identifier__empty = null, $identifier__gt = null, $identifier__gte = null, $identifier__lt = null, $identifier__lte = null, $identifier__n = null, $import_target = null, $import_target__n = null, $import_target_id = null, $import_target_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $type = null, $type__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnL2vpnsList'][0])
    {


























































































        $resourcePath = '/api/vpn/l2vpns/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export_target,
            'export_target', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export_target__n,
            'export_target__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export_target_id,
            'export_target_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export_target_id__n,
            'export_target_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $identifier,
            'identifier', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $identifier__empty,
            'identifier__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $identifier__gt,
            'identifier__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $identifier__gte,
            'identifier__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $identifier__lt,
            'identifier__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $identifier__lte,
            'identifier__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $identifier__n,
            'identifier__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $import_target,
            'import_target', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $import_target__n,
            'import_target__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $import_target_id,
            'import_target_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $import_target_id__n,
            'import_target_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__empty,
            'slug__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ic,
            'slug__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ie,
            'slug__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__iew,
            'slug__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__isw,
            'slug__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__n,
            'slug__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nic,
            'slug__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nie,
            'slug__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__niew,
            'slug__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nisw,
            'slug__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type__n,
            'type__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableL2VPNRequest $patched_writable_l2_vpn_request patched_writable_l2_vpn_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPN
     */
    public function vpnL2vpnsPartialUpdate($id, $patched_writable_l2_vpn_request = null, string $contentType = self::contentTypes['vpnL2vpnsPartialUpdate'][0])
    {
        list($response) = $this->vpnL2vpnsPartialUpdateWithHttpInfo($id, $patched_writable_l2_vpn_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableL2VPNRequest $patched_writable_l2_vpn_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPN, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnsPartialUpdateWithHttpInfo($id, $patched_writable_l2_vpn_request = null, string $contentType = self::contentTypes['vpnL2vpnsPartialUpdate'][0])
    {
        $request = $this->vpnL2vpnsPartialUpdateRequest($id, $patched_writable_l2_vpn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\L2VPN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableL2VPNRequest $patched_writable_l2_vpn_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsPartialUpdateAsync($id, $patched_writable_l2_vpn_request = null, string $contentType = self::contentTypes['vpnL2vpnsPartialUpdate'][0])
    {
        return $this->vpnL2vpnsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_l2_vpn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableL2VPNRequest $patched_writable_l2_vpn_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_l2_vpn_request = null, string $contentType = self::contentTypes['vpnL2vpnsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPN';
        $request = $this->vpnL2vpnsPartialUpdateRequest($id, $patched_writable_l2_vpn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableL2VPNRequest $patched_writable_l2_vpn_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnsPartialUpdateRequest($id, $patched_writable_l2_vpn_request = null, string $contentType = self::contentTypes['vpnL2vpnsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnL2vpnsPartialUpdate'
            );
        }



        $resourcePath = '/api/vpn/l2vpns/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_l2_vpn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_l2_vpn_request));
            } else {
                $httpBody = $patched_writable_l2_vpn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnsRetrieve
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPN
     */
    public function vpnL2vpnsRetrieve($id, string $contentType = self::contentTypes['vpnL2vpnsRetrieve'][0])
    {
        list($response) = $this->vpnL2vpnsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPN, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['vpnL2vpnsRetrieve'][0])
    {
        $request = $this->vpnL2vpnsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\L2VPN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsRetrieveAsync($id, string $contentType = self::contentTypes['vpnL2vpnsRetrieve'][0])
    {
        return $this->vpnL2vpnsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnL2vpnsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPN';
        $request = $this->vpnL2vpnsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnsRetrieve'
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnsRetrieveRequest($id, string $contentType = self::contentTypes['vpnL2vpnsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnL2vpnsRetrieve'
            );
        }


        $resourcePath = '/api/vpn/l2vpns/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnL2vpnsUpdate
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  \OpenAPI\Client\Model\WritableL2VPNRequest $writable_l2_vpn_request writable_l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\L2VPN
     */
    public function vpnL2vpnsUpdate($id, $writable_l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsUpdate'][0])
    {
        list($response) = $this->vpnL2vpnsUpdateWithHttpInfo($id, $writable_l2_vpn_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnL2vpnsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  \OpenAPI\Client\Model\WritableL2VPNRequest $writable_l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\L2VPN, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnL2vpnsUpdateWithHttpInfo($id, $writable_l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsUpdate'][0])
    {
        $request = $this->vpnL2vpnsUpdateRequest($id, $writable_l2_vpn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\L2VPN' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\L2VPN' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\L2VPN', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\L2VPN';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\L2VPN',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnL2vpnsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  \OpenAPI\Client\Model\WritableL2VPNRequest $writable_l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsUpdateAsync($id, $writable_l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsUpdate'][0])
    {
        return $this->vpnL2vpnsUpdateAsyncWithHttpInfo($id, $writable_l2_vpn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnL2vpnsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  \OpenAPI\Client\Model\WritableL2VPNRequest $writable_l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnL2vpnsUpdateAsyncWithHttpInfo($id, $writable_l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\L2VPN';
        $request = $this->vpnL2vpnsUpdateRequest($id, $writable_l2_vpn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnL2vpnsUpdate'
     *
     * @param  int $id A unique integer value identifying this L2VPN. (required)
     * @param  \OpenAPI\Client\Model\WritableL2VPNRequest $writable_l2_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnL2vpnsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnL2vpnsUpdateRequest($id, $writable_l2_vpn_request, string $contentType = self::contentTypes['vpnL2vpnsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnL2vpnsUpdate'
            );
        }

        // verify the required parameter 'writable_l2_vpn_request' is set
        if ($writable_l2_vpn_request === null || (is_array($writable_l2_vpn_request) && count($writable_l2_vpn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_l2_vpn_request when calling vpnL2vpnsUpdate'
            );
        }


        $resourcePath = '/api/vpn/l2vpns/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_l2_vpn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_l2_vpn_request));
            } else {
                $httpBody = $writable_l2_vpn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelGroupsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnTunnelGroupsBulkDestroy($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkDestroy'][0])
    {
        $this->vpnTunnelGroupsBulkDestroyWithHttpInfo($tunnel_group_request, $contentType);
    }

    /**
     * Operation vpnTunnelGroupsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelGroupsBulkDestroyWithHttpInfo($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkDestroy'][0])
    {
        $request = $this->vpnTunnelGroupsBulkDestroyRequest($tunnel_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelGroupsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsBulkDestroyAsync($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkDestroy'][0])
    {
        return $this->vpnTunnelGroupsBulkDestroyAsyncWithHttpInfo($tunnel_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelGroupsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsBulkDestroyAsyncWithHttpInfo($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnTunnelGroupsBulkDestroyRequest($tunnel_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelGroupsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelGroupsBulkDestroyRequest($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkDestroy'][0])
    {

        // verify the required parameter 'tunnel_group_request' is set
        if ($tunnel_group_request === null || (is_array($tunnel_group_request) && count($tunnel_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tunnel_group_request when calling vpnTunnelGroupsBulkDestroy'
            );
        }


        $resourcePath = '/api/vpn/tunnel-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tunnel_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tunnel_group_request));
            } else {
                $httpBody = $tunnel_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelGroupsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelGroup[]
     */
    public function vpnTunnelGroupsBulkPartialUpdate($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkPartialUpdate'][0])
    {
        list($response) = $this->vpnTunnelGroupsBulkPartialUpdateWithHttpInfo($tunnel_group_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelGroupsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelGroupsBulkPartialUpdateWithHttpInfo($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkPartialUpdate'][0])
    {
        $request = $this->vpnTunnelGroupsBulkPartialUpdateRequest($tunnel_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunnelGroup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelGroup[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelGroup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelGroupsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsBulkPartialUpdateAsync($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkPartialUpdate'][0])
    {
        return $this->vpnTunnelGroupsBulkPartialUpdateAsyncWithHttpInfo($tunnel_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelGroupsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsBulkPartialUpdateAsyncWithHttpInfo($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelGroup[]';
        $request = $this->vpnTunnelGroupsBulkPartialUpdateRequest($tunnel_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelGroupsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelGroupsBulkPartialUpdateRequest($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'tunnel_group_request' is set
        if ($tunnel_group_request === null || (is_array($tunnel_group_request) && count($tunnel_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tunnel_group_request when calling vpnTunnelGroupsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/vpn/tunnel-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tunnel_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tunnel_group_request));
            } else {
                $httpBody = $tunnel_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelGroupsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelGroup[]
     */
    public function vpnTunnelGroupsBulkUpdate($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkUpdate'][0])
    {
        list($response) = $this->vpnTunnelGroupsBulkUpdateWithHttpInfo($tunnel_group_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelGroupsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelGroupsBulkUpdateWithHttpInfo($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkUpdate'][0])
    {
        $request = $this->vpnTunnelGroupsBulkUpdateRequest($tunnel_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunnelGroup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelGroup[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelGroup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelGroupsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsBulkUpdateAsync($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkUpdate'][0])
    {
        return $this->vpnTunnelGroupsBulkUpdateAsyncWithHttpInfo($tunnel_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelGroupsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsBulkUpdateAsyncWithHttpInfo($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelGroup[]';
        $request = $this->vpnTunnelGroupsBulkUpdateRequest($tunnel_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelGroupsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest[] $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelGroupsBulkUpdateRequest($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsBulkUpdate'][0])
    {

        // verify the required parameter 'tunnel_group_request' is set
        if ($tunnel_group_request === null || (is_array($tunnel_group_request) && count($tunnel_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tunnel_group_request when calling vpnTunnelGroupsBulkUpdate'
            );
        }


        $resourcePath = '/api/vpn/tunnel-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tunnel_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tunnel_group_request));
            } else {
                $httpBody = $tunnel_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelGroupsCreate
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest $tunnel_group_request tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelGroup
     */
    public function vpnTunnelGroupsCreate($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsCreate'][0])
    {
        list($response) = $this->vpnTunnelGroupsCreateWithHttpInfo($tunnel_group_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelGroupsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelGroupsCreateWithHttpInfo($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsCreate'][0])
    {
        $request = $this->vpnTunnelGroupsCreateRequest($tunnel_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\TunnelGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelGroupsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsCreateAsync($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsCreate'][0])
    {
        return $this->vpnTunnelGroupsCreateAsyncWithHttpInfo($tunnel_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelGroupsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsCreateAsyncWithHttpInfo($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelGroup';
        $request = $this->vpnTunnelGroupsCreateRequest($tunnel_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelGroupsCreate'
     *
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelGroupsCreateRequest($tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsCreate'][0])
    {

        // verify the required parameter 'tunnel_group_request' is set
        if ($tunnel_group_request === null || (is_array($tunnel_group_request) && count($tunnel_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tunnel_group_request when calling vpnTunnelGroupsCreate'
            );
        }


        $resourcePath = '/api/vpn/tunnel-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tunnel_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tunnel_group_request));
            } else {
                $httpBody = $tunnel_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelGroupsDestroy
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnTunnelGroupsDestroy($id, string $contentType = self::contentTypes['vpnTunnelGroupsDestroy'][0])
    {
        $this->vpnTunnelGroupsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation vpnTunnelGroupsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelGroupsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelGroupsDestroy'][0])
    {
        $request = $this->vpnTunnelGroupsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelGroupsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsDestroyAsync($id, string $contentType = self::contentTypes['vpnTunnelGroupsDestroy'][0])
    {
        return $this->vpnTunnelGroupsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelGroupsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelGroupsDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnTunnelGroupsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelGroupsDestroy'
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelGroupsDestroyRequest($id, string $contentType = self::contentTypes['vpnTunnelGroupsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelGroupsDestroy'
            );
        }


        $resourcePath = '/api/vpn/tunnel-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelGroupsList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug slug (optional)
     * @param  bool $slug__empty slug__empty (optional)
     * @param  string[] $slug__ic slug__ic (optional)
     * @param  string[] $slug__ie slug__ie (optional)
     * @param  string[] $slug__iew slug__iew (optional)
     * @param  string[] $slug__isw slug__isw (optional)
     * @param  string[] $slug__n slug__n (optional)
     * @param  string[] $slug__nic slug__nic (optional)
     * @param  string[] $slug__nie slug__nie (optional)
     * @param  string[] $slug__niew slug__niew (optional)
     * @param  string[] $slug__nisw slug__nisw (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedTunnelGroupList
     */
    public function vpnTunnelGroupsList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnTunnelGroupsList'][0])
    {
        list($response) = $this->vpnTunnelGroupsListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelGroupsListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedTunnelGroupList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelGroupsListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnTunnelGroupsList'][0])
    {
        $request = $this->vpnTunnelGroupsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedTunnelGroupList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedTunnelGroupList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedTunnelGroupList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedTunnelGroupList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedTunnelGroupList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelGroupsListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnTunnelGroupsList'][0])
    {
        return $this->vpnTunnelGroupsListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelGroupsListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnTunnelGroupsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedTunnelGroupList';
        $request = $this->vpnTunnelGroupsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelGroupsList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelGroupsListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnTunnelGroupsList'][0])
    {

































































        $resourcePath = '/api/vpn/tunnel-groups/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__empty,
            'slug__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ic,
            'slug__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ie,
            'slug__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__iew,
            'slug__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__isw,
            'slug__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__n,
            'slug__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nic,
            'slug__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nie,
            'slug__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__niew,
            'slug__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nisw,
            'slug__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelGroupsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  \OpenAPI\Client\Model\PatchedTunnelGroupRequest $patched_tunnel_group_request patched_tunnel_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelGroup
     */
    public function vpnTunnelGroupsPartialUpdate($id, $patched_tunnel_group_request = null, string $contentType = self::contentTypes['vpnTunnelGroupsPartialUpdate'][0])
    {
        list($response) = $this->vpnTunnelGroupsPartialUpdateWithHttpInfo($id, $patched_tunnel_group_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelGroupsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  \OpenAPI\Client\Model\PatchedTunnelGroupRequest $patched_tunnel_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelGroupsPartialUpdateWithHttpInfo($id, $patched_tunnel_group_request = null, string $contentType = self::contentTypes['vpnTunnelGroupsPartialUpdate'][0])
    {
        $request = $this->vpnTunnelGroupsPartialUpdateRequest($id, $patched_tunnel_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunnelGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelGroupsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  \OpenAPI\Client\Model\PatchedTunnelGroupRequest $patched_tunnel_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsPartialUpdateAsync($id, $patched_tunnel_group_request = null, string $contentType = self::contentTypes['vpnTunnelGroupsPartialUpdate'][0])
    {
        return $this->vpnTunnelGroupsPartialUpdateAsyncWithHttpInfo($id, $patched_tunnel_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelGroupsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  \OpenAPI\Client\Model\PatchedTunnelGroupRequest $patched_tunnel_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsPartialUpdateAsyncWithHttpInfo($id, $patched_tunnel_group_request = null, string $contentType = self::contentTypes['vpnTunnelGroupsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelGroup';
        $request = $this->vpnTunnelGroupsPartialUpdateRequest($id, $patched_tunnel_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelGroupsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  \OpenAPI\Client\Model\PatchedTunnelGroupRequest $patched_tunnel_group_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelGroupsPartialUpdateRequest($id, $patched_tunnel_group_request = null, string $contentType = self::contentTypes['vpnTunnelGroupsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelGroupsPartialUpdate'
            );
        }



        $resourcePath = '/api/vpn/tunnel-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_tunnel_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_tunnel_group_request));
            } else {
                $httpBody = $patched_tunnel_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelGroupsRetrieve
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelGroup
     */
    public function vpnTunnelGroupsRetrieve($id, string $contentType = self::contentTypes['vpnTunnelGroupsRetrieve'][0])
    {
        list($response) = $this->vpnTunnelGroupsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelGroupsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelGroupsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelGroupsRetrieve'][0])
    {
        $request = $this->vpnTunnelGroupsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunnelGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelGroupsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsRetrieveAsync($id, string $contentType = self::contentTypes['vpnTunnelGroupsRetrieve'][0])
    {
        return $this->vpnTunnelGroupsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelGroupsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelGroupsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelGroup';
        $request = $this->vpnTunnelGroupsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelGroupsRetrieve'
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelGroupsRetrieveRequest($id, string $contentType = self::contentTypes['vpnTunnelGroupsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelGroupsRetrieve'
            );
        }


        $resourcePath = '/api/vpn/tunnel-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelGroupsUpdate
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest $tunnel_group_request tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelGroup
     */
    public function vpnTunnelGroupsUpdate($id, $tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsUpdate'][0])
    {
        list($response) = $this->vpnTunnelGroupsUpdateWithHttpInfo($id, $tunnel_group_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelGroupsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelGroupsUpdateWithHttpInfo($id, $tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsUpdate'][0])
    {
        $request = $this->vpnTunnelGroupsUpdateRequest($id, $tunnel_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunnelGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelGroup' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelGroupsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsUpdateAsync($id, $tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsUpdate'][0])
    {
        return $this->vpnTunnelGroupsUpdateAsyncWithHttpInfo($id, $tunnel_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelGroupsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelGroupsUpdateAsyncWithHttpInfo($id, $tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelGroup';
        $request = $this->vpnTunnelGroupsUpdateRequest($id, $tunnel_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelGroupsUpdate'
     *
     * @param  int $id A unique integer value identifying this tunnel group. (required)
     * @param  \OpenAPI\Client\Model\TunnelGroupRequest $tunnel_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelGroupsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelGroupsUpdateRequest($id, $tunnel_group_request, string $contentType = self::contentTypes['vpnTunnelGroupsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelGroupsUpdate'
            );
        }

        // verify the required parameter 'tunnel_group_request' is set
        if ($tunnel_group_request === null || (is_array($tunnel_group_request) && count($tunnel_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tunnel_group_request when calling vpnTunnelGroupsUpdate'
            );
        }


        $resourcePath = '/api/vpn/tunnel-groups/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tunnel_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tunnel_group_request));
            } else {
                $httpBody = $tunnel_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelTerminationsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnTunnelTerminationsBulkDestroy($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkDestroy'][0])
    {
        $this->vpnTunnelTerminationsBulkDestroyWithHttpInfo($tunnel_termination_request, $contentType);
    }

    /**
     * Operation vpnTunnelTerminationsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelTerminationsBulkDestroyWithHttpInfo($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkDestroy'][0])
    {
        $request = $this->vpnTunnelTerminationsBulkDestroyRequest($tunnel_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelTerminationsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsBulkDestroyAsync($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkDestroy'][0])
    {
        return $this->vpnTunnelTerminationsBulkDestroyAsyncWithHttpInfo($tunnel_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelTerminationsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsBulkDestroyAsyncWithHttpInfo($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnTunnelTerminationsBulkDestroyRequest($tunnel_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelTerminationsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelTerminationsBulkDestroyRequest($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkDestroy'][0])
    {

        // verify the required parameter 'tunnel_termination_request' is set
        if ($tunnel_termination_request === null || (is_array($tunnel_termination_request) && count($tunnel_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tunnel_termination_request when calling vpnTunnelTerminationsBulkDestroy'
            );
        }


        $resourcePath = '/api/vpn/tunnel-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tunnel_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tunnel_termination_request));
            } else {
                $httpBody = $tunnel_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelTerminationsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelTermination[]
     */
    public function vpnTunnelTerminationsBulkPartialUpdate($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkPartialUpdate'][0])
    {
        list($response) = $this->vpnTunnelTerminationsBulkPartialUpdateWithHttpInfo($tunnel_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelTerminationsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelTermination[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelTerminationsBulkPartialUpdateWithHttpInfo($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkPartialUpdate'][0])
    {
        $request = $this->vpnTunnelTerminationsBulkPartialUpdateRequest($tunnel_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunnelTermination[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelTermination[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelTermination[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelTermination[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelTermination[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelTerminationsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsBulkPartialUpdateAsync($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkPartialUpdate'][0])
    {
        return $this->vpnTunnelTerminationsBulkPartialUpdateAsyncWithHttpInfo($tunnel_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelTerminationsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsBulkPartialUpdateAsyncWithHttpInfo($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelTermination[]';
        $request = $this->vpnTunnelTerminationsBulkPartialUpdateRequest($tunnel_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelTerminationsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelTerminationsBulkPartialUpdateRequest($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'tunnel_termination_request' is set
        if ($tunnel_termination_request === null || (is_array($tunnel_termination_request) && count($tunnel_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tunnel_termination_request when calling vpnTunnelTerminationsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/vpn/tunnel-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tunnel_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tunnel_termination_request));
            } else {
                $httpBody = $tunnel_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelTerminationsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelTermination[]
     */
    public function vpnTunnelTerminationsBulkUpdate($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkUpdate'][0])
    {
        list($response) = $this->vpnTunnelTerminationsBulkUpdateWithHttpInfo($tunnel_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelTerminationsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelTermination[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelTerminationsBulkUpdateWithHttpInfo($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkUpdate'][0])
    {
        $request = $this->vpnTunnelTerminationsBulkUpdateRequest($tunnel_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunnelTermination[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelTermination[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelTermination[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelTermination[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelTermination[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelTerminationsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsBulkUpdateAsync($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkUpdate'][0])
    {
        return $this->vpnTunnelTerminationsBulkUpdateAsyncWithHttpInfo($tunnel_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelTerminationsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsBulkUpdateAsyncWithHttpInfo($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelTermination[]';
        $request = $this->vpnTunnelTerminationsBulkUpdateRequest($tunnel_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelTerminationsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\TunnelTerminationRequest[] $tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelTerminationsBulkUpdateRequest($tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsBulkUpdate'][0])
    {

        // verify the required parameter 'tunnel_termination_request' is set
        if ($tunnel_termination_request === null || (is_array($tunnel_termination_request) && count($tunnel_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tunnel_termination_request when calling vpnTunnelTerminationsBulkUpdate'
            );
        }


        $resourcePath = '/api/vpn/tunnel-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tunnel_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tunnel_termination_request));
            } else {
                $httpBody = $tunnel_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelTerminationsCreate
     *
     * @param  \OpenAPI\Client\Model\WritableTunnelTerminationRequest $writable_tunnel_termination_request writable_tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelTermination
     */
    public function vpnTunnelTerminationsCreate($writable_tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsCreate'][0])
    {
        list($response) = $this->vpnTunnelTerminationsCreateWithHttpInfo($writable_tunnel_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelTerminationsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableTunnelTerminationRequest $writable_tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelTerminationsCreateWithHttpInfo($writable_tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsCreate'][0])
    {
        $request = $this->vpnTunnelTerminationsCreateRequest($writable_tunnel_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\TunnelTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelTerminationsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableTunnelTerminationRequest $writable_tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsCreateAsync($writable_tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsCreate'][0])
    {
        return $this->vpnTunnelTerminationsCreateAsyncWithHttpInfo($writable_tunnel_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelTerminationsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableTunnelTerminationRequest $writable_tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsCreateAsyncWithHttpInfo($writable_tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelTermination';
        $request = $this->vpnTunnelTerminationsCreateRequest($writable_tunnel_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelTerminationsCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableTunnelTerminationRequest $writable_tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelTerminationsCreateRequest($writable_tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsCreate'][0])
    {

        // verify the required parameter 'writable_tunnel_termination_request' is set
        if ($writable_tunnel_termination_request === null || (is_array($writable_tunnel_termination_request) && count($writable_tunnel_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_tunnel_termination_request when calling vpnTunnelTerminationsCreate'
            );
        }


        $resourcePath = '/api/vpn/tunnel-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_tunnel_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_tunnel_termination_request));
            } else {
                $httpBody = $writable_tunnel_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelTerminationsDestroy
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnTunnelTerminationsDestroy($id, string $contentType = self::contentTypes['vpnTunnelTerminationsDestroy'][0])
    {
        $this->vpnTunnelTerminationsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation vpnTunnelTerminationsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelTerminationsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelTerminationsDestroy'][0])
    {
        $request = $this->vpnTunnelTerminationsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelTerminationsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsDestroyAsync($id, string $contentType = self::contentTypes['vpnTunnelTerminationsDestroy'][0])
    {
        return $this->vpnTunnelTerminationsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelTerminationsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelTerminationsDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnTunnelTerminationsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelTerminationsDestroy'
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelTerminationsDestroyRequest($id, string $contentType = self::contentTypes['vpnTunnelTerminationsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelTerminationsDestroy'
            );
        }


        $resourcePath = '/api/vpn/tunnel-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelTerminationsList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $outside_ip_id Outside IP (ID) (optional)
     * @param  int[] $outside_ip_id__n Outside IP (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role role (optional)
     * @param  string[] $role__n role__n (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  int[] $termination_id termination_id (optional)
     * @param  bool $termination_id__empty termination_id__empty (optional)
     * @param  int[] $termination_id__gt termination_id__gt (optional)
     * @param  int[] $termination_id__gte termination_id__gte (optional)
     * @param  int[] $termination_id__lt termination_id__lt (optional)
     * @param  int[] $termination_id__lte termination_id__lte (optional)
     * @param  int[] $termination_id__n termination_id__n (optional)
     * @param  string $termination_type termination_type (optional)
     * @param  string $termination_type__n termination_type__n (optional)
     * @param  string[] $tunnel Tunnel (name) (optional)
     * @param  string[] $tunnel__n Tunnel (name) (optional)
     * @param  int[] $tunnel_id Tunnel (ID) (optional)
     * @param  int[] $tunnel_id__n Tunnel (ID) (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM interface (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedTunnelTerminationList
     */
    public function vpnTunnelTerminationsList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $outside_ip_id = null, $outside_ip_id__n = null, $q = null, $role = null, $role__n = null, $tag = null, $tag__n = null, $termination_id = null, $termination_id__empty = null, $termination_id__gt = null, $termination_id__gte = null, $termination_id__lt = null, $termination_id__lte = null, $termination_id__n = null, $termination_type = null, $termination_type__n = null, $tunnel = null, $tunnel__n = null, $tunnel_id = null, $tunnel_id__n = null, $updated_by_request = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, string $contentType = self::contentTypes['vpnTunnelTerminationsList'][0])
    {
        list($response) = $this->vpnTunnelTerminationsListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $outside_ip_id, $outside_ip_id__n, $q, $role, $role__n, $tag, $tag__n, $termination_id, $termination_id__empty, $termination_id__gt, $termination_id__gte, $termination_id__lt, $termination_id__lte, $termination_id__n, $termination_type, $termination_type__n, $tunnel, $tunnel__n, $tunnel_id, $tunnel_id__n, $updated_by_request, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelTerminationsListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $outside_ip_id Outside IP (ID) (optional)
     * @param  int[] $outside_ip_id__n Outside IP (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role (optional)
     * @param  string[] $role__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  int[] $termination_id (optional)
     * @param  bool $termination_id__empty (optional)
     * @param  int[] $termination_id__gt (optional)
     * @param  int[] $termination_id__gte (optional)
     * @param  int[] $termination_id__lt (optional)
     * @param  int[] $termination_id__lte (optional)
     * @param  int[] $termination_id__n (optional)
     * @param  string $termination_type (optional)
     * @param  string $termination_type__n (optional)
     * @param  string[] $tunnel Tunnel (name) (optional)
     * @param  string[] $tunnel__n Tunnel (name) (optional)
     * @param  int[] $tunnel_id Tunnel (ID) (optional)
     * @param  int[] $tunnel_id__n Tunnel (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM interface (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedTunnelTerminationList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelTerminationsListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $outside_ip_id = null, $outside_ip_id__n = null, $q = null, $role = null, $role__n = null, $tag = null, $tag__n = null, $termination_id = null, $termination_id__empty = null, $termination_id__gt = null, $termination_id__gte = null, $termination_id__lt = null, $termination_id__lte = null, $termination_id__n = null, $termination_type = null, $termination_type__n = null, $tunnel = null, $tunnel__n = null, $tunnel_id = null, $tunnel_id__n = null, $updated_by_request = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, string $contentType = self::contentTypes['vpnTunnelTerminationsList'][0])
    {
        $request = $this->vpnTunnelTerminationsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $outside_ip_id, $outside_ip_id__n, $q, $role, $role__n, $tag, $tag__n, $termination_id, $termination_id__empty, $termination_id__gt, $termination_id__gte, $termination_id__lt, $termination_id__lte, $termination_id__n, $termination_type, $termination_type__n, $tunnel, $tunnel__n, $tunnel_id, $tunnel_id__n, $updated_by_request, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedTunnelTerminationList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedTunnelTerminationList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedTunnelTerminationList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedTunnelTerminationList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedTunnelTerminationList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelTerminationsListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $outside_ip_id Outside IP (ID) (optional)
     * @param  int[] $outside_ip_id__n Outside IP (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role (optional)
     * @param  string[] $role__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  int[] $termination_id (optional)
     * @param  bool $termination_id__empty (optional)
     * @param  int[] $termination_id__gt (optional)
     * @param  int[] $termination_id__gte (optional)
     * @param  int[] $termination_id__lt (optional)
     * @param  int[] $termination_id__lte (optional)
     * @param  int[] $termination_id__n (optional)
     * @param  string $termination_type (optional)
     * @param  string $termination_type__n (optional)
     * @param  string[] $tunnel Tunnel (name) (optional)
     * @param  string[] $tunnel__n Tunnel (name) (optional)
     * @param  int[] $tunnel_id Tunnel (ID) (optional)
     * @param  int[] $tunnel_id__n Tunnel (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM interface (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $outside_ip_id = null, $outside_ip_id__n = null, $q = null, $role = null, $role__n = null, $tag = null, $tag__n = null, $termination_id = null, $termination_id__empty = null, $termination_id__gt = null, $termination_id__gte = null, $termination_id__lt = null, $termination_id__lte = null, $termination_id__n = null, $termination_type = null, $termination_type__n = null, $tunnel = null, $tunnel__n = null, $tunnel_id = null, $tunnel_id__n = null, $updated_by_request = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, string $contentType = self::contentTypes['vpnTunnelTerminationsList'][0])
    {
        return $this->vpnTunnelTerminationsListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $outside_ip_id, $outside_ip_id__n, $q, $role, $role__n, $tag, $tag__n, $termination_id, $termination_id__empty, $termination_id__gt, $termination_id__gte, $termination_id__lt, $termination_id__lte, $termination_id__n, $termination_type, $termination_type__n, $tunnel, $tunnel__n, $tunnel_id, $tunnel_id__n, $updated_by_request, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelTerminationsListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $outside_ip_id Outside IP (ID) (optional)
     * @param  int[] $outside_ip_id__n Outside IP (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role (optional)
     * @param  string[] $role__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  int[] $termination_id (optional)
     * @param  bool $termination_id__empty (optional)
     * @param  int[] $termination_id__gt (optional)
     * @param  int[] $termination_id__gte (optional)
     * @param  int[] $termination_id__lt (optional)
     * @param  int[] $termination_id__lte (optional)
     * @param  int[] $termination_id__n (optional)
     * @param  string $termination_type (optional)
     * @param  string $termination_type__n (optional)
     * @param  string[] $tunnel Tunnel (name) (optional)
     * @param  string[] $tunnel__n Tunnel (name) (optional)
     * @param  int[] $tunnel_id Tunnel (ID) (optional)
     * @param  int[] $tunnel_id__n Tunnel (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM interface (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $outside_ip_id = null, $outside_ip_id__n = null, $q = null, $role = null, $role__n = null, $tag = null, $tag__n = null, $termination_id = null, $termination_id__empty = null, $termination_id__gt = null, $termination_id__gte = null, $termination_id__lt = null, $termination_id__lte = null, $termination_id__n = null, $termination_type = null, $termination_type__n = null, $tunnel = null, $tunnel__n = null, $tunnel_id = null, $tunnel_id__n = null, $updated_by_request = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, string $contentType = self::contentTypes['vpnTunnelTerminationsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedTunnelTerminationList';
        $request = $this->vpnTunnelTerminationsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $interface, $interface__n, $interface_id, $interface_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $outside_ip_id, $outside_ip_id__n, $q, $role, $role__n, $tag, $tag__n, $termination_id, $termination_id__empty, $termination_id__gt, $termination_id__gte, $termination_id__lt, $termination_id__lte, $termination_id__n, $termination_type, $termination_type__n, $tunnel, $tunnel__n, $tunnel_id, $tunnel_id__n, $updated_by_request, $vminterface, $vminterface__n, $vminterface_id, $vminterface_id__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelTerminationsList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $interface Interface (name) (optional)
     * @param  string[] $interface__n Interface (name) (optional)
     * @param  int[] $interface_id Interface (ID) (optional)
     * @param  int[] $interface_id__n Interface (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  int[] $outside_ip_id Outside IP (ID) (optional)
     * @param  int[] $outside_ip_id__n Outside IP (ID) (optional)
     * @param  string $q Search (optional)
     * @param  string[] $role (optional)
     * @param  string[] $role__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  int[] $termination_id (optional)
     * @param  bool $termination_id__empty (optional)
     * @param  int[] $termination_id__gt (optional)
     * @param  int[] $termination_id__gte (optional)
     * @param  int[] $termination_id__lt (optional)
     * @param  int[] $termination_id__lte (optional)
     * @param  int[] $termination_id__n (optional)
     * @param  string $termination_type (optional)
     * @param  string $termination_type__n (optional)
     * @param  string[] $tunnel Tunnel (name) (optional)
     * @param  string[] $tunnel__n Tunnel (name) (optional)
     * @param  int[] $tunnel_id Tunnel (ID) (optional)
     * @param  int[] $tunnel_id__n Tunnel (ID) (optional)
     * @param  string $updated_by_request (optional)
     * @param  string[] $vminterface VM interface (name) (optional)
     * @param  string[] $vminterface__n VM interface (name) (optional)
     * @param  int[] $vminterface_id VM interface (ID) (optional)
     * @param  int[] $vminterface_id__n VM interface (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelTerminationsListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $interface = null, $interface__n = null, $interface_id = null, $interface_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $outside_ip_id = null, $outside_ip_id__n = null, $q = null, $role = null, $role__n = null, $tag = null, $tag__n = null, $termination_id = null, $termination_id__empty = null, $termination_id__gt = null, $termination_id__gte = null, $termination_id__lt = null, $termination_id__lte = null, $termination_id__n = null, $termination_type = null, $termination_type__n = null, $tunnel = null, $tunnel__n = null, $tunnel_id = null, $tunnel_id__n = null, $updated_by_request = null, $vminterface = null, $vminterface__n = null, $vminterface_id = null, $vminterface_id__n = null, string $contentType = self::contentTypes['vpnTunnelTerminationsList'][0])
    {

























































        $resourcePath = '/api/vpn/tunnel-terminations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface,
            'interface', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface__n,
            'interface__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id,
            'interface_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interface_id__n,
            'interface_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $outside_ip_id,
            'outside_ip_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $outside_ip_id__n,
            'outside_ip_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role,
            'role', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role__n,
            'role__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_id,
            'termination_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_id__empty,
            'termination_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_id__gt,
            'termination_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_id__gte,
            'termination_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_id__lt,
            'termination_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_id__lte,
            'termination_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_id__n,
            'termination_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_type,
            'termination_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $termination_type__n,
            'termination_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tunnel,
            'tunnel', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tunnel__n,
            'tunnel__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tunnel_id,
            'tunnel_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tunnel_id__n,
            'tunnel_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface,
            'vminterface', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface__n,
            'vminterface__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface_id,
            'vminterface_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vminterface_id__n,
            'vminterface_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelTerminationsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableTunnelTerminationRequest $patched_writable_tunnel_termination_request patched_writable_tunnel_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelTermination
     */
    public function vpnTunnelTerminationsPartialUpdate($id, $patched_writable_tunnel_termination_request = null, string $contentType = self::contentTypes['vpnTunnelTerminationsPartialUpdate'][0])
    {
        list($response) = $this->vpnTunnelTerminationsPartialUpdateWithHttpInfo($id, $patched_writable_tunnel_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelTerminationsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableTunnelTerminationRequest $patched_writable_tunnel_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelTerminationsPartialUpdateWithHttpInfo($id, $patched_writable_tunnel_termination_request = null, string $contentType = self::contentTypes['vpnTunnelTerminationsPartialUpdate'][0])
    {
        $request = $this->vpnTunnelTerminationsPartialUpdateRequest($id, $patched_writable_tunnel_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunnelTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelTerminationsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableTunnelTerminationRequest $patched_writable_tunnel_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsPartialUpdateAsync($id, $patched_writable_tunnel_termination_request = null, string $contentType = self::contentTypes['vpnTunnelTerminationsPartialUpdate'][0])
    {
        return $this->vpnTunnelTerminationsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_tunnel_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelTerminationsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableTunnelTerminationRequest $patched_writable_tunnel_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_tunnel_termination_request = null, string $contentType = self::contentTypes['vpnTunnelTerminationsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelTermination';
        $request = $this->vpnTunnelTerminationsPartialUpdateRequest($id, $patched_writable_tunnel_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelTerminationsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableTunnelTerminationRequest $patched_writable_tunnel_termination_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelTerminationsPartialUpdateRequest($id, $patched_writable_tunnel_termination_request = null, string $contentType = self::contentTypes['vpnTunnelTerminationsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelTerminationsPartialUpdate'
            );
        }



        $resourcePath = '/api/vpn/tunnel-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_tunnel_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_tunnel_termination_request));
            } else {
                $httpBody = $patched_writable_tunnel_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelTerminationsRetrieve
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelTermination
     */
    public function vpnTunnelTerminationsRetrieve($id, string $contentType = self::contentTypes['vpnTunnelTerminationsRetrieve'][0])
    {
        list($response) = $this->vpnTunnelTerminationsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelTerminationsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelTerminationsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelTerminationsRetrieve'][0])
    {
        $request = $this->vpnTunnelTerminationsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunnelTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelTerminationsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsRetrieveAsync($id, string $contentType = self::contentTypes['vpnTunnelTerminationsRetrieve'][0])
    {
        return $this->vpnTunnelTerminationsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelTerminationsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelTerminationsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelTermination';
        $request = $this->vpnTunnelTerminationsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelTerminationsRetrieve'
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelTerminationsRetrieveRequest($id, string $contentType = self::contentTypes['vpnTunnelTerminationsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelTerminationsRetrieve'
            );
        }


        $resourcePath = '/api/vpn/tunnel-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelTerminationsUpdate
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  \OpenAPI\Client\Model\WritableTunnelTerminationRequest $writable_tunnel_termination_request writable_tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunnelTermination
     */
    public function vpnTunnelTerminationsUpdate($id, $writable_tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsUpdate'][0])
    {
        list($response) = $this->vpnTunnelTerminationsUpdateWithHttpInfo($id, $writable_tunnel_termination_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelTerminationsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  \OpenAPI\Client\Model\WritableTunnelTerminationRequest $writable_tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunnelTermination, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelTerminationsUpdateWithHttpInfo($id, $writable_tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsUpdate'][0])
    {
        $request = $this->vpnTunnelTerminationsUpdateRequest($id, $writable_tunnel_termination_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunnelTermination' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunnelTermination' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunnelTermination', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunnelTermination';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunnelTermination',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelTerminationsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  \OpenAPI\Client\Model\WritableTunnelTerminationRequest $writable_tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsUpdateAsync($id, $writable_tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsUpdate'][0])
    {
        return $this->vpnTunnelTerminationsUpdateAsyncWithHttpInfo($id, $writable_tunnel_termination_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelTerminationsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  \OpenAPI\Client\Model\WritableTunnelTerminationRequest $writable_tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelTerminationsUpdateAsyncWithHttpInfo($id, $writable_tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunnelTermination';
        $request = $this->vpnTunnelTerminationsUpdateRequest($id, $writable_tunnel_termination_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelTerminationsUpdate'
     *
     * @param  int $id A unique integer value identifying this tunnel termination. (required)
     * @param  \OpenAPI\Client\Model\WritableTunnelTerminationRequest $writable_tunnel_termination_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelTerminationsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelTerminationsUpdateRequest($id, $writable_tunnel_termination_request, string $contentType = self::contentTypes['vpnTunnelTerminationsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelTerminationsUpdate'
            );
        }

        // verify the required parameter 'writable_tunnel_termination_request' is set
        if ($writable_tunnel_termination_request === null || (is_array($writable_tunnel_termination_request) && count($writable_tunnel_termination_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_tunnel_termination_request when calling vpnTunnelTerminationsUpdate'
            );
        }


        $resourcePath = '/api/vpn/tunnel-terminations/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_tunnel_termination_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_tunnel_termination_request));
            } else {
                $httpBody = $writable_tunnel_termination_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnTunnelsBulkDestroy($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkDestroy'][0])
    {
        $this->vpnTunnelsBulkDestroyWithHttpInfo($tunnel_request, $contentType);
    }

    /**
     * Operation vpnTunnelsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelsBulkDestroyWithHttpInfo($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkDestroy'][0])
    {
        $request = $this->vpnTunnelsBulkDestroyRequest($tunnel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsBulkDestroyAsync($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkDestroy'][0])
    {
        return $this->vpnTunnelsBulkDestroyAsyncWithHttpInfo($tunnel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsBulkDestroyAsyncWithHttpInfo($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnTunnelsBulkDestroyRequest($tunnel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelsBulkDestroyRequest($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkDestroy'][0])
    {

        // verify the required parameter 'tunnel_request' is set
        if ($tunnel_request === null || (is_array($tunnel_request) && count($tunnel_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tunnel_request when calling vpnTunnelsBulkDestroy'
            );
        }


        $resourcePath = '/api/vpn/tunnels/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tunnel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tunnel_request));
            } else {
                $httpBody = $tunnel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tunnel[]
     */
    public function vpnTunnelsBulkPartialUpdate($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkPartialUpdate'][0])
    {
        list($response) = $this->vpnTunnelsBulkPartialUpdateWithHttpInfo($tunnel_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tunnel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelsBulkPartialUpdateWithHttpInfo($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkPartialUpdate'][0])
    {
        $request = $this->vpnTunnelsBulkPartialUpdateRequest($tunnel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tunnel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tunnel[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tunnel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tunnel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tunnel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsBulkPartialUpdateAsync($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkPartialUpdate'][0])
    {
        return $this->vpnTunnelsBulkPartialUpdateAsyncWithHttpInfo($tunnel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsBulkPartialUpdateAsyncWithHttpInfo($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tunnel[]';
        $request = $this->vpnTunnelsBulkPartialUpdateRequest($tunnel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelsBulkPartialUpdateRequest($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'tunnel_request' is set
        if ($tunnel_request === null || (is_array($tunnel_request) && count($tunnel_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tunnel_request when calling vpnTunnelsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/vpn/tunnels/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tunnel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tunnel_request));
            } else {
                $httpBody = $tunnel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tunnel[]
     */
    public function vpnTunnelsBulkUpdate($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkUpdate'][0])
    {
        list($response) = $this->vpnTunnelsBulkUpdateWithHttpInfo($tunnel_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tunnel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelsBulkUpdateWithHttpInfo($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkUpdate'][0])
    {
        $request = $this->vpnTunnelsBulkUpdateRequest($tunnel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tunnel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tunnel[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tunnel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tunnel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tunnel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsBulkUpdateAsync($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkUpdate'][0])
    {
        return $this->vpnTunnelsBulkUpdateAsyncWithHttpInfo($tunnel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsBulkUpdateAsyncWithHttpInfo($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tunnel[]';
        $request = $this->vpnTunnelsBulkUpdateRequest($tunnel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\TunnelRequest[] $tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelsBulkUpdateRequest($tunnel_request, string $contentType = self::contentTypes['vpnTunnelsBulkUpdate'][0])
    {

        // verify the required parameter 'tunnel_request' is set
        if ($tunnel_request === null || (is_array($tunnel_request) && count($tunnel_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tunnel_request when calling vpnTunnelsBulkUpdate'
            );
        }


        $resourcePath = '/api/vpn/tunnels/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tunnel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tunnel_request));
            } else {
                $httpBody = $tunnel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelsCreate
     *
     * @param  \OpenAPI\Client\Model\WritableTunnelRequest $writable_tunnel_request writable_tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tunnel
     */
    public function vpnTunnelsCreate($writable_tunnel_request, string $contentType = self::contentTypes['vpnTunnelsCreate'][0])
    {
        list($response) = $this->vpnTunnelsCreateWithHttpInfo($writable_tunnel_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableTunnelRequest $writable_tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tunnel, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelsCreateWithHttpInfo($writable_tunnel_request, string $contentType = self::contentTypes['vpnTunnelsCreate'][0])
    {
        $request = $this->vpnTunnelsCreateRequest($writable_tunnel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Tunnel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tunnel' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tunnel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tunnel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tunnel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableTunnelRequest $writable_tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsCreateAsync($writable_tunnel_request, string $contentType = self::contentTypes['vpnTunnelsCreate'][0])
    {
        return $this->vpnTunnelsCreateAsyncWithHttpInfo($writable_tunnel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableTunnelRequest $writable_tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsCreateAsyncWithHttpInfo($writable_tunnel_request, string $contentType = self::contentTypes['vpnTunnelsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tunnel';
        $request = $this->vpnTunnelsCreateRequest($writable_tunnel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelsCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableTunnelRequest $writable_tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelsCreateRequest($writable_tunnel_request, string $contentType = self::contentTypes['vpnTunnelsCreate'][0])
    {

        // verify the required parameter 'writable_tunnel_request' is set
        if ($writable_tunnel_request === null || (is_array($writable_tunnel_request) && count($writable_tunnel_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_tunnel_request when calling vpnTunnelsCreate'
            );
        }


        $resourcePath = '/api/vpn/tunnels/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_tunnel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_tunnel_request));
            } else {
                $httpBody = $writable_tunnel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelsDestroy
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vpnTunnelsDestroy($id, string $contentType = self::contentTypes['vpnTunnelsDestroy'][0])
    {
        $this->vpnTunnelsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation vpnTunnelsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelsDestroy'][0])
    {
        $request = $this->vpnTunnelsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsDestroyAsync($id, string $contentType = self::contentTypes['vpnTunnelsDestroy'][0])
    {
        return $this->vpnTunnelsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelsDestroy'][0])
    {
        $returnType = '';
        $request = $this->vpnTunnelsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelsDestroy'
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelsDestroyRequest($id, string $contentType = self::contentTypes['vpnTunnelsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelsDestroy'
            );
        }


        $resourcePath = '/api/vpn/tunnels/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelsList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $encapsulation encapsulation (optional)
     * @param  string[] $encapsulation__n encapsulation__n (optional)
     * @param  string[] $group Tunnel group (slug) (optional)
     * @param  string[] $group__n Tunnel group (slug) (optional)
     * @param  int[] $group_id Tunnel group (ID) (optional)
     * @param  int[] $group_id__n Tunnel group (ID) (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $ipsec_profile IPSec profile (name) (optional)
     * @param  string[] $ipsec_profile__n IPSec profile (name) (optional)
     * @param  int[] $ipsec_profile_id IPSec profile (ID) (optional)
     * @param  int[] $ipsec_profile_id__n IPSec profile (ID) (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $status status (optional)
     * @param  string[] $status__n status__n (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group tenant_group (optional)
     * @param  string[] $tenant_group__n tenant_group__n (optional)
     * @param  string[] $tenant_group_id tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  int[] $tunnel_id tunnel_id (optional)
     * @param  bool $tunnel_id__empty tunnel_id__empty (optional)
     * @param  int[] $tunnel_id__gt tunnel_id__gt (optional)
     * @param  int[] $tunnel_id__gte tunnel_id__gte (optional)
     * @param  int[] $tunnel_id__lt tunnel_id__lt (optional)
     * @param  int[] $tunnel_id__lte tunnel_id__lte (optional)
     * @param  int[] $tunnel_id__n tunnel_id__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedTunnelList
     */
    public function vpnTunnelsList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encapsulation = null, $encapsulation__n = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_profile = null, $ipsec_profile__n = null, $ipsec_profile_id = null, $ipsec_profile_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $tunnel_id = null, $tunnel_id__empty = null, $tunnel_id__gt = null, $tunnel_id__gte = null, $tunnel_id__lt = null, $tunnel_id__lte = null, $tunnel_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnTunnelsList'][0])
    {
        list($response) = $this->vpnTunnelsListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encapsulation, $encapsulation__n, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_profile, $ipsec_profile__n, $ipsec_profile_id, $ipsec_profile_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $tunnel_id, $tunnel_id__empty, $tunnel_id__gt, $tunnel_id__gte, $tunnel_id__lt, $tunnel_id__lte, $tunnel_id__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelsListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encapsulation (optional)
     * @param  string[] $encapsulation__n (optional)
     * @param  string[] $group Tunnel group (slug) (optional)
     * @param  string[] $group__n Tunnel group (slug) (optional)
     * @param  int[] $group_id Tunnel group (ID) (optional)
     * @param  int[] $group_id__n Tunnel group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_profile IPSec profile (name) (optional)
     * @param  string[] $ipsec_profile__n IPSec profile (name) (optional)
     * @param  int[] $ipsec_profile_id IPSec profile (ID) (optional)
     * @param  int[] $ipsec_profile_id__n IPSec profile (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  int[] $tunnel_id (optional)
     * @param  bool $tunnel_id__empty (optional)
     * @param  int[] $tunnel_id__gt (optional)
     * @param  int[] $tunnel_id__gte (optional)
     * @param  int[] $tunnel_id__lt (optional)
     * @param  int[] $tunnel_id__lte (optional)
     * @param  int[] $tunnel_id__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedTunnelList, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelsListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encapsulation = null, $encapsulation__n = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_profile = null, $ipsec_profile__n = null, $ipsec_profile_id = null, $ipsec_profile_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $tunnel_id = null, $tunnel_id__empty = null, $tunnel_id__gt = null, $tunnel_id__gte = null, $tunnel_id__lt = null, $tunnel_id__lte = null, $tunnel_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnTunnelsList'][0])
    {
        $request = $this->vpnTunnelsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encapsulation, $encapsulation__n, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_profile, $ipsec_profile__n, $ipsec_profile_id, $ipsec_profile_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $tunnel_id, $tunnel_id__empty, $tunnel_id__gt, $tunnel_id__gte, $tunnel_id__lt, $tunnel_id__lte, $tunnel_id__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedTunnelList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedTunnelList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedTunnelList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedTunnelList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedTunnelList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelsListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encapsulation (optional)
     * @param  string[] $encapsulation__n (optional)
     * @param  string[] $group Tunnel group (slug) (optional)
     * @param  string[] $group__n Tunnel group (slug) (optional)
     * @param  int[] $group_id Tunnel group (ID) (optional)
     * @param  int[] $group_id__n Tunnel group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_profile IPSec profile (name) (optional)
     * @param  string[] $ipsec_profile__n IPSec profile (name) (optional)
     * @param  int[] $ipsec_profile_id IPSec profile (ID) (optional)
     * @param  int[] $ipsec_profile_id__n IPSec profile (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  int[] $tunnel_id (optional)
     * @param  bool $tunnel_id__empty (optional)
     * @param  int[] $tunnel_id__gt (optional)
     * @param  int[] $tunnel_id__gte (optional)
     * @param  int[] $tunnel_id__lt (optional)
     * @param  int[] $tunnel_id__lte (optional)
     * @param  int[] $tunnel_id__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encapsulation = null, $encapsulation__n = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_profile = null, $ipsec_profile__n = null, $ipsec_profile_id = null, $ipsec_profile_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $tunnel_id = null, $tunnel_id__empty = null, $tunnel_id__gt = null, $tunnel_id__gte = null, $tunnel_id__lt = null, $tunnel_id__lte = null, $tunnel_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnTunnelsList'][0])
    {
        return $this->vpnTunnelsListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encapsulation, $encapsulation__n, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_profile, $ipsec_profile__n, $ipsec_profile_id, $ipsec_profile_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $tunnel_id, $tunnel_id__empty, $tunnel_id__gt, $tunnel_id__gte, $tunnel_id__lt, $tunnel_id__lte, $tunnel_id__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelsListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encapsulation (optional)
     * @param  string[] $encapsulation__n (optional)
     * @param  string[] $group Tunnel group (slug) (optional)
     * @param  string[] $group__n Tunnel group (slug) (optional)
     * @param  int[] $group_id Tunnel group (ID) (optional)
     * @param  int[] $group_id__n Tunnel group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_profile IPSec profile (name) (optional)
     * @param  string[] $ipsec_profile__n IPSec profile (name) (optional)
     * @param  int[] $ipsec_profile_id IPSec profile (ID) (optional)
     * @param  int[] $ipsec_profile_id__n IPSec profile (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  int[] $tunnel_id (optional)
     * @param  bool $tunnel_id__empty (optional)
     * @param  int[] $tunnel_id__gt (optional)
     * @param  int[] $tunnel_id__gte (optional)
     * @param  int[] $tunnel_id__lt (optional)
     * @param  int[] $tunnel_id__lte (optional)
     * @param  int[] $tunnel_id__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encapsulation = null, $encapsulation__n = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_profile = null, $ipsec_profile__n = null, $ipsec_profile_id = null, $ipsec_profile_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $tunnel_id = null, $tunnel_id__empty = null, $tunnel_id__gt = null, $tunnel_id__gte = null, $tunnel_id__lt = null, $tunnel_id__lte = null, $tunnel_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnTunnelsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedTunnelList';
        $request = $this->vpnTunnelsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $encapsulation, $encapsulation__n, $group, $group__n, $group_id, $group_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $ipsec_profile, $ipsec_profile__n, $ipsec_profile_id, $ipsec_profile_id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $status, $status__n, $tag, $tag__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $tunnel_id, $tunnel_id__empty, $tunnel_id__gt, $tunnel_id__gte, $tunnel_id__lt, $tunnel_id__lte, $tunnel_id__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelsList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $encapsulation (optional)
     * @param  string[] $encapsulation__n (optional)
     * @param  string[] $group Tunnel group (slug) (optional)
     * @param  string[] $group__n Tunnel group (slug) (optional)
     * @param  int[] $group_id Tunnel group (ID) (optional)
     * @param  int[] $group_id__n Tunnel group (ID) (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $ipsec_profile IPSec profile (name) (optional)
     * @param  string[] $ipsec_profile__n IPSec profile (name) (optional)
     * @param  int[] $ipsec_profile_id IPSec profile (ID) (optional)
     * @param  int[] $ipsec_profile_id__n IPSec profile (ID) (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $status (optional)
     * @param  string[] $status__n (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group (optional)
     * @param  string[] $tenant_group__n (optional)
     * @param  string[] $tenant_group_id (optional)
     * @param  string[] $tenant_group_id__n (optional)
     * @param  int[] $tenant_id Tenant (ID) (optional)
     * @param  int[] $tenant_id__n Tenant (ID) (optional)
     * @param  int[] $tunnel_id (optional)
     * @param  bool $tunnel_id__empty (optional)
     * @param  int[] $tunnel_id__gt (optional)
     * @param  int[] $tunnel_id__gte (optional)
     * @param  int[] $tunnel_id__lt (optional)
     * @param  int[] $tunnel_id__lte (optional)
     * @param  int[] $tunnel_id__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelsListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $encapsulation = null, $encapsulation__n = null, $group = null, $group__n = null, $group_id = null, $group_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $ipsec_profile = null, $ipsec_profile__n = null, $ipsec_profile_id = null, $ipsec_profile_id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $status = null, $status__n = null, $tag = null, $tag__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $tunnel_id = null, $tunnel_id__empty = null, $tunnel_id__gt = null, $tunnel_id__gte = null, $tunnel_id__lt = null, $tunnel_id__lte = null, $tunnel_id__n = null, $updated_by_request = null, string $contentType = self::contentTypes['vpnTunnelsList'][0])
    {

















































































        $resourcePath = '/api/vpn/tunnels/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $encapsulation,
            'encapsulation', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $encapsulation__n,
            'encapsulation__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group,
            'group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group__n,
            'group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id,
            'group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id__n,
            'group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_profile,
            'ipsec_profile', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_profile__n,
            'ipsec_profile__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_profile_id,
            'ipsec_profile_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ipsec_profile_id__n,
            'ipsec_profile_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status__n,
            'status__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tunnel_id,
            'tunnel_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tunnel_id__empty,
            'tunnel_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tunnel_id__gt,
            'tunnel_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tunnel_id__gte,
            'tunnel_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tunnel_id__lt,
            'tunnel_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tunnel_id__lte,
            'tunnel_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tunnel_id__n,
            'tunnel_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableTunnelRequest $patched_writable_tunnel_request patched_writable_tunnel_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tunnel
     */
    public function vpnTunnelsPartialUpdate($id, $patched_writable_tunnel_request = null, string $contentType = self::contentTypes['vpnTunnelsPartialUpdate'][0])
    {
        list($response) = $this->vpnTunnelsPartialUpdateWithHttpInfo($id, $patched_writable_tunnel_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableTunnelRequest $patched_writable_tunnel_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tunnel, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelsPartialUpdateWithHttpInfo($id, $patched_writable_tunnel_request = null, string $contentType = self::contentTypes['vpnTunnelsPartialUpdate'][0])
    {
        $request = $this->vpnTunnelsPartialUpdateRequest($id, $patched_writable_tunnel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tunnel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tunnel' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tunnel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tunnel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tunnel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableTunnelRequest $patched_writable_tunnel_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsPartialUpdateAsync($id, $patched_writable_tunnel_request = null, string $contentType = self::contentTypes['vpnTunnelsPartialUpdate'][0])
    {
        return $this->vpnTunnelsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_tunnel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableTunnelRequest $patched_writable_tunnel_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_tunnel_request = null, string $contentType = self::contentTypes['vpnTunnelsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tunnel';
        $request = $this->vpnTunnelsPartialUpdateRequest($id, $patched_writable_tunnel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableTunnelRequest $patched_writable_tunnel_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelsPartialUpdateRequest($id, $patched_writable_tunnel_request = null, string $contentType = self::contentTypes['vpnTunnelsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelsPartialUpdate'
            );
        }



        $resourcePath = '/api/vpn/tunnels/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_tunnel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_tunnel_request));
            } else {
                $httpBody = $patched_writable_tunnel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelsRetrieve
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tunnel
     */
    public function vpnTunnelsRetrieve($id, string $contentType = self::contentTypes['vpnTunnelsRetrieve'][0])
    {
        list($response) = $this->vpnTunnelsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tunnel, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelsRetrieve'][0])
    {
        $request = $this->vpnTunnelsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tunnel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tunnel' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tunnel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tunnel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tunnel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsRetrieveAsync($id, string $contentType = self::contentTypes['vpnTunnelsRetrieve'][0])
    {
        return $this->vpnTunnelsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['vpnTunnelsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tunnel';
        $request = $this->vpnTunnelsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelsRetrieve'
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelsRetrieveRequest($id, string $contentType = self::contentTypes['vpnTunnelsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelsRetrieve'
            );
        }


        $resourcePath = '/api/vpn/tunnels/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vpnTunnelsUpdate
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  \OpenAPI\Client\Model\WritableTunnelRequest $writable_tunnel_request writable_tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tunnel
     */
    public function vpnTunnelsUpdate($id, $writable_tunnel_request, string $contentType = self::contentTypes['vpnTunnelsUpdate'][0])
    {
        list($response) = $this->vpnTunnelsUpdateWithHttpInfo($id, $writable_tunnel_request, $contentType);
        return $response;
    }

    /**
     * Operation vpnTunnelsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  \OpenAPI\Client\Model\WritableTunnelRequest $writable_tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tunnel, HTTP status code, HTTP response headers (array of strings)
     */
    public function vpnTunnelsUpdateWithHttpInfo($id, $writable_tunnel_request, string $contentType = self::contentTypes['vpnTunnelsUpdate'][0])
    {
        $request = $this->vpnTunnelsUpdateRequest($id, $writable_tunnel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tunnel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tunnel' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tunnel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tunnel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tunnel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vpnTunnelsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  \OpenAPI\Client\Model\WritableTunnelRequest $writable_tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsUpdateAsync($id, $writable_tunnel_request, string $contentType = self::contentTypes['vpnTunnelsUpdate'][0])
    {
        return $this->vpnTunnelsUpdateAsyncWithHttpInfo($id, $writable_tunnel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vpnTunnelsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  \OpenAPI\Client\Model\WritableTunnelRequest $writable_tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vpnTunnelsUpdateAsyncWithHttpInfo($id, $writable_tunnel_request, string $contentType = self::contentTypes['vpnTunnelsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tunnel';
        $request = $this->vpnTunnelsUpdateRequest($id, $writable_tunnel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vpnTunnelsUpdate'
     *
     * @param  int $id A unique integer value identifying this tunnel. (required)
     * @param  \OpenAPI\Client\Model\WritableTunnelRequest $writable_tunnel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vpnTunnelsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vpnTunnelsUpdateRequest($id, $writable_tunnel_request, string $contentType = self::contentTypes['vpnTunnelsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling vpnTunnelsUpdate'
            );
        }

        // verify the required parameter 'writable_tunnel_request' is set
        if ($writable_tunnel_request === null || (is_array($writable_tunnel_request) && count($writable_tunnel_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_tunnel_request when calling vpnTunnelsUpdate'
            );
        }


        $resourcePath = '/api/vpn/tunnels/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_tunnel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_tunnel_request));
            } else {
                $httpBody = $writable_tunnel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
