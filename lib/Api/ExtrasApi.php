<?php
/**
 * ExtrasApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NetBox REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0.8 (4.0)
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.8.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ExtrasApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ExtrasApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'extrasBookmarksBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasBookmarksBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasBookmarksBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasBookmarksCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasBookmarksDestroy' => [
            'application/json',
        ],
        'extrasBookmarksList' => [
            'application/json',
        ],
        'extrasBookmarksPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasBookmarksRetrieve' => [
            'application/json',
        ],
        'extrasBookmarksUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigContextsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigContextsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigContextsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigContextsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigContextsDestroy' => [
            'application/json',
        ],
        'extrasConfigContextsList' => [
            'application/json',
        ],
        'extrasConfigContextsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigContextsRetrieve' => [
            'application/json',
        ],
        'extrasConfigContextsSyncCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigContextsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigTemplatesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigTemplatesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigTemplatesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigTemplatesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigTemplatesDestroy' => [
            'application/json',
        ],
        'extrasConfigTemplatesList' => [
            'application/json',
        ],
        'extrasConfigTemplatesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigTemplatesRenderCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigTemplatesRetrieve' => [
            'application/json',
        ],
        'extrasConfigTemplatesSyncCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasConfigTemplatesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldChoiceSetsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldChoiceSetsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldChoiceSetsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldChoiceSetsChoicesRetrieve' => [
            'application/json',
        ],
        'extrasCustomFieldChoiceSetsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldChoiceSetsDestroy' => [
            'application/json',
        ],
        'extrasCustomFieldChoiceSetsList' => [
            'application/json',
        ],
        'extrasCustomFieldChoiceSetsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldChoiceSetsRetrieve' => [
            'application/json',
        ],
        'extrasCustomFieldChoiceSetsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldsDestroy' => [
            'application/json',
        ],
        'extrasCustomFieldsList' => [
            'application/json',
        ],
        'extrasCustomFieldsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomFieldsRetrieve' => [
            'application/json',
        ],
        'extrasCustomFieldsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomLinksBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomLinksBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomLinksBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomLinksCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomLinksDestroy' => [
            'application/json',
        ],
        'extrasCustomLinksList' => [
            'application/json',
        ],
        'extrasCustomLinksPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasCustomLinksRetrieve' => [
            'application/json',
        ],
        'extrasCustomLinksUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasDashboardDestroy' => [
            'application/json',
        ],
        'extrasDashboardPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasDashboardRetrieve' => [
            'application/json',
        ],
        'extrasDashboardUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasEventRulesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasEventRulesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasEventRulesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasEventRulesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasEventRulesDestroy' => [
            'application/json',
        ],
        'extrasEventRulesList' => [
            'application/json',
        ],
        'extrasEventRulesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasEventRulesRetrieve' => [
            'application/json',
        ],
        'extrasEventRulesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasExportTemplatesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasExportTemplatesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasExportTemplatesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasExportTemplatesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasExportTemplatesDestroy' => [
            'application/json',
        ],
        'extrasExportTemplatesList' => [
            'application/json',
        ],
        'extrasExportTemplatesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasExportTemplatesRetrieve' => [
            'application/json',
        ],
        'extrasExportTemplatesSyncCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasExportTemplatesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasImageAttachmentsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasImageAttachmentsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasImageAttachmentsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasImageAttachmentsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasImageAttachmentsDestroy' => [
            'application/json',
        ],
        'extrasImageAttachmentsList' => [
            'application/json',
        ],
        'extrasImageAttachmentsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasImageAttachmentsRetrieve' => [
            'application/json',
        ],
        'extrasImageAttachmentsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasJournalEntriesBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasJournalEntriesBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasJournalEntriesBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasJournalEntriesCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasJournalEntriesDestroy' => [
            'application/json',
        ],
        'extrasJournalEntriesList' => [
            'application/json',
        ],
        'extrasJournalEntriesPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasJournalEntriesRetrieve' => [
            'application/json',
        ],
        'extrasJournalEntriesUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasObjectChangesList' => [
            'application/json',
        ],
        'extrasObjectChangesRetrieve' => [
            'application/json',
        ],
        'extrasObjectTypesList' => [
            'application/json',
        ],
        'extrasObjectTypesRetrieve' => [
            'application/json',
        ],
        'extrasSavedFiltersBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasSavedFiltersBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasSavedFiltersBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasSavedFiltersCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasSavedFiltersDestroy' => [
            'application/json',
        ],
        'extrasSavedFiltersList' => [
            'application/json',
        ],
        'extrasSavedFiltersPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasSavedFiltersRetrieve' => [
            'application/json',
        ],
        'extrasSavedFiltersUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasScriptsCreate' => [
            'application/json',
        ],
        'extrasScriptsDestroy' => [
            'application/json',
        ],
        'extrasScriptsList' => [
            'application/json',
        ],
        'extrasScriptsPartialUpdate' => [
            'application/json',
        ],
        'extrasScriptsRetrieve' => [
            'application/json',
        ],
        'extrasScriptsUpdate' => [
            'application/json',
        ],
        'extrasTagsBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasTagsBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasTagsBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasTagsCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasTagsDestroy' => [
            'application/json',
        ],
        'extrasTagsList' => [
            'application/json',
        ],
        'extrasTagsPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasTagsRetrieve' => [
            'application/json',
        ],
        'extrasTagsUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasWebhooksBulkDestroy' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasWebhooksBulkPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasWebhooksBulkUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasWebhooksCreate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasWebhooksDestroy' => [
            'application/json',
        ],
        'extrasWebhooksList' => [
            'application/json',
        ],
        'extrasWebhooksPartialUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
        'extrasWebhooksRetrieve' => [
            'application/json',
        ],
        'extrasWebhooksUpdate' => [
            'application/json',
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation extrasBookmarksBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasBookmarksBulkDestroy($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkDestroy'][0])
    {
        $this->extrasBookmarksBulkDestroyWithHttpInfo($bookmark_request, $contentType);
    }

    /**
     * Operation extrasBookmarksBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasBookmarksBulkDestroyWithHttpInfo($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkDestroy'][0])
    {
        $request = $this->extrasBookmarksBulkDestroyRequest($bookmark_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasBookmarksBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksBulkDestroyAsync($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkDestroy'][0])
    {
        return $this->extrasBookmarksBulkDestroyAsyncWithHttpInfo($bookmark_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasBookmarksBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksBulkDestroyAsyncWithHttpInfo($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasBookmarksBulkDestroyRequest($bookmark_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasBookmarksBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasBookmarksBulkDestroyRequest($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkDestroy'][0])
    {

        // verify the required parameter 'bookmark_request' is set
        if ($bookmark_request === null || (is_array($bookmark_request) && count($bookmark_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bookmark_request when calling extrasBookmarksBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/bookmarks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bookmark_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bookmark_request));
            } else {
                $httpBody = $bookmark_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasBookmarksBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Bookmark[]
     */
    public function extrasBookmarksBulkPartialUpdate($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasBookmarksBulkPartialUpdateWithHttpInfo($bookmark_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasBookmarksBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Bookmark[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasBookmarksBulkPartialUpdateWithHttpInfo($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkPartialUpdate'][0])
    {
        $request = $this->extrasBookmarksBulkPartialUpdateRequest($bookmark_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Bookmark[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Bookmark[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Bookmark[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Bookmark[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Bookmark[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasBookmarksBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksBulkPartialUpdateAsync($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkPartialUpdate'][0])
    {
        return $this->extrasBookmarksBulkPartialUpdateAsyncWithHttpInfo($bookmark_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasBookmarksBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksBulkPartialUpdateAsyncWithHttpInfo($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Bookmark[]';
        $request = $this->extrasBookmarksBulkPartialUpdateRequest($bookmark_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasBookmarksBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasBookmarksBulkPartialUpdateRequest($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkPartialUpdate'][0])
    {

        // verify the required parameter 'bookmark_request' is set
        if ($bookmark_request === null || (is_array($bookmark_request) && count($bookmark_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bookmark_request when calling extrasBookmarksBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/bookmarks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bookmark_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bookmark_request));
            } else {
                $httpBody = $bookmark_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasBookmarksBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Bookmark[]
     */
    public function extrasBookmarksBulkUpdate($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkUpdate'][0])
    {
        list($response) = $this->extrasBookmarksBulkUpdateWithHttpInfo($bookmark_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasBookmarksBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Bookmark[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasBookmarksBulkUpdateWithHttpInfo($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkUpdate'][0])
    {
        $request = $this->extrasBookmarksBulkUpdateRequest($bookmark_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Bookmark[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Bookmark[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Bookmark[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Bookmark[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Bookmark[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasBookmarksBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksBulkUpdateAsync($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkUpdate'][0])
    {
        return $this->extrasBookmarksBulkUpdateAsyncWithHttpInfo($bookmark_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasBookmarksBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksBulkUpdateAsyncWithHttpInfo($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Bookmark[]';
        $request = $this->extrasBookmarksBulkUpdateRequest($bookmark_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasBookmarksBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest[] $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasBookmarksBulkUpdateRequest($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksBulkUpdate'][0])
    {

        // verify the required parameter 'bookmark_request' is set
        if ($bookmark_request === null || (is_array($bookmark_request) && count($bookmark_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bookmark_request when calling extrasBookmarksBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/bookmarks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bookmark_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bookmark_request));
            } else {
                $httpBody = $bookmark_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasBookmarksCreate
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest $bookmark_request bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Bookmark
     */
    public function extrasBookmarksCreate($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksCreate'][0])
    {
        list($response) = $this->extrasBookmarksCreateWithHttpInfo($bookmark_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasBookmarksCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Bookmark, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasBookmarksCreateWithHttpInfo($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksCreate'][0])
    {
        $request = $this->extrasBookmarksCreateRequest($bookmark_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Bookmark' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Bookmark' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Bookmark', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Bookmark';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Bookmark',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasBookmarksCreateAsync
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksCreateAsync($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksCreate'][0])
    {
        return $this->extrasBookmarksCreateAsyncWithHttpInfo($bookmark_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasBookmarksCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksCreateAsyncWithHttpInfo($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Bookmark';
        $request = $this->extrasBookmarksCreateRequest($bookmark_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasBookmarksCreate'
     *
     * @param  \OpenAPI\Client\Model\BookmarkRequest $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasBookmarksCreateRequest($bookmark_request, string $contentType = self::contentTypes['extrasBookmarksCreate'][0])
    {

        // verify the required parameter 'bookmark_request' is set
        if ($bookmark_request === null || (is_array($bookmark_request) && count($bookmark_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bookmark_request when calling extrasBookmarksCreate'
            );
        }


        $resourcePath = '/api/extras/bookmarks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bookmark_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bookmark_request));
            } else {
                $httpBody = $bookmark_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasBookmarksDestroy
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasBookmarksDestroy($id, string $contentType = self::contentTypes['extrasBookmarksDestroy'][0])
    {
        $this->extrasBookmarksDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasBookmarksDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasBookmarksDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasBookmarksDestroy'][0])
    {
        $request = $this->extrasBookmarksDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasBookmarksDestroyAsync
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksDestroyAsync($id, string $contentType = self::contentTypes['extrasBookmarksDestroy'][0])
    {
        return $this->extrasBookmarksDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasBookmarksDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasBookmarksDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasBookmarksDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasBookmarksDestroy'
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasBookmarksDestroyRequest($id, string $contentType = self::contentTypes['extrasBookmarksDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasBookmarksDestroy'
            );
        }


        $resourcePath = '/api/extras/bookmarks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasBookmarksList
     *
     * @param  \DateTime $created created (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $object_id object_id (optional)
     * @param  bool $object_id__empty object_id__empty (optional)
     * @param  int[] $object_id__gt object_id__gt (optional)
     * @param  int[] $object_id__gte object_id__gte (optional)
     * @param  int[] $object_id__lt object_id__lt (optional)
     * @param  int[] $object_id__lte object_id__lte (optional)
     * @param  int[] $object_id__n object_id__n (optional)
     * @param  string $object_type object_type (optional)
     * @param  string $object_type__n object_type__n (optional)
     * @param  int[] $object_type_id object_type_id (optional)
     * @param  int[] $object_type_id__empty object_type_id__empty (optional)
     * @param  int[] $object_type_id__gt object_type_id__gt (optional)
     * @param  int[] $object_type_id__gte object_type_id__gte (optional)
     * @param  int[] $object_type_id__lt object_type_id__lt (optional)
     * @param  int[] $object_type_id__lte object_type_id__lte (optional)
     * @param  int[] $object_type_id__n object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedBookmarkList
     */
    public function extrasBookmarksList($created = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $object_id = null, $object_id__empty = null, $object_id__gt = null, $object_id__gte = null, $object_id__lt = null, $object_id__lte = null, $object_id__n = null, $object_type = null, $object_type__n = null, $object_type_id = null, $object_type_id__empty = null, $object_type_id__gt = null, $object_type_id__gte = null, $object_type_id__lt = null, $object_type_id__lte = null, $object_type_id__n = null, $offset = null, $ordering = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['extrasBookmarksList'][0])
    {
        list($response) = $this->extrasBookmarksListWithHttpInfo($created, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $object_id, $object_id__empty, $object_id__gt, $object_id__gte, $object_id__lt, $object_id__lte, $object_id__n, $object_type, $object_type__n, $object_type_id, $object_type_id__empty, $object_type_id__gt, $object_type_id__gte, $object_type_id__lt, $object_type_id__lte, $object_type_id__n, $offset, $ordering, $user, $user__n, $user_id, $user_id__n, $contentType);
        return $response;
    }

    /**
     * Operation extrasBookmarksListWithHttpInfo
     *
     * @param  \DateTime $created (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $object_id (optional)
     * @param  bool $object_id__empty (optional)
     * @param  int[] $object_id__gt (optional)
     * @param  int[] $object_id__gte (optional)
     * @param  int[] $object_id__lt (optional)
     * @param  int[] $object_id__lte (optional)
     * @param  int[] $object_id__n (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__n (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__empty (optional)
     * @param  int[] $object_type_id__gt (optional)
     * @param  int[] $object_type_id__gte (optional)
     * @param  int[] $object_type_id__lt (optional)
     * @param  int[] $object_type_id__lte (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedBookmarkList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasBookmarksListWithHttpInfo($created = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $object_id = null, $object_id__empty = null, $object_id__gt = null, $object_id__gte = null, $object_id__lt = null, $object_id__lte = null, $object_id__n = null, $object_type = null, $object_type__n = null, $object_type_id = null, $object_type_id__empty = null, $object_type_id__gt = null, $object_type_id__gte = null, $object_type_id__lt = null, $object_type_id__lte = null, $object_type_id__n = null, $offset = null, $ordering = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['extrasBookmarksList'][0])
    {
        $request = $this->extrasBookmarksListRequest($created, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $object_id, $object_id__empty, $object_id__gt, $object_id__gte, $object_id__lt, $object_id__lte, $object_id__n, $object_type, $object_type__n, $object_type_id, $object_type_id__empty, $object_type_id__gt, $object_type_id__gte, $object_type_id__lt, $object_type_id__lte, $object_type_id__n, $offset, $ordering, $user, $user__n, $user_id, $user_id__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedBookmarkList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedBookmarkList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedBookmarkList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedBookmarkList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedBookmarkList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasBookmarksListAsync
     *
     * @param  \DateTime $created (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $object_id (optional)
     * @param  bool $object_id__empty (optional)
     * @param  int[] $object_id__gt (optional)
     * @param  int[] $object_id__gte (optional)
     * @param  int[] $object_id__lt (optional)
     * @param  int[] $object_id__lte (optional)
     * @param  int[] $object_id__n (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__n (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__empty (optional)
     * @param  int[] $object_type_id__gt (optional)
     * @param  int[] $object_type_id__gte (optional)
     * @param  int[] $object_type_id__lt (optional)
     * @param  int[] $object_type_id__lte (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksListAsync($created = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $object_id = null, $object_id__empty = null, $object_id__gt = null, $object_id__gte = null, $object_id__lt = null, $object_id__lte = null, $object_id__n = null, $object_type = null, $object_type__n = null, $object_type_id = null, $object_type_id__empty = null, $object_type_id__gt = null, $object_type_id__gte = null, $object_type_id__lt = null, $object_type_id__lte = null, $object_type_id__n = null, $offset = null, $ordering = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['extrasBookmarksList'][0])
    {
        return $this->extrasBookmarksListAsyncWithHttpInfo($created, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $object_id, $object_id__empty, $object_id__gt, $object_id__gte, $object_id__lt, $object_id__lte, $object_id__n, $object_type, $object_type__n, $object_type_id, $object_type_id__empty, $object_type_id__gt, $object_type_id__gte, $object_type_id__lt, $object_type_id__lte, $object_type_id__n, $offset, $ordering, $user, $user__n, $user_id, $user_id__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasBookmarksListAsyncWithHttpInfo
     *
     * @param  \DateTime $created (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $object_id (optional)
     * @param  bool $object_id__empty (optional)
     * @param  int[] $object_id__gt (optional)
     * @param  int[] $object_id__gte (optional)
     * @param  int[] $object_id__lt (optional)
     * @param  int[] $object_id__lte (optional)
     * @param  int[] $object_id__n (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__n (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__empty (optional)
     * @param  int[] $object_type_id__gt (optional)
     * @param  int[] $object_type_id__gte (optional)
     * @param  int[] $object_type_id__lt (optional)
     * @param  int[] $object_type_id__lte (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksListAsyncWithHttpInfo($created = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $object_id = null, $object_id__empty = null, $object_id__gt = null, $object_id__gte = null, $object_id__lt = null, $object_id__lte = null, $object_id__n = null, $object_type = null, $object_type__n = null, $object_type_id = null, $object_type_id__empty = null, $object_type_id__gt = null, $object_type_id__gte = null, $object_type_id__lt = null, $object_type_id__lte = null, $object_type_id__n = null, $offset = null, $ordering = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['extrasBookmarksList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedBookmarkList';
        $request = $this->extrasBookmarksListRequest($created, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $object_id, $object_id__empty, $object_id__gt, $object_id__gte, $object_id__lt, $object_id__lte, $object_id__n, $object_type, $object_type__n, $object_type_id, $object_type_id__empty, $object_type_id__gt, $object_type_id__gte, $object_type_id__lt, $object_type_id__lte, $object_type_id__n, $offset, $ordering, $user, $user__n, $user_id, $user_id__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasBookmarksList'
     *
     * @param  \DateTime $created (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $object_id (optional)
     * @param  bool $object_id__empty (optional)
     * @param  int[] $object_id__gt (optional)
     * @param  int[] $object_id__gte (optional)
     * @param  int[] $object_id__lt (optional)
     * @param  int[] $object_id__lte (optional)
     * @param  int[] $object_id__n (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__n (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__empty (optional)
     * @param  int[] $object_type_id__gt (optional)
     * @param  int[] $object_type_id__gte (optional)
     * @param  int[] $object_type_id__lt (optional)
     * @param  int[] $object_type_id__lte (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasBookmarksListRequest($created = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $object_id = null, $object_id__empty = null, $object_id__gt = null, $object_id__gte = null, $object_id__lt = null, $object_id__lte = null, $object_id__n = null, $object_type = null, $object_type__n = null, $object_type_id = null, $object_type_id__empty = null, $object_type_id__gt = null, $object_type_id__gte = null, $object_type_id__lt = null, $object_type_id__lte = null, $object_type_id__n = null, $offset = null, $ordering = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, string $contentType = self::contentTypes['extrasBookmarksList'][0])
    {

































        $resourcePath = '/api/extras/bookmarks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id,
            'object_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__empty,
            'object_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__gt,
            'object_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__gte,
            'object_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__lt,
            'object_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__lte,
            'object_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__n,
            'object_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type,
            'object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__n,
            'object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id,
            'object_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__empty,
            'object_type_id__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__gt,
            'object_type_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__gte,
            'object_type_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__lt,
            'object_type_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__lte,
            'object_type_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__n,
            'object_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user,
            'user', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user__n,
            'user__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'user_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id__n,
            'user_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasBookmarksPartialUpdate
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  \OpenAPI\Client\Model\PatchedBookmarkRequest $patched_bookmark_request patched_bookmark_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Bookmark
     */
    public function extrasBookmarksPartialUpdate($id, $patched_bookmark_request = null, string $contentType = self::contentTypes['extrasBookmarksPartialUpdate'][0])
    {
        list($response) = $this->extrasBookmarksPartialUpdateWithHttpInfo($id, $patched_bookmark_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasBookmarksPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  \OpenAPI\Client\Model\PatchedBookmarkRequest $patched_bookmark_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Bookmark, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasBookmarksPartialUpdateWithHttpInfo($id, $patched_bookmark_request = null, string $contentType = self::contentTypes['extrasBookmarksPartialUpdate'][0])
    {
        $request = $this->extrasBookmarksPartialUpdateRequest($id, $patched_bookmark_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Bookmark' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Bookmark' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Bookmark', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Bookmark';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Bookmark',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasBookmarksPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  \OpenAPI\Client\Model\PatchedBookmarkRequest $patched_bookmark_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksPartialUpdateAsync($id, $patched_bookmark_request = null, string $contentType = self::contentTypes['extrasBookmarksPartialUpdate'][0])
    {
        return $this->extrasBookmarksPartialUpdateAsyncWithHttpInfo($id, $patched_bookmark_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasBookmarksPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  \OpenAPI\Client\Model\PatchedBookmarkRequest $patched_bookmark_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksPartialUpdateAsyncWithHttpInfo($id, $patched_bookmark_request = null, string $contentType = self::contentTypes['extrasBookmarksPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Bookmark';
        $request = $this->extrasBookmarksPartialUpdateRequest($id, $patched_bookmark_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasBookmarksPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  \OpenAPI\Client\Model\PatchedBookmarkRequest $patched_bookmark_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasBookmarksPartialUpdateRequest($id, $patched_bookmark_request = null, string $contentType = self::contentTypes['extrasBookmarksPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasBookmarksPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/bookmarks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_bookmark_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_bookmark_request));
            } else {
                $httpBody = $patched_bookmark_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasBookmarksRetrieve
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Bookmark
     */
    public function extrasBookmarksRetrieve($id, string $contentType = self::contentTypes['extrasBookmarksRetrieve'][0])
    {
        list($response) = $this->extrasBookmarksRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasBookmarksRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Bookmark, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasBookmarksRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasBookmarksRetrieve'][0])
    {
        $request = $this->extrasBookmarksRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Bookmark' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Bookmark' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Bookmark', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Bookmark';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Bookmark',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasBookmarksRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksRetrieveAsync($id, string $contentType = self::contentTypes['extrasBookmarksRetrieve'][0])
    {
        return $this->extrasBookmarksRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasBookmarksRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasBookmarksRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Bookmark';
        $request = $this->extrasBookmarksRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasBookmarksRetrieve'
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasBookmarksRetrieveRequest($id, string $contentType = self::contentTypes['extrasBookmarksRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasBookmarksRetrieve'
            );
        }


        $resourcePath = '/api/extras/bookmarks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasBookmarksUpdate
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  \OpenAPI\Client\Model\BookmarkRequest $bookmark_request bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Bookmark
     */
    public function extrasBookmarksUpdate($id, $bookmark_request, string $contentType = self::contentTypes['extrasBookmarksUpdate'][0])
    {
        list($response) = $this->extrasBookmarksUpdateWithHttpInfo($id, $bookmark_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasBookmarksUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  \OpenAPI\Client\Model\BookmarkRequest $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Bookmark, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasBookmarksUpdateWithHttpInfo($id, $bookmark_request, string $contentType = self::contentTypes['extrasBookmarksUpdate'][0])
    {
        $request = $this->extrasBookmarksUpdateRequest($id, $bookmark_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Bookmark' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Bookmark' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Bookmark', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Bookmark';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Bookmark',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasBookmarksUpdateAsync
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  \OpenAPI\Client\Model\BookmarkRequest $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksUpdateAsync($id, $bookmark_request, string $contentType = self::contentTypes['extrasBookmarksUpdate'][0])
    {
        return $this->extrasBookmarksUpdateAsyncWithHttpInfo($id, $bookmark_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasBookmarksUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  \OpenAPI\Client\Model\BookmarkRequest $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasBookmarksUpdateAsyncWithHttpInfo($id, $bookmark_request, string $contentType = self::contentTypes['extrasBookmarksUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Bookmark';
        $request = $this->extrasBookmarksUpdateRequest($id, $bookmark_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasBookmarksUpdate'
     *
     * @param  int $id A unique integer value identifying this bookmark. (required)
     * @param  \OpenAPI\Client\Model\BookmarkRequest $bookmark_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasBookmarksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasBookmarksUpdateRequest($id, $bookmark_request, string $contentType = self::contentTypes['extrasBookmarksUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasBookmarksUpdate'
            );
        }

        // verify the required parameter 'bookmark_request' is set
        if ($bookmark_request === null || (is_array($bookmark_request) && count($bookmark_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bookmark_request when calling extrasBookmarksUpdate'
            );
        }


        $resourcePath = '/api/extras/bookmarks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bookmark_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bookmark_request));
            } else {
                $httpBody = $bookmark_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigContextsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasConfigContextsBulkDestroy($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkDestroy'][0])
    {
        $this->extrasConfigContextsBulkDestroyWithHttpInfo($config_context_request, $contentType);
    }

    /**
     * Operation extrasConfigContextsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigContextsBulkDestroyWithHttpInfo($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkDestroy'][0])
    {
        $request = $this->extrasConfigContextsBulkDestroyRequest($config_context_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigContextsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsBulkDestroyAsync($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkDestroy'][0])
    {
        return $this->extrasConfigContextsBulkDestroyAsyncWithHttpInfo($config_context_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigContextsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsBulkDestroyAsyncWithHttpInfo($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasConfigContextsBulkDestroyRequest($config_context_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigContextsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigContextsBulkDestroyRequest($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkDestroy'][0])
    {

        // verify the required parameter 'config_context_request' is set
        if ($config_context_request === null || (is_array($config_context_request) && count($config_context_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_context_request when calling extrasConfigContextsBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/config-contexts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_context_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_context_request));
            } else {
                $httpBody = $config_context_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigContextsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigContext[]
     */
    public function extrasConfigContextsBulkPartialUpdate($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasConfigContextsBulkPartialUpdateWithHttpInfo($config_context_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigContextsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigContext[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigContextsBulkPartialUpdateWithHttpInfo($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkPartialUpdate'][0])
    {
        $request = $this->extrasConfigContextsBulkPartialUpdateRequest($config_context_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigContext[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigContext[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigContext[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigContext[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigContext[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigContextsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsBulkPartialUpdateAsync($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkPartialUpdate'][0])
    {
        return $this->extrasConfigContextsBulkPartialUpdateAsyncWithHttpInfo($config_context_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigContextsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsBulkPartialUpdateAsyncWithHttpInfo($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigContext[]';
        $request = $this->extrasConfigContextsBulkPartialUpdateRequest($config_context_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigContextsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigContextsBulkPartialUpdateRequest($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'config_context_request' is set
        if ($config_context_request === null || (is_array($config_context_request) && count($config_context_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_context_request when calling extrasConfigContextsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/config-contexts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_context_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_context_request));
            } else {
                $httpBody = $config_context_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigContextsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigContext[]
     */
    public function extrasConfigContextsBulkUpdate($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkUpdate'][0])
    {
        list($response) = $this->extrasConfigContextsBulkUpdateWithHttpInfo($config_context_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigContextsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigContext[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigContextsBulkUpdateWithHttpInfo($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkUpdate'][0])
    {
        $request = $this->extrasConfigContextsBulkUpdateRequest($config_context_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigContext[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigContext[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigContext[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigContext[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigContext[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigContextsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsBulkUpdateAsync($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkUpdate'][0])
    {
        return $this->extrasConfigContextsBulkUpdateAsyncWithHttpInfo($config_context_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigContextsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsBulkUpdateAsyncWithHttpInfo($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigContext[]';
        $request = $this->extrasConfigContextsBulkUpdateRequest($config_context_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigContextsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest[] $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigContextsBulkUpdateRequest($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsBulkUpdate'][0])
    {

        // verify the required parameter 'config_context_request' is set
        if ($config_context_request === null || (is_array($config_context_request) && count($config_context_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_context_request when calling extrasConfigContextsBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/config-contexts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_context_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_context_request));
            } else {
                $httpBody = $config_context_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigContextsCreate
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigContext
     */
    public function extrasConfigContextsCreate($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsCreate'][0])
    {
        list($response) = $this->extrasConfigContextsCreateWithHttpInfo($config_context_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigContextsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigContext, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigContextsCreateWithHttpInfo($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsCreate'][0])
    {
        $request = $this->extrasConfigContextsCreateRequest($config_context_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ConfigContext' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigContext' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigContext', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigContext';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigContext',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigContextsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsCreateAsync($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsCreate'][0])
    {
        return $this->extrasConfigContextsCreateAsyncWithHttpInfo($config_context_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigContextsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsCreateAsyncWithHttpInfo($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigContext';
        $request = $this->extrasConfigContextsCreateRequest($config_context_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigContextsCreate'
     *
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigContextsCreateRequest($config_context_request, string $contentType = self::contentTypes['extrasConfigContextsCreate'][0])
    {

        // verify the required parameter 'config_context_request' is set
        if ($config_context_request === null || (is_array($config_context_request) && count($config_context_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_context_request when calling extrasConfigContextsCreate'
            );
        }


        $resourcePath = '/api/extras/config-contexts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_context_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_context_request));
            } else {
                $httpBody = $config_context_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigContextsDestroy
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasConfigContextsDestroy($id, string $contentType = self::contentTypes['extrasConfigContextsDestroy'][0])
    {
        $this->extrasConfigContextsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasConfigContextsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigContextsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasConfigContextsDestroy'][0])
    {
        $request = $this->extrasConfigContextsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigContextsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsDestroyAsync($id, string $contentType = self::contentTypes['extrasConfigContextsDestroy'][0])
    {
        return $this->extrasConfigContextsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigContextsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasConfigContextsDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasConfigContextsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigContextsDestroy'
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigContextsDestroyRequest($id, string $contentType = self::contentTypes['extrasConfigContextsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasConfigContextsDestroy'
            );
        }


        $resourcePath = '/api/extras/config-contexts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigContextsList
     *
     * @param  bool $auto_sync_enabled auto_sync_enabled (optional)
     * @param  string[] $cluster_group Cluster group (slug) (optional)
     * @param  string[] $cluster_group__n Cluster group (slug) (optional)
     * @param  int[] $cluster_group_id Cluster group (optional)
     * @param  int[] $cluster_group_id__n Cluster group (optional)
     * @param  int[] $cluster_id Cluster (optional)
     * @param  int[] $cluster_id__n Cluster (optional)
     * @param  string[] $cluster_type Cluster type (slug) (optional)
     * @param  string[] $cluster_type__n Cluster type (slug) (optional)
     * @param  int[] $cluster_type_id Cluster type (optional)
     * @param  int[] $cluster_type_id__n Cluster type (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced data_synced (optional)
     * @param  bool $data_synced__empty data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n data_synced__n (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $device_role Role (slug) (optional)
     * @param  string[] $device_role__n Role (slug) (optional)
     * @param  int[] $device_role_id Role (optional)
     * @param  int[] $device_role_id__n Role (optional)
     * @param  int[] $device_type_id Device type (optional)
     * @param  int[] $device_type_id__n Device type (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  bool $is_active is_active (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $location Location (slug) (optional)
     * @param  string[] $location__n Location (slug) (optional)
     * @param  int[] $location_id Location (optional)
     * @param  int[] $location_id__n Location (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $platform Platform (slug) (optional)
     * @param  string[] $platform__n Platform (slug) (optional)
     * @param  int[] $platform_id Platform (optional)
     * @param  int[] $platform_id__n Platform (optional)
     * @param  string $q Search (optional)
     * @param  string[] $region Region (slug) (optional)
     * @param  string[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (optional)
     * @param  int[] $region_id__n Region (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (optional)
     * @param  int[] $role_id__n Role (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  string[] $site_group Site group (slug) (optional)
     * @param  string[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (optional)
     * @param  int[] $site_group_id__n Site group (optional)
     * @param  int[] $site_id Site (optional)
     * @param  int[] $site_id__n Site (optional)
     * @param  string[] $tag Tag (slug) (optional)
     * @param  string[] $tag__n Tag (slug) (optional)
     * @param  int[] $tag_id Tag (optional)
     * @param  int[] $tag_id__n Tag (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group Tenant group (slug) (optional)
     * @param  string[] $tenant_group__n Tenant group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant group (optional)
     * @param  int[] $tenant_group_id__n Tenant group (optional)
     * @param  int[] $tenant_id Tenant (optional)
     * @param  int[] $tenant_id__n Tenant (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  int[] $weight weight (optional)
     * @param  bool $weight__empty weight__empty (optional)
     * @param  int[] $weight__gt weight__gt (optional)
     * @param  int[] $weight__gte weight__gte (optional)
     * @param  int[] $weight__lt weight__lt (optional)
     * @param  int[] $weight__lte weight__lte (optional)
     * @param  int[] $weight__n weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedConfigContextList
     */
    public function extrasConfigContextsList($auto_sync_enabled = null, $cluster_group = null, $cluster_group__n = null, $cluster_group_id = null, $cluster_group_id__n = null, $cluster_id = null, $cluster_id__n = null, $cluster_type = null, $cluster_type__n = null, $cluster_type_id = null, $cluster_type_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device_role = null, $device_role__n = null, $device_role_id = null, $device_role_id__n = null, $device_type_id = null, $device_type_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_active = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $location = null, $location__n = null, $location_id = null, $location_id__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $platform = null, $platform__n = null, $platform_id = null, $platform_id__n = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $tag_id = null, $tag_id__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasConfigContextsList'][0])
    {
        list($response) = $this->extrasConfigContextsListWithHttpInfo($auto_sync_enabled, $cluster_group, $cluster_group__n, $cluster_group_id, $cluster_group_id__n, $cluster_id, $cluster_id__n, $cluster_type, $cluster_type__n, $cluster_type_id, $cluster_type_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device_role, $device_role__n, $device_role_id, $device_role_id__n, $device_type_id, $device_type_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_active, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $location, $location__n, $location_id, $location_id__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $platform, $platform__n, $platform_id, $platform_id__n, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $tag, $tag__n, $tag_id, $tag_id__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigContextsListWithHttpInfo
     *
     * @param  bool $auto_sync_enabled (optional)
     * @param  string[] $cluster_group Cluster group (slug) (optional)
     * @param  string[] $cluster_group__n Cluster group (slug) (optional)
     * @param  int[] $cluster_group_id Cluster group (optional)
     * @param  int[] $cluster_group_id__n Cluster group (optional)
     * @param  int[] $cluster_id Cluster (optional)
     * @param  int[] $cluster_id__n Cluster (optional)
     * @param  string[] $cluster_type Cluster type (slug) (optional)
     * @param  string[] $cluster_type__n Cluster type (slug) (optional)
     * @param  int[] $cluster_type_id Cluster type (optional)
     * @param  int[] $cluster_type_id__n Cluster type (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device_role Role (slug) (optional)
     * @param  string[] $device_role__n Role (slug) (optional)
     * @param  int[] $device_role_id Role (optional)
     * @param  int[] $device_role_id__n Role (optional)
     * @param  int[] $device_type_id Device type (optional)
     * @param  int[] $device_type_id__n Device type (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_active (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $location Location (slug) (optional)
     * @param  string[] $location__n Location (slug) (optional)
     * @param  int[] $location_id Location (optional)
     * @param  int[] $location_id__n Location (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $platform Platform (slug) (optional)
     * @param  string[] $platform__n Platform (slug) (optional)
     * @param  int[] $platform_id Platform (optional)
     * @param  int[] $platform_id__n Platform (optional)
     * @param  string $q Search (optional)
     * @param  string[] $region Region (slug) (optional)
     * @param  string[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (optional)
     * @param  int[] $region_id__n Region (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (optional)
     * @param  int[] $role_id__n Role (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  string[] $site_group Site group (slug) (optional)
     * @param  string[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (optional)
     * @param  int[] $site_group_id__n Site group (optional)
     * @param  int[] $site_id Site (optional)
     * @param  int[] $site_id__n Site (optional)
     * @param  string[] $tag Tag (slug) (optional)
     * @param  string[] $tag__n Tag (slug) (optional)
     * @param  int[] $tag_id Tag (optional)
     * @param  int[] $tag_id__n Tag (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group Tenant group (slug) (optional)
     * @param  string[] $tenant_group__n Tenant group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant group (optional)
     * @param  int[] $tenant_group_id__n Tenant group (optional)
     * @param  int[] $tenant_id Tenant (optional)
     * @param  int[] $tenant_id__n Tenant (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedConfigContextList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigContextsListWithHttpInfo($auto_sync_enabled = null, $cluster_group = null, $cluster_group__n = null, $cluster_group_id = null, $cluster_group_id__n = null, $cluster_id = null, $cluster_id__n = null, $cluster_type = null, $cluster_type__n = null, $cluster_type_id = null, $cluster_type_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device_role = null, $device_role__n = null, $device_role_id = null, $device_role_id__n = null, $device_type_id = null, $device_type_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_active = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $location = null, $location__n = null, $location_id = null, $location_id__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $platform = null, $platform__n = null, $platform_id = null, $platform_id__n = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $tag_id = null, $tag_id__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasConfigContextsList'][0])
    {
        $request = $this->extrasConfigContextsListRequest($auto_sync_enabled, $cluster_group, $cluster_group__n, $cluster_group_id, $cluster_group_id__n, $cluster_id, $cluster_id__n, $cluster_type, $cluster_type__n, $cluster_type_id, $cluster_type_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device_role, $device_role__n, $device_role_id, $device_role_id__n, $device_type_id, $device_type_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_active, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $location, $location__n, $location_id, $location_id__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $platform, $platform__n, $platform_id, $platform_id__n, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $tag, $tag__n, $tag_id, $tag_id__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedConfigContextList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedConfigContextList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedConfigContextList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedConfigContextList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedConfigContextList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigContextsListAsync
     *
     * @param  bool $auto_sync_enabled (optional)
     * @param  string[] $cluster_group Cluster group (slug) (optional)
     * @param  string[] $cluster_group__n Cluster group (slug) (optional)
     * @param  int[] $cluster_group_id Cluster group (optional)
     * @param  int[] $cluster_group_id__n Cluster group (optional)
     * @param  int[] $cluster_id Cluster (optional)
     * @param  int[] $cluster_id__n Cluster (optional)
     * @param  string[] $cluster_type Cluster type (slug) (optional)
     * @param  string[] $cluster_type__n Cluster type (slug) (optional)
     * @param  int[] $cluster_type_id Cluster type (optional)
     * @param  int[] $cluster_type_id__n Cluster type (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device_role Role (slug) (optional)
     * @param  string[] $device_role__n Role (slug) (optional)
     * @param  int[] $device_role_id Role (optional)
     * @param  int[] $device_role_id__n Role (optional)
     * @param  int[] $device_type_id Device type (optional)
     * @param  int[] $device_type_id__n Device type (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_active (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $location Location (slug) (optional)
     * @param  string[] $location__n Location (slug) (optional)
     * @param  int[] $location_id Location (optional)
     * @param  int[] $location_id__n Location (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $platform Platform (slug) (optional)
     * @param  string[] $platform__n Platform (slug) (optional)
     * @param  int[] $platform_id Platform (optional)
     * @param  int[] $platform_id__n Platform (optional)
     * @param  string $q Search (optional)
     * @param  string[] $region Region (slug) (optional)
     * @param  string[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (optional)
     * @param  int[] $region_id__n Region (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (optional)
     * @param  int[] $role_id__n Role (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  string[] $site_group Site group (slug) (optional)
     * @param  string[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (optional)
     * @param  int[] $site_group_id__n Site group (optional)
     * @param  int[] $site_id Site (optional)
     * @param  int[] $site_id__n Site (optional)
     * @param  string[] $tag Tag (slug) (optional)
     * @param  string[] $tag__n Tag (slug) (optional)
     * @param  int[] $tag_id Tag (optional)
     * @param  int[] $tag_id__n Tag (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group Tenant group (slug) (optional)
     * @param  string[] $tenant_group__n Tenant group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant group (optional)
     * @param  int[] $tenant_group_id__n Tenant group (optional)
     * @param  int[] $tenant_id Tenant (optional)
     * @param  int[] $tenant_id__n Tenant (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsListAsync($auto_sync_enabled = null, $cluster_group = null, $cluster_group__n = null, $cluster_group_id = null, $cluster_group_id__n = null, $cluster_id = null, $cluster_id__n = null, $cluster_type = null, $cluster_type__n = null, $cluster_type_id = null, $cluster_type_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device_role = null, $device_role__n = null, $device_role_id = null, $device_role_id__n = null, $device_type_id = null, $device_type_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_active = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $location = null, $location__n = null, $location_id = null, $location_id__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $platform = null, $platform__n = null, $platform_id = null, $platform_id__n = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $tag_id = null, $tag_id__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasConfigContextsList'][0])
    {
        return $this->extrasConfigContextsListAsyncWithHttpInfo($auto_sync_enabled, $cluster_group, $cluster_group__n, $cluster_group_id, $cluster_group_id__n, $cluster_id, $cluster_id__n, $cluster_type, $cluster_type__n, $cluster_type_id, $cluster_type_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device_role, $device_role__n, $device_role_id, $device_role_id__n, $device_type_id, $device_type_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_active, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $location, $location__n, $location_id, $location_id__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $platform, $platform__n, $platform_id, $platform_id__n, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $tag, $tag__n, $tag_id, $tag_id__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigContextsListAsyncWithHttpInfo
     *
     * @param  bool $auto_sync_enabled (optional)
     * @param  string[] $cluster_group Cluster group (slug) (optional)
     * @param  string[] $cluster_group__n Cluster group (slug) (optional)
     * @param  int[] $cluster_group_id Cluster group (optional)
     * @param  int[] $cluster_group_id__n Cluster group (optional)
     * @param  int[] $cluster_id Cluster (optional)
     * @param  int[] $cluster_id__n Cluster (optional)
     * @param  string[] $cluster_type Cluster type (slug) (optional)
     * @param  string[] $cluster_type__n Cluster type (slug) (optional)
     * @param  int[] $cluster_type_id Cluster type (optional)
     * @param  int[] $cluster_type_id__n Cluster type (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device_role Role (slug) (optional)
     * @param  string[] $device_role__n Role (slug) (optional)
     * @param  int[] $device_role_id Role (optional)
     * @param  int[] $device_role_id__n Role (optional)
     * @param  int[] $device_type_id Device type (optional)
     * @param  int[] $device_type_id__n Device type (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_active (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $location Location (slug) (optional)
     * @param  string[] $location__n Location (slug) (optional)
     * @param  int[] $location_id Location (optional)
     * @param  int[] $location_id__n Location (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $platform Platform (slug) (optional)
     * @param  string[] $platform__n Platform (slug) (optional)
     * @param  int[] $platform_id Platform (optional)
     * @param  int[] $platform_id__n Platform (optional)
     * @param  string $q Search (optional)
     * @param  string[] $region Region (slug) (optional)
     * @param  string[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (optional)
     * @param  int[] $region_id__n Region (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (optional)
     * @param  int[] $role_id__n Role (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  string[] $site_group Site group (slug) (optional)
     * @param  string[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (optional)
     * @param  int[] $site_group_id__n Site group (optional)
     * @param  int[] $site_id Site (optional)
     * @param  int[] $site_id__n Site (optional)
     * @param  string[] $tag Tag (slug) (optional)
     * @param  string[] $tag__n Tag (slug) (optional)
     * @param  int[] $tag_id Tag (optional)
     * @param  int[] $tag_id__n Tag (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group Tenant group (slug) (optional)
     * @param  string[] $tenant_group__n Tenant group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant group (optional)
     * @param  int[] $tenant_group_id__n Tenant group (optional)
     * @param  int[] $tenant_id Tenant (optional)
     * @param  int[] $tenant_id__n Tenant (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsListAsyncWithHttpInfo($auto_sync_enabled = null, $cluster_group = null, $cluster_group__n = null, $cluster_group_id = null, $cluster_group_id__n = null, $cluster_id = null, $cluster_id__n = null, $cluster_type = null, $cluster_type__n = null, $cluster_type_id = null, $cluster_type_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device_role = null, $device_role__n = null, $device_role_id = null, $device_role_id__n = null, $device_type_id = null, $device_type_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_active = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $location = null, $location__n = null, $location_id = null, $location_id__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $platform = null, $platform__n = null, $platform_id = null, $platform_id__n = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $tag_id = null, $tag_id__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasConfigContextsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedConfigContextList';
        $request = $this->extrasConfigContextsListRequest($auto_sync_enabled, $cluster_group, $cluster_group__n, $cluster_group_id, $cluster_group_id__n, $cluster_id, $cluster_id__n, $cluster_type, $cluster_type__n, $cluster_type_id, $cluster_type_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $device_role, $device_role__n, $device_role_id, $device_role_id__n, $device_type_id, $device_type_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_active, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $location, $location__n, $location_id, $location_id__n, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $platform, $platform__n, $platform_id, $platform_id__n, $q, $region, $region__n, $region_id, $region_id__n, $role, $role__n, $role_id, $role_id__n, $site, $site__n, $site_group, $site_group__n, $site_group_id, $site_group_id__n, $site_id, $site_id__n, $tag, $tag__n, $tag_id, $tag_id__n, $tenant, $tenant__n, $tenant_group, $tenant_group__n, $tenant_group_id, $tenant_group_id__n, $tenant_id, $tenant_id__n, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigContextsList'
     *
     * @param  bool $auto_sync_enabled (optional)
     * @param  string[] $cluster_group Cluster group (slug) (optional)
     * @param  string[] $cluster_group__n Cluster group (slug) (optional)
     * @param  int[] $cluster_group_id Cluster group (optional)
     * @param  int[] $cluster_group_id__n Cluster group (optional)
     * @param  int[] $cluster_id Cluster (optional)
     * @param  int[] $cluster_id__n Cluster (optional)
     * @param  string[] $cluster_type Cluster type (slug) (optional)
     * @param  string[] $cluster_type__n Cluster type (slug) (optional)
     * @param  int[] $cluster_type_id Cluster type (optional)
     * @param  int[] $cluster_type_id__n Cluster type (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $device_role Role (slug) (optional)
     * @param  string[] $device_role__n Role (slug) (optional)
     * @param  int[] $device_role_id Role (optional)
     * @param  int[] $device_role_id__n Role (optional)
     * @param  int[] $device_type_id Device type (optional)
     * @param  int[] $device_type_id__n Device type (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_active (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $location Location (slug) (optional)
     * @param  string[] $location__n Location (slug) (optional)
     * @param  int[] $location_id Location (optional)
     * @param  int[] $location_id__n Location (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $platform Platform (slug) (optional)
     * @param  string[] $platform__n Platform (slug) (optional)
     * @param  int[] $platform_id Platform (optional)
     * @param  int[] $platform_id__n Platform (optional)
     * @param  string $q Search (optional)
     * @param  string[] $region Region (slug) (optional)
     * @param  string[] $region__n Region (slug) (optional)
     * @param  int[] $region_id Region (optional)
     * @param  int[] $region_id__n Region (optional)
     * @param  string[] $role Role (slug) (optional)
     * @param  string[] $role__n Role (slug) (optional)
     * @param  int[] $role_id Role (optional)
     * @param  int[] $role_id__n Role (optional)
     * @param  string[] $site Site (slug) (optional)
     * @param  string[] $site__n Site (slug) (optional)
     * @param  string[] $site_group Site group (slug) (optional)
     * @param  string[] $site_group__n Site group (slug) (optional)
     * @param  int[] $site_group_id Site group (optional)
     * @param  int[] $site_group_id__n Site group (optional)
     * @param  int[] $site_id Site (optional)
     * @param  int[] $site_id__n Site (optional)
     * @param  string[] $tag Tag (slug) (optional)
     * @param  string[] $tag__n Tag (slug) (optional)
     * @param  int[] $tag_id Tag (optional)
     * @param  int[] $tag_id__n Tag (optional)
     * @param  string[] $tenant Tenant (slug) (optional)
     * @param  string[] $tenant__n Tenant (slug) (optional)
     * @param  string[] $tenant_group Tenant group (slug) (optional)
     * @param  string[] $tenant_group__n Tenant group (slug) (optional)
     * @param  int[] $tenant_group_id Tenant group (optional)
     * @param  int[] $tenant_group_id__n Tenant group (optional)
     * @param  int[] $tenant_id Tenant (optional)
     * @param  int[] $tenant_id__n Tenant (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigContextsListRequest($auto_sync_enabled = null, $cluster_group = null, $cluster_group__n = null, $cluster_group_id = null, $cluster_group_id__n = null, $cluster_id = null, $cluster_id__n = null, $cluster_type = null, $cluster_type__n = null, $cluster_type_id = null, $cluster_type_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $device_role = null, $device_role__n = null, $device_role_id = null, $device_role_id__n = null, $device_type_id = null, $device_type_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_active = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $location = null, $location__n = null, $location_id = null, $location_id__n = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $platform = null, $platform__n = null, $platform_id = null, $platform_id__n = null, $q = null, $region = null, $region__n = null, $region_id = null, $region_id__n = null, $role = null, $role__n = null, $role_id = null, $role_id__n = null, $site = null, $site__n = null, $site_group = null, $site_group__n = null, $site_group_id = null, $site_group_id__n = null, $site_id = null, $site_id__n = null, $tag = null, $tag__n = null, $tag_id = null, $tag_id__n = null, $tenant = null, $tenant__n = null, $tenant_group = null, $tenant_group__n = null, $tenant_group_id = null, $tenant_group_id__n = null, $tenant_id = null, $tenant_id__n = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasConfigContextsList'][0])
    {




























































































































        $resourcePath = '/api/extras/config-contexts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auto_sync_enabled,
            'auto_sync_enabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_group,
            'cluster_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_group__n,
            'cluster_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_group_id,
            'cluster_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_group_id__n,
            'cluster_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_id,
            'cluster_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_id__n,
            'cluster_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_type,
            'cluster_type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_type__n,
            'cluster_type__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_type_id,
            'cluster_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_type_id__n,
            'cluster_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_file_id,
            'data_file_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_file_id__n,
            'data_file_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_source_id,
            'data_source_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_source_id__n,
            'data_source_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced,
            'data_synced', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__empty,
            'data_synced__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__gt,
            'data_synced__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__gte,
            'data_synced__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__lt,
            'data_synced__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__lte,
            'data_synced__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__n,
            'data_synced__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_role,
            'device_role', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_role__n,
            'device_role__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_role_id,
            'device_role_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_role_id__n,
            'device_role_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_type_id,
            'device_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_type_id__n,
            'device_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_active,
            'is_active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $location,
            'location', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $location__n,
            'location__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $location_id,
            'location_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $location_id__n,
            'location_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform,
            'platform', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform__n,
            'platform__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform_id,
            'platform_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform_id__n,
            'platform_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region,
            'region', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region__n,
            'region__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region_id,
            'region_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region_id__n,
            'region_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role,
            'role', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role__n,
            'role__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role_id,
            'role_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role_id__n,
            'role_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site,
            'site', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site__n,
            'site__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group,
            'site_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group__n,
            'site_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group_id,
            'site_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_group_id__n,
            'site_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id,
            'site_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id__n,
            'site_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag_id,
            'tag_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag_id__n,
            'tag_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant,
            'tenant', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant__n,
            'tenant__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group,
            'tenant_group', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group__n,
            'tenant_group__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id,
            'tenant_group_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_group_id__n,
            'tenant_group_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenant_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id__n,
            'tenant_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight,
            'weight', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__empty,
            'weight__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__gt,
            'weight__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__gte,
            'weight__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__lt,
            'weight__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__lte,
            'weight__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__n,
            'weight__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigContextsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\PatchedConfigContextRequest $patched_config_context_request patched_config_context_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigContext
     */
    public function extrasConfigContextsPartialUpdate($id, $patched_config_context_request = null, string $contentType = self::contentTypes['extrasConfigContextsPartialUpdate'][0])
    {
        list($response) = $this->extrasConfigContextsPartialUpdateWithHttpInfo($id, $patched_config_context_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigContextsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\PatchedConfigContextRequest $patched_config_context_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigContext, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigContextsPartialUpdateWithHttpInfo($id, $patched_config_context_request = null, string $contentType = self::contentTypes['extrasConfigContextsPartialUpdate'][0])
    {
        $request = $this->extrasConfigContextsPartialUpdateRequest($id, $patched_config_context_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigContext' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigContext' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigContext', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigContext';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigContext',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigContextsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\PatchedConfigContextRequest $patched_config_context_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsPartialUpdateAsync($id, $patched_config_context_request = null, string $contentType = self::contentTypes['extrasConfigContextsPartialUpdate'][0])
    {
        return $this->extrasConfigContextsPartialUpdateAsyncWithHttpInfo($id, $patched_config_context_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigContextsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\PatchedConfigContextRequest $patched_config_context_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsPartialUpdateAsyncWithHttpInfo($id, $patched_config_context_request = null, string $contentType = self::contentTypes['extrasConfigContextsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigContext';
        $request = $this->extrasConfigContextsPartialUpdateRequest($id, $patched_config_context_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigContextsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\PatchedConfigContextRequest $patched_config_context_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigContextsPartialUpdateRequest($id, $patched_config_context_request = null, string $contentType = self::contentTypes['extrasConfigContextsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasConfigContextsPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/config-contexts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_config_context_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_config_context_request));
            } else {
                $httpBody = $patched_config_context_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigContextsRetrieve
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigContext
     */
    public function extrasConfigContextsRetrieve($id, string $contentType = self::contentTypes['extrasConfigContextsRetrieve'][0])
    {
        list($response) = $this->extrasConfigContextsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigContextsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigContext, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigContextsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasConfigContextsRetrieve'][0])
    {
        $request = $this->extrasConfigContextsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigContext' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigContext' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigContext', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigContext';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigContext',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigContextsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsRetrieveAsync($id, string $contentType = self::contentTypes['extrasConfigContextsRetrieve'][0])
    {
        return $this->extrasConfigContextsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigContextsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasConfigContextsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigContext';
        $request = $this->extrasConfigContextsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigContextsRetrieve'
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigContextsRetrieveRequest($id, string $contentType = self::contentTypes['extrasConfigContextsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasConfigContextsRetrieve'
            );
        }


        $resourcePath = '/api/extras/config-contexts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigContextsSyncCreate
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsSyncCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigContext
     */
    public function extrasConfigContextsSyncCreate($id, $config_context_request, string $contentType = self::contentTypes['extrasConfigContextsSyncCreate'][0])
    {
        list($response) = $this->extrasConfigContextsSyncCreateWithHttpInfo($id, $config_context_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigContextsSyncCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsSyncCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigContext, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigContextsSyncCreateWithHttpInfo($id, $config_context_request, string $contentType = self::contentTypes['extrasConfigContextsSyncCreate'][0])
    {
        $request = $this->extrasConfigContextsSyncCreateRequest($id, $config_context_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigContext' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigContext' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigContext', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigContext';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigContext',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigContextsSyncCreateAsync
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsSyncCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsSyncCreateAsync($id, $config_context_request, string $contentType = self::contentTypes['extrasConfigContextsSyncCreate'][0])
    {
        return $this->extrasConfigContextsSyncCreateAsyncWithHttpInfo($id, $config_context_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigContextsSyncCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsSyncCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsSyncCreateAsyncWithHttpInfo($id, $config_context_request, string $contentType = self::contentTypes['extrasConfigContextsSyncCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigContext';
        $request = $this->extrasConfigContextsSyncCreateRequest($id, $config_context_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigContextsSyncCreate'
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsSyncCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigContextsSyncCreateRequest($id, $config_context_request, string $contentType = self::contentTypes['extrasConfigContextsSyncCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasConfigContextsSyncCreate'
            );
        }

        // verify the required parameter 'config_context_request' is set
        if ($config_context_request === null || (is_array($config_context_request) && count($config_context_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_context_request when calling extrasConfigContextsSyncCreate'
            );
        }


        $resourcePath = '/api/extras/config-contexts/{id}/sync/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_context_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_context_request));
            } else {
                $httpBody = $config_context_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigContextsUpdate
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigContext
     */
    public function extrasConfigContextsUpdate($id, $config_context_request, string $contentType = self::contentTypes['extrasConfigContextsUpdate'][0])
    {
        list($response) = $this->extrasConfigContextsUpdateWithHttpInfo($id, $config_context_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigContextsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigContext, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigContextsUpdateWithHttpInfo($id, $config_context_request, string $contentType = self::contentTypes['extrasConfigContextsUpdate'][0])
    {
        $request = $this->extrasConfigContextsUpdateRequest($id, $config_context_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigContext' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigContext' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigContext', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigContext';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigContext',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigContextsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsUpdateAsync($id, $config_context_request, string $contentType = self::contentTypes['extrasConfigContextsUpdate'][0])
    {
        return $this->extrasConfigContextsUpdateAsyncWithHttpInfo($id, $config_context_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigContextsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigContextsUpdateAsyncWithHttpInfo($id, $config_context_request, string $contentType = self::contentTypes['extrasConfigContextsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigContext';
        $request = $this->extrasConfigContextsUpdateRequest($id, $config_context_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigContextsUpdate'
     *
     * @param  int $id A unique integer value identifying this config context. (required)
     * @param  \OpenAPI\Client\Model\ConfigContextRequest $config_context_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigContextsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigContextsUpdateRequest($id, $config_context_request, string $contentType = self::contentTypes['extrasConfigContextsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasConfigContextsUpdate'
            );
        }

        // verify the required parameter 'config_context_request' is set
        if ($config_context_request === null || (is_array($config_context_request) && count($config_context_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_context_request when calling extrasConfigContextsUpdate'
            );
        }


        $resourcePath = '/api/extras/config-contexts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_context_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_context_request));
            } else {
                $httpBody = $config_context_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigTemplatesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasConfigTemplatesBulkDestroy($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkDestroy'][0])
    {
        $this->extrasConfigTemplatesBulkDestroyWithHttpInfo($config_template_request, $contentType);
    }

    /**
     * Operation extrasConfigTemplatesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigTemplatesBulkDestroyWithHttpInfo($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkDestroy'][0])
    {
        $request = $this->extrasConfigTemplatesBulkDestroyRequest($config_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigTemplatesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesBulkDestroyAsync($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkDestroy'][0])
    {
        return $this->extrasConfigTemplatesBulkDestroyAsyncWithHttpInfo($config_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigTemplatesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesBulkDestroyAsyncWithHttpInfo($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasConfigTemplatesBulkDestroyRequest($config_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigTemplatesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigTemplatesBulkDestroyRequest($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkDestroy'][0])
    {

        // verify the required parameter 'config_template_request' is set
        if ($config_template_request === null || (is_array($config_template_request) && count($config_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_template_request when calling extrasConfigTemplatesBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/config-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_template_request));
            } else {
                $httpBody = $config_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigTemplatesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigTemplate[]
     */
    public function extrasConfigTemplatesBulkPartialUpdate($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasConfigTemplatesBulkPartialUpdateWithHttpInfo($config_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigTemplatesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigTemplate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigTemplatesBulkPartialUpdateWithHttpInfo($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkPartialUpdate'][0])
    {
        $request = $this->extrasConfigTemplatesBulkPartialUpdateRequest($config_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigTemplate[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigTemplate[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigTemplate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigTemplate[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigTemplate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigTemplatesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesBulkPartialUpdateAsync($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkPartialUpdate'][0])
    {
        return $this->extrasConfigTemplatesBulkPartialUpdateAsyncWithHttpInfo($config_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigTemplatesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesBulkPartialUpdateAsyncWithHttpInfo($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigTemplate[]';
        $request = $this->extrasConfigTemplatesBulkPartialUpdateRequest($config_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigTemplatesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigTemplatesBulkPartialUpdateRequest($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'config_template_request' is set
        if ($config_template_request === null || (is_array($config_template_request) && count($config_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_template_request when calling extrasConfigTemplatesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/config-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_template_request));
            } else {
                $httpBody = $config_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigTemplatesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigTemplate[]
     */
    public function extrasConfigTemplatesBulkUpdate($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkUpdate'][0])
    {
        list($response) = $this->extrasConfigTemplatesBulkUpdateWithHttpInfo($config_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigTemplatesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigTemplate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigTemplatesBulkUpdateWithHttpInfo($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkUpdate'][0])
    {
        $request = $this->extrasConfigTemplatesBulkUpdateRequest($config_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigTemplate[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigTemplate[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigTemplate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigTemplate[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigTemplate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigTemplatesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesBulkUpdateAsync($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkUpdate'][0])
    {
        return $this->extrasConfigTemplatesBulkUpdateAsyncWithHttpInfo($config_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigTemplatesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesBulkUpdateAsyncWithHttpInfo($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigTemplate[]';
        $request = $this->extrasConfigTemplatesBulkUpdateRequest($config_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigTemplatesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest[] $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigTemplatesBulkUpdateRequest($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesBulkUpdate'][0])
    {

        // verify the required parameter 'config_template_request' is set
        if ($config_template_request === null || (is_array($config_template_request) && count($config_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_template_request when calling extrasConfigTemplatesBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/config-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_template_request));
            } else {
                $httpBody = $config_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigTemplatesCreate
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigTemplate
     */
    public function extrasConfigTemplatesCreate($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesCreate'][0])
    {
        list($response) = $this->extrasConfigTemplatesCreateWithHttpInfo($config_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigTemplatesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigTemplatesCreateWithHttpInfo($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesCreate'][0])
    {
        $request = $this->extrasConfigTemplatesCreateRequest($config_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ConfigTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigTemplatesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesCreateAsync($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesCreate'][0])
    {
        return $this->extrasConfigTemplatesCreateAsyncWithHttpInfo($config_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigTemplatesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesCreateAsyncWithHttpInfo($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
        $request = $this->extrasConfigTemplatesCreateRequest($config_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigTemplatesCreate'
     *
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigTemplatesCreateRequest($config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesCreate'][0])
    {

        // verify the required parameter 'config_template_request' is set
        if ($config_template_request === null || (is_array($config_template_request) && count($config_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_template_request when calling extrasConfigTemplatesCreate'
            );
        }


        $resourcePath = '/api/extras/config-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_template_request));
            } else {
                $httpBody = $config_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigTemplatesDestroy
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasConfigTemplatesDestroy($id, string $contentType = self::contentTypes['extrasConfigTemplatesDestroy'][0])
    {
        $this->extrasConfigTemplatesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasConfigTemplatesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigTemplatesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasConfigTemplatesDestroy'][0])
    {
        $request = $this->extrasConfigTemplatesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigTemplatesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesDestroyAsync($id, string $contentType = self::contentTypes['extrasConfigTemplatesDestroy'][0])
    {
        return $this->extrasConfigTemplatesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigTemplatesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasConfigTemplatesDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasConfigTemplatesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigTemplatesDestroy'
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigTemplatesDestroyRequest($id, string $contentType = self::contentTypes['extrasConfigTemplatesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasConfigTemplatesDestroy'
            );
        }


        $resourcePath = '/api/extras/config-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigTemplatesList
     *
     * @param  bool $auto_sync_enabled auto_sync_enabled (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced data_synced (optional)
     * @param  bool $data_synced__empty data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n data_synced__n (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedConfigTemplateList
     */
    public function extrasConfigTemplatesList($auto_sync_enabled = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasConfigTemplatesList'][0])
    {
        list($response) = $this->extrasConfigTemplatesListWithHttpInfo($auto_sync_enabled, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigTemplatesListWithHttpInfo
     *
     * @param  bool $auto_sync_enabled (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedConfigTemplateList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigTemplatesListWithHttpInfo($auto_sync_enabled = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasConfigTemplatesList'][0])
    {
        $request = $this->extrasConfigTemplatesListRequest($auto_sync_enabled, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedConfigTemplateList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedConfigTemplateList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedConfigTemplateList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedConfigTemplateList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedConfigTemplateList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigTemplatesListAsync
     *
     * @param  bool $auto_sync_enabled (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesListAsync($auto_sync_enabled = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasConfigTemplatesList'][0])
    {
        return $this->extrasConfigTemplatesListAsyncWithHttpInfo($auto_sync_enabled, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigTemplatesListAsyncWithHttpInfo
     *
     * @param  bool $auto_sync_enabled (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesListAsyncWithHttpInfo($auto_sync_enabled = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasConfigTemplatesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedConfigTemplateList';
        $request = $this->extrasConfigTemplatesListRequest($auto_sync_enabled, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigTemplatesList'
     *
     * @param  bool $auto_sync_enabled (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigTemplatesListRequest($auto_sync_enabled = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasConfigTemplatesList'][0])
    {


































































        $resourcePath = '/api/extras/config-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auto_sync_enabled,
            'auto_sync_enabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_file_id,
            'data_file_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_file_id__n,
            'data_file_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_source_id,
            'data_source_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_source_id__n,
            'data_source_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced,
            'data_synced', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__empty,
            'data_synced__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__gt,
            'data_synced__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__gte,
            'data_synced__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__lt,
            'data_synced__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__lte,
            'data_synced__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__n,
            'data_synced__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigTemplatesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\PatchedConfigTemplateRequest $patched_config_template_request patched_config_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigTemplate
     */
    public function extrasConfigTemplatesPartialUpdate($id, $patched_config_template_request = null, string $contentType = self::contentTypes['extrasConfigTemplatesPartialUpdate'][0])
    {
        list($response) = $this->extrasConfigTemplatesPartialUpdateWithHttpInfo($id, $patched_config_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigTemplatesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\PatchedConfigTemplateRequest $patched_config_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigTemplatesPartialUpdateWithHttpInfo($id, $patched_config_template_request = null, string $contentType = self::contentTypes['extrasConfigTemplatesPartialUpdate'][0])
    {
        $request = $this->extrasConfigTemplatesPartialUpdateRequest($id, $patched_config_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigTemplatesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\PatchedConfigTemplateRequest $patched_config_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesPartialUpdateAsync($id, $patched_config_template_request = null, string $contentType = self::contentTypes['extrasConfigTemplatesPartialUpdate'][0])
    {
        return $this->extrasConfigTemplatesPartialUpdateAsyncWithHttpInfo($id, $patched_config_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigTemplatesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\PatchedConfigTemplateRequest $patched_config_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesPartialUpdateAsyncWithHttpInfo($id, $patched_config_template_request = null, string $contentType = self::contentTypes['extrasConfigTemplatesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
        $request = $this->extrasConfigTemplatesPartialUpdateRequest($id, $patched_config_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigTemplatesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\PatchedConfigTemplateRequest $patched_config_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigTemplatesPartialUpdateRequest($id, $patched_config_template_request = null, string $contentType = self::contentTypes['extrasConfigTemplatesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasConfigTemplatesPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/config-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_config_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_config_template_request));
            } else {
                $httpBody = $patched_config_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigTemplatesRenderCreate
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request config_template_request (required)
     * @param  string $format format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesRenderCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigTemplate
     */
    public function extrasConfigTemplatesRenderCreate($id, $config_template_request, $format = null, string $contentType = self::contentTypes['extrasConfigTemplatesRenderCreate'][0])
    {
        list($response) = $this->extrasConfigTemplatesRenderCreateWithHttpInfo($id, $config_template_request, $format, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigTemplatesRenderCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesRenderCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigTemplatesRenderCreateWithHttpInfo($id, $config_template_request, $format = null, string $contentType = self::contentTypes['extrasConfigTemplatesRenderCreate'][0])
    {
        $request = $this->extrasConfigTemplatesRenderCreateRequest($id, $config_template_request, $format, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigTemplatesRenderCreateAsync
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesRenderCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesRenderCreateAsync($id, $config_template_request, $format = null, string $contentType = self::contentTypes['extrasConfigTemplatesRenderCreate'][0])
    {
        return $this->extrasConfigTemplatesRenderCreateAsyncWithHttpInfo($id, $config_template_request, $format, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigTemplatesRenderCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesRenderCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesRenderCreateAsyncWithHttpInfo($id, $config_template_request, $format = null, string $contentType = self::contentTypes['extrasConfigTemplatesRenderCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
        $request = $this->extrasConfigTemplatesRenderCreateRequest($id, $config_template_request, $format, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigTemplatesRenderCreate'
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesRenderCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigTemplatesRenderCreateRequest($id, $config_template_request, $format = null, string $contentType = self::contentTypes['extrasConfigTemplatesRenderCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasConfigTemplatesRenderCreate'
            );
        }

        // verify the required parameter 'config_template_request' is set
        if ($config_template_request === null || (is_array($config_template_request) && count($config_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_template_request when calling extrasConfigTemplatesRenderCreate'
            );
        }



        $resourcePath = '/api/extras/config-templates/{id}/render/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_template_request));
            } else {
                $httpBody = $config_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigTemplatesRetrieve
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigTemplate
     */
    public function extrasConfigTemplatesRetrieve($id, string $contentType = self::contentTypes['extrasConfigTemplatesRetrieve'][0])
    {
        list($response) = $this->extrasConfigTemplatesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigTemplatesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigTemplatesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasConfigTemplatesRetrieve'][0])
    {
        $request = $this->extrasConfigTemplatesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigTemplatesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesRetrieveAsync($id, string $contentType = self::contentTypes['extrasConfigTemplatesRetrieve'][0])
    {
        return $this->extrasConfigTemplatesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigTemplatesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasConfigTemplatesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
        $request = $this->extrasConfigTemplatesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigTemplatesRetrieve'
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigTemplatesRetrieveRequest($id, string $contentType = self::contentTypes['extrasConfigTemplatesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasConfigTemplatesRetrieve'
            );
        }


        $resourcePath = '/api/extras/config-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigTemplatesSyncCreate
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesSyncCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigTemplate
     */
    public function extrasConfigTemplatesSyncCreate($id, $config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesSyncCreate'][0])
    {
        list($response) = $this->extrasConfigTemplatesSyncCreateWithHttpInfo($id, $config_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigTemplatesSyncCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesSyncCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigTemplatesSyncCreateWithHttpInfo($id, $config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesSyncCreate'][0])
    {
        $request = $this->extrasConfigTemplatesSyncCreateRequest($id, $config_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigTemplatesSyncCreateAsync
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesSyncCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesSyncCreateAsync($id, $config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesSyncCreate'][0])
    {
        return $this->extrasConfigTemplatesSyncCreateAsyncWithHttpInfo($id, $config_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigTemplatesSyncCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesSyncCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesSyncCreateAsyncWithHttpInfo($id, $config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesSyncCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
        $request = $this->extrasConfigTemplatesSyncCreateRequest($id, $config_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigTemplatesSyncCreate'
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesSyncCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigTemplatesSyncCreateRequest($id, $config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesSyncCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasConfigTemplatesSyncCreate'
            );
        }

        // verify the required parameter 'config_template_request' is set
        if ($config_template_request === null || (is_array($config_template_request) && count($config_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_template_request when calling extrasConfigTemplatesSyncCreate'
            );
        }


        $resourcePath = '/api/extras/config-templates/{id}/sync/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_template_request));
            } else {
                $httpBody = $config_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasConfigTemplatesUpdate
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigTemplate
     */
    public function extrasConfigTemplatesUpdate($id, $config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesUpdate'][0])
    {
        list($response) = $this->extrasConfigTemplatesUpdateWithHttpInfo($id, $config_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasConfigTemplatesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasConfigTemplatesUpdateWithHttpInfo($id, $config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesUpdate'][0])
    {
        $request = $this->extrasConfigTemplatesUpdateRequest($id, $config_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConfigTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConfigTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConfigTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasConfigTemplatesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesUpdateAsync($id, $config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesUpdate'][0])
    {
        return $this->extrasConfigTemplatesUpdateAsyncWithHttpInfo($id, $config_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasConfigTemplatesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasConfigTemplatesUpdateAsyncWithHttpInfo($id, $config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigTemplate';
        $request = $this->extrasConfigTemplatesUpdateRequest($id, $config_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasConfigTemplatesUpdate'
     *
     * @param  int $id A unique integer value identifying this config template. (required)
     * @param  \OpenAPI\Client\Model\ConfigTemplateRequest $config_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasConfigTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasConfigTemplatesUpdateRequest($id, $config_template_request, string $contentType = self::contentTypes['extrasConfigTemplatesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasConfigTemplatesUpdate'
            );
        }

        // verify the required parameter 'config_template_request' is set
        if ($config_template_request === null || (is_array($config_template_request) && count($config_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_template_request when calling extrasConfigTemplatesUpdate'
            );
        }


        $resourcePath = '/api/extras/config-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($config_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($config_template_request));
            } else {
                $httpBody = $config_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasCustomFieldChoiceSetsBulkDestroy($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkDestroy'][0])
    {
        $this->extrasCustomFieldChoiceSetsBulkDestroyWithHttpInfo($custom_field_choice_set_request, $contentType);
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldChoiceSetsBulkDestroyWithHttpInfo($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkDestroy'][0])
    {
        $request = $this->extrasCustomFieldChoiceSetsBulkDestroyRequest($custom_field_choice_set_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsBulkDestroyAsync($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkDestroy'][0])
    {
        return $this->extrasCustomFieldChoiceSetsBulkDestroyAsyncWithHttpInfo($custom_field_choice_set_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsBulkDestroyAsyncWithHttpInfo($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasCustomFieldChoiceSetsBulkDestroyRequest($custom_field_choice_set_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldChoiceSetsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldChoiceSetsBulkDestroyRequest($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkDestroy'][0])
    {

        // verify the required parameter 'custom_field_choice_set_request' is set
        if ($custom_field_choice_set_request === null || (is_array($custom_field_choice_set_request) && count($custom_field_choice_set_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_field_choice_set_request when calling extrasCustomFieldChoiceSetsBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/custom-field-choice-sets/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_field_choice_set_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_field_choice_set_request));
            } else {
                $httpBody = $custom_field_choice_set_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomFieldChoiceSet[]
     */
    public function extrasCustomFieldChoiceSetsBulkPartialUpdate($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasCustomFieldChoiceSetsBulkPartialUpdateWithHttpInfo($custom_field_choice_set_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomFieldChoiceSet[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldChoiceSetsBulkPartialUpdateWithHttpInfo($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkPartialUpdate'][0])
    {
        $request = $this->extrasCustomFieldChoiceSetsBulkPartialUpdateRequest($custom_field_choice_set_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomFieldChoiceSet[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomFieldChoiceSet[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomFieldChoiceSet[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomFieldChoiceSet[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsBulkPartialUpdateAsync($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkPartialUpdate'][0])
    {
        return $this->extrasCustomFieldChoiceSetsBulkPartialUpdateAsyncWithHttpInfo($custom_field_choice_set_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsBulkPartialUpdateAsyncWithHttpInfo($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet[]';
        $request = $this->extrasCustomFieldChoiceSetsBulkPartialUpdateRequest($custom_field_choice_set_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldChoiceSetsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldChoiceSetsBulkPartialUpdateRequest($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'custom_field_choice_set_request' is set
        if ($custom_field_choice_set_request === null || (is_array($custom_field_choice_set_request) && count($custom_field_choice_set_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_field_choice_set_request when calling extrasCustomFieldChoiceSetsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/custom-field-choice-sets/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_field_choice_set_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_field_choice_set_request));
            } else {
                $httpBody = $custom_field_choice_set_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomFieldChoiceSet[]
     */
    public function extrasCustomFieldChoiceSetsBulkUpdate($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkUpdate'][0])
    {
        list($response) = $this->extrasCustomFieldChoiceSetsBulkUpdateWithHttpInfo($custom_field_choice_set_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomFieldChoiceSet[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldChoiceSetsBulkUpdateWithHttpInfo($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkUpdate'][0])
    {
        $request = $this->extrasCustomFieldChoiceSetsBulkUpdateRequest($custom_field_choice_set_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomFieldChoiceSet[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomFieldChoiceSet[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomFieldChoiceSet[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomFieldChoiceSet[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsBulkUpdateAsync($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkUpdate'][0])
    {
        return $this->extrasCustomFieldChoiceSetsBulkUpdateAsyncWithHttpInfo($custom_field_choice_set_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsBulkUpdateAsyncWithHttpInfo($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet[]';
        $request = $this->extrasCustomFieldChoiceSetsBulkUpdateRequest($custom_field_choice_set_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldChoiceSetsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\CustomFieldChoiceSetRequest[] $custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldChoiceSetsBulkUpdateRequest($custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsBulkUpdate'][0])
    {

        // verify the required parameter 'custom_field_choice_set_request' is set
        if ($custom_field_choice_set_request === null || (is_array($custom_field_choice_set_request) && count($custom_field_choice_set_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_field_choice_set_request when calling extrasCustomFieldChoiceSetsBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/custom-field-choice-sets/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_field_choice_set_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_field_choice_set_request));
            } else {
                $httpBody = $custom_field_choice_set_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsChoicesRetrieve
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsChoicesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomFieldChoiceSet
     */
    public function extrasCustomFieldChoiceSetsChoicesRetrieve($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsChoicesRetrieve'][0])
    {
        list($response) = $this->extrasCustomFieldChoiceSetsChoicesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldChoiceSetsChoicesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsChoicesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomFieldChoiceSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldChoiceSetsChoicesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsChoicesRetrieve'][0])
    {
        $request = $this->extrasCustomFieldChoiceSetsChoicesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomFieldChoiceSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomFieldChoiceSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomFieldChoiceSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomFieldChoiceSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldChoiceSetsChoicesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsChoicesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsChoicesRetrieveAsync($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsChoicesRetrieve'][0])
    {
        return $this->extrasCustomFieldChoiceSetsChoicesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsChoicesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsChoicesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsChoicesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsChoicesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet';
        $request = $this->extrasCustomFieldChoiceSetsChoicesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldChoiceSetsChoicesRetrieve'
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsChoicesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldChoiceSetsChoicesRetrieveRequest($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsChoicesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomFieldChoiceSetsChoicesRetrieve'
            );
        }


        $resourcePath = '/api/extras/custom-field-choice-sets/{id}/choices/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsCreate
     *
     * @param  \OpenAPI\Client\Model\WritableCustomFieldChoiceSetRequest $writable_custom_field_choice_set_request writable_custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomFieldChoiceSet
     */
    public function extrasCustomFieldChoiceSetsCreate($writable_custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsCreate'][0])
    {
        list($response) = $this->extrasCustomFieldChoiceSetsCreateWithHttpInfo($writable_custom_field_choice_set_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldChoiceSetsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableCustomFieldChoiceSetRequest $writable_custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomFieldChoiceSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldChoiceSetsCreateWithHttpInfo($writable_custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsCreate'][0])
    {
        $request = $this->extrasCustomFieldChoiceSetsCreateRequest($writable_custom_field_choice_set_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\CustomFieldChoiceSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomFieldChoiceSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomFieldChoiceSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomFieldChoiceSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldChoiceSetsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableCustomFieldChoiceSetRequest $writable_custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsCreateAsync($writable_custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsCreate'][0])
    {
        return $this->extrasCustomFieldChoiceSetsCreateAsyncWithHttpInfo($writable_custom_field_choice_set_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableCustomFieldChoiceSetRequest $writable_custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsCreateAsyncWithHttpInfo($writable_custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet';
        $request = $this->extrasCustomFieldChoiceSetsCreateRequest($writable_custom_field_choice_set_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldChoiceSetsCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableCustomFieldChoiceSetRequest $writable_custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldChoiceSetsCreateRequest($writable_custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsCreate'][0])
    {

        // verify the required parameter 'writable_custom_field_choice_set_request' is set
        if ($writable_custom_field_choice_set_request === null || (is_array($writable_custom_field_choice_set_request) && count($writable_custom_field_choice_set_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_custom_field_choice_set_request when calling extrasCustomFieldChoiceSetsCreate'
            );
        }


        $resourcePath = '/api/extras/custom-field-choice-sets/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_custom_field_choice_set_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_custom_field_choice_set_request));
            } else {
                $httpBody = $writable_custom_field_choice_set_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsDestroy
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasCustomFieldChoiceSetsDestroy($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsDestroy'][0])
    {
        $this->extrasCustomFieldChoiceSetsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasCustomFieldChoiceSetsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldChoiceSetsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsDestroy'][0])
    {
        $request = $this->extrasCustomFieldChoiceSetsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldChoiceSetsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsDestroyAsync($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsDestroy'][0])
    {
        return $this->extrasCustomFieldChoiceSetsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasCustomFieldChoiceSetsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldChoiceSetsDestroy'
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldChoiceSetsDestroyRequest($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomFieldChoiceSetsDestroy'
            );
        }


        $resourcePath = '/api/extras/custom-field-choice-sets/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsList
     *
     * @param  string $base_choices Base set of predefined choices (optional)  * &#x60;IATA&#x60; - IATA (Airport codes) * &#x60;ISO_3166&#x60; - ISO 3166 (Country codes) * &#x60;UN_LOCODE&#x60; - UN/LOCODE (Location codes) (optional)
     * @param  string $base_choices__n Base set of predefined choices (optional)  * &#x60;IATA&#x60; - IATA (Airport codes) * &#x60;ISO_3166&#x60; - ISO 3166 (Country codes) * &#x60;UN_LOCODE&#x60; - UN/LOCODE (Location codes) (optional)
     * @param  string[] $choice choice (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  bool $order_alphabetically order_alphabetically (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedCustomFieldChoiceSetList
     */
    public function extrasCustomFieldChoiceSetsList($base_choices = null, $base_choices__n = null, $choice = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $order_alphabetically = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsList'][0])
    {
        list($response) = $this->extrasCustomFieldChoiceSetsListWithHttpInfo($base_choices, $base_choices__n, $choice, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $order_alphabetically, $ordering, $q, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldChoiceSetsListWithHttpInfo
     *
     * @param  string $base_choices Base set of predefined choices (optional)  * &#x60;IATA&#x60; - IATA (Airport codes) * &#x60;ISO_3166&#x60; - ISO 3166 (Country codes) * &#x60;UN_LOCODE&#x60; - UN/LOCODE (Location codes) (optional)
     * @param  string $base_choices__n Base set of predefined choices (optional)  * &#x60;IATA&#x60; - IATA (Airport codes) * &#x60;ISO_3166&#x60; - ISO 3166 (Country codes) * &#x60;UN_LOCODE&#x60; - UN/LOCODE (Location codes) (optional)
     * @param  string[] $choice (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  bool $order_alphabetically (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedCustomFieldChoiceSetList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldChoiceSetsListWithHttpInfo($base_choices = null, $base_choices__n = null, $choice = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $order_alphabetically = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsList'][0])
    {
        $request = $this->extrasCustomFieldChoiceSetsListRequest($base_choices, $base_choices__n, $choice, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $order_alphabetically, $ordering, $q, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedCustomFieldChoiceSetList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedCustomFieldChoiceSetList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedCustomFieldChoiceSetList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedCustomFieldChoiceSetList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedCustomFieldChoiceSetList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldChoiceSetsListAsync
     *
     * @param  string $base_choices Base set of predefined choices (optional)  * &#x60;IATA&#x60; - IATA (Airport codes) * &#x60;ISO_3166&#x60; - ISO 3166 (Country codes) * &#x60;UN_LOCODE&#x60; - UN/LOCODE (Location codes) (optional)
     * @param  string $base_choices__n Base set of predefined choices (optional)  * &#x60;IATA&#x60; - IATA (Airport codes) * &#x60;ISO_3166&#x60; - ISO 3166 (Country codes) * &#x60;UN_LOCODE&#x60; - UN/LOCODE (Location codes) (optional)
     * @param  string[] $choice (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  bool $order_alphabetically (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsListAsync($base_choices = null, $base_choices__n = null, $choice = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $order_alphabetically = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsList'][0])
    {
        return $this->extrasCustomFieldChoiceSetsListAsyncWithHttpInfo($base_choices, $base_choices__n, $choice, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $order_alphabetically, $ordering, $q, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsListAsyncWithHttpInfo
     *
     * @param  string $base_choices Base set of predefined choices (optional)  * &#x60;IATA&#x60; - IATA (Airport codes) * &#x60;ISO_3166&#x60; - ISO 3166 (Country codes) * &#x60;UN_LOCODE&#x60; - UN/LOCODE (Location codes) (optional)
     * @param  string $base_choices__n Base set of predefined choices (optional)  * &#x60;IATA&#x60; - IATA (Airport codes) * &#x60;ISO_3166&#x60; - ISO 3166 (Country codes) * &#x60;UN_LOCODE&#x60; - UN/LOCODE (Location codes) (optional)
     * @param  string[] $choice (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  bool $order_alphabetically (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsListAsyncWithHttpInfo($base_choices = null, $base_choices__n = null, $choice = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $order_alphabetically = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedCustomFieldChoiceSetList';
        $request = $this->extrasCustomFieldChoiceSetsListRequest($base_choices, $base_choices__n, $choice, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $order_alphabetically, $ordering, $q, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldChoiceSetsList'
     *
     * @param  string $base_choices Base set of predefined choices (optional)  * &#x60;IATA&#x60; - IATA (Airport codes) * &#x60;ISO_3166&#x60; - ISO 3166 (Country codes) * &#x60;UN_LOCODE&#x60; - UN/LOCODE (Location codes) (optional)
     * @param  string $base_choices__n Base set of predefined choices (optional)  * &#x60;IATA&#x60; - IATA (Airport codes) * &#x60;ISO_3166&#x60; - ISO 3166 (Country codes) * &#x60;UN_LOCODE&#x60; - UN/LOCODE (Location codes) (optional)
     * @param  string[] $choice (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  bool $order_alphabetically (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldChoiceSetsListRequest($base_choices = null, $base_choices__n = null, $choice = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $order_alphabetically = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsList'][0])
    {
























































        $resourcePath = '/api/extras/custom-field-choice-sets/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $base_choices,
            'base_choices', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $base_choices__n,
            'base_choices__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $choice,
            'choice', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_alphabetically,
            'order_alphabetically', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCustomFieldChoiceSetRequest $patched_writable_custom_field_choice_set_request patched_writable_custom_field_choice_set_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomFieldChoiceSet
     */
    public function extrasCustomFieldChoiceSetsPartialUpdate($id, $patched_writable_custom_field_choice_set_request = null, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsPartialUpdate'][0])
    {
        list($response) = $this->extrasCustomFieldChoiceSetsPartialUpdateWithHttpInfo($id, $patched_writable_custom_field_choice_set_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldChoiceSetsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCustomFieldChoiceSetRequest $patched_writable_custom_field_choice_set_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomFieldChoiceSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldChoiceSetsPartialUpdateWithHttpInfo($id, $patched_writable_custom_field_choice_set_request = null, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsPartialUpdate'][0])
    {
        $request = $this->extrasCustomFieldChoiceSetsPartialUpdateRequest($id, $patched_writable_custom_field_choice_set_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomFieldChoiceSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomFieldChoiceSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomFieldChoiceSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomFieldChoiceSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldChoiceSetsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCustomFieldChoiceSetRequest $patched_writable_custom_field_choice_set_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsPartialUpdateAsync($id, $patched_writable_custom_field_choice_set_request = null, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsPartialUpdate'][0])
    {
        return $this->extrasCustomFieldChoiceSetsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_custom_field_choice_set_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCustomFieldChoiceSetRequest $patched_writable_custom_field_choice_set_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_custom_field_choice_set_request = null, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet';
        $request = $this->extrasCustomFieldChoiceSetsPartialUpdateRequest($id, $patched_writable_custom_field_choice_set_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldChoiceSetsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCustomFieldChoiceSetRequest $patched_writable_custom_field_choice_set_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldChoiceSetsPartialUpdateRequest($id, $patched_writable_custom_field_choice_set_request = null, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomFieldChoiceSetsPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/custom-field-choice-sets/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_custom_field_choice_set_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_custom_field_choice_set_request));
            } else {
                $httpBody = $patched_writable_custom_field_choice_set_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsRetrieve
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomFieldChoiceSet
     */
    public function extrasCustomFieldChoiceSetsRetrieve($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsRetrieve'][0])
    {
        list($response) = $this->extrasCustomFieldChoiceSetsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldChoiceSetsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomFieldChoiceSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldChoiceSetsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsRetrieve'][0])
    {
        $request = $this->extrasCustomFieldChoiceSetsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomFieldChoiceSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomFieldChoiceSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomFieldChoiceSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomFieldChoiceSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldChoiceSetsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsRetrieveAsync($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsRetrieve'][0])
    {
        return $this->extrasCustomFieldChoiceSetsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet';
        $request = $this->extrasCustomFieldChoiceSetsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldChoiceSetsRetrieve'
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldChoiceSetsRetrieveRequest($id, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomFieldChoiceSetsRetrieve'
            );
        }


        $resourcePath = '/api/extras/custom-field-choice-sets/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsUpdate
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  \OpenAPI\Client\Model\WritableCustomFieldChoiceSetRequest $writable_custom_field_choice_set_request writable_custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomFieldChoiceSet
     */
    public function extrasCustomFieldChoiceSetsUpdate($id, $writable_custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsUpdate'][0])
    {
        list($response) = $this->extrasCustomFieldChoiceSetsUpdateWithHttpInfo($id, $writable_custom_field_choice_set_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldChoiceSetsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  \OpenAPI\Client\Model\WritableCustomFieldChoiceSetRequest $writable_custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomFieldChoiceSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldChoiceSetsUpdateWithHttpInfo($id, $writable_custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsUpdate'][0])
    {
        $request = $this->extrasCustomFieldChoiceSetsUpdateRequest($id, $writable_custom_field_choice_set_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomFieldChoiceSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomFieldChoiceSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomFieldChoiceSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomFieldChoiceSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldChoiceSetsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  \OpenAPI\Client\Model\WritableCustomFieldChoiceSetRequest $writable_custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsUpdateAsync($id, $writable_custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsUpdate'][0])
    {
        return $this->extrasCustomFieldChoiceSetsUpdateAsyncWithHttpInfo($id, $writable_custom_field_choice_set_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldChoiceSetsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  \OpenAPI\Client\Model\WritableCustomFieldChoiceSetRequest $writable_custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldChoiceSetsUpdateAsyncWithHttpInfo($id, $writable_custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomFieldChoiceSet';
        $request = $this->extrasCustomFieldChoiceSetsUpdateRequest($id, $writable_custom_field_choice_set_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldChoiceSetsUpdate'
     *
     * @param  int $id A unique integer value identifying this custom field choice set. (required)
     * @param  \OpenAPI\Client\Model\WritableCustomFieldChoiceSetRequest $writable_custom_field_choice_set_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldChoiceSetsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldChoiceSetsUpdateRequest($id, $writable_custom_field_choice_set_request, string $contentType = self::contentTypes['extrasCustomFieldChoiceSetsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomFieldChoiceSetsUpdate'
            );
        }

        // verify the required parameter 'writable_custom_field_choice_set_request' is set
        if ($writable_custom_field_choice_set_request === null || (is_array($writable_custom_field_choice_set_request) && count($writable_custom_field_choice_set_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_custom_field_choice_set_request when calling extrasCustomFieldChoiceSetsUpdate'
            );
        }


        $resourcePath = '/api/extras/custom-field-choice-sets/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_custom_field_choice_set_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_custom_field_choice_set_request));
            } else {
                $httpBody = $writable_custom_field_choice_set_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasCustomFieldsBulkDestroy($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkDestroy'][0])
    {
        $this->extrasCustomFieldsBulkDestroyWithHttpInfo($custom_field_request, $contentType);
    }

    /**
     * Operation extrasCustomFieldsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldsBulkDestroyWithHttpInfo($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkDestroy'][0])
    {
        $request = $this->extrasCustomFieldsBulkDestroyRequest($custom_field_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsBulkDestroyAsync($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkDestroy'][0])
    {
        return $this->extrasCustomFieldsBulkDestroyAsyncWithHttpInfo($custom_field_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsBulkDestroyAsyncWithHttpInfo($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasCustomFieldsBulkDestroyRequest($custom_field_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldsBulkDestroyRequest($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkDestroy'][0])
    {

        // verify the required parameter 'custom_field_request' is set
        if ($custom_field_request === null || (is_array($custom_field_request) && count($custom_field_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_field_request when calling extrasCustomFieldsBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/custom-fields/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_field_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_field_request));
            } else {
                $httpBody = $custom_field_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomField[]
     */
    public function extrasCustomFieldsBulkPartialUpdate($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasCustomFieldsBulkPartialUpdateWithHttpInfo($custom_field_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomField[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldsBulkPartialUpdateWithHttpInfo($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkPartialUpdate'][0])
    {
        $request = $this->extrasCustomFieldsBulkPartialUpdateRequest($custom_field_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomField[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomField[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomField[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomField[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsBulkPartialUpdateAsync($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkPartialUpdate'][0])
    {
        return $this->extrasCustomFieldsBulkPartialUpdateAsyncWithHttpInfo($custom_field_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsBulkPartialUpdateAsyncWithHttpInfo($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomField[]';
        $request = $this->extrasCustomFieldsBulkPartialUpdateRequest($custom_field_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldsBulkPartialUpdateRequest($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'custom_field_request' is set
        if ($custom_field_request === null || (is_array($custom_field_request) && count($custom_field_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_field_request when calling extrasCustomFieldsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/custom-fields/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_field_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_field_request));
            } else {
                $httpBody = $custom_field_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomField[]
     */
    public function extrasCustomFieldsBulkUpdate($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkUpdate'][0])
    {
        list($response) = $this->extrasCustomFieldsBulkUpdateWithHttpInfo($custom_field_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomField[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldsBulkUpdateWithHttpInfo($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkUpdate'][0])
    {
        $request = $this->extrasCustomFieldsBulkUpdateRequest($custom_field_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomField[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomField[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomField[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomField[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsBulkUpdateAsync($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkUpdate'][0])
    {
        return $this->extrasCustomFieldsBulkUpdateAsyncWithHttpInfo($custom_field_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsBulkUpdateAsyncWithHttpInfo($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomField[]';
        $request = $this->extrasCustomFieldsBulkUpdateRequest($custom_field_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\CustomFieldRequest[] $custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldsBulkUpdateRequest($custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsBulkUpdate'][0])
    {

        // verify the required parameter 'custom_field_request' is set
        if ($custom_field_request === null || (is_array($custom_field_request) && count($custom_field_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_field_request when calling extrasCustomFieldsBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/custom-fields/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_field_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_field_request));
            } else {
                $httpBody = $custom_field_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldsCreate
     *
     * @param  \OpenAPI\Client\Model\WritableCustomFieldRequest $writable_custom_field_request writable_custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomField
     */
    public function extrasCustomFieldsCreate($writable_custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsCreate'][0])
    {
        list($response) = $this->extrasCustomFieldsCreateWithHttpInfo($writable_custom_field_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableCustomFieldRequest $writable_custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomField, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldsCreateWithHttpInfo($writable_custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsCreate'][0])
    {
        $request = $this->extrasCustomFieldsCreateRequest($writable_custom_field_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\CustomField' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomField' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomField', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomField';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomField',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableCustomFieldRequest $writable_custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsCreateAsync($writable_custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsCreate'][0])
    {
        return $this->extrasCustomFieldsCreateAsyncWithHttpInfo($writable_custom_field_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableCustomFieldRequest $writable_custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsCreateAsyncWithHttpInfo($writable_custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomField';
        $request = $this->extrasCustomFieldsCreateRequest($writable_custom_field_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldsCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableCustomFieldRequest $writable_custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldsCreateRequest($writable_custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsCreate'][0])
    {

        // verify the required parameter 'writable_custom_field_request' is set
        if ($writable_custom_field_request === null || (is_array($writable_custom_field_request) && count($writable_custom_field_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_custom_field_request when calling extrasCustomFieldsCreate'
            );
        }


        $resourcePath = '/api/extras/custom-fields/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_custom_field_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_custom_field_request));
            } else {
                $httpBody = $writable_custom_field_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldsDestroy
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasCustomFieldsDestroy($id, string $contentType = self::contentTypes['extrasCustomFieldsDestroy'][0])
    {
        $this->extrasCustomFieldsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasCustomFieldsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomFieldsDestroy'][0])
    {
        $request = $this->extrasCustomFieldsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsDestroyAsync($id, string $contentType = self::contentTypes['extrasCustomFieldsDestroy'][0])
    {
        return $this->extrasCustomFieldsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomFieldsDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasCustomFieldsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldsDestroy'
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldsDestroyRequest($id, string $contentType = self::contentTypes['extrasCustomFieldsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomFieldsDestroy'
            );
        }


        $resourcePath = '/api/extras/custom-fields/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldsList
     *
     * @param  string[] $choice_set choice_set (optional)
     * @param  string[] $choice_set__n choice_set__n (optional)
     * @param  int[] $choice_set_id choice_set_id (optional)
     * @param  int[] $choice_set_id__n choice_set_id__n (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string $filter_logic Loose matches any instance of a given string; exact matches the entire field.  * &#x60;disabled&#x60; - Disabled * &#x60;loose&#x60; - Loose * &#x60;exact&#x60; - Exact (optional)
     * @param  string $filter_logic__n Loose matches any instance of a given string; exact matches the entire field.  * &#x60;disabled&#x60; - Disabled * &#x60;loose&#x60; - Loose * &#x60;exact&#x60; - Exact (optional)
     * @param  string[] $group_name group_name (optional)
     * @param  bool $group_name__empty group_name__empty (optional)
     * @param  string[] $group_name__ic group_name__ic (optional)
     * @param  string[] $group_name__ie group_name__ie (optional)
     * @param  string[] $group_name__iew group_name__iew (optional)
     * @param  string[] $group_name__isw group_name__isw (optional)
     * @param  string[] $group_name__n group_name__n (optional)
     * @param  string[] $group_name__nic group_name__nic (optional)
     * @param  string[] $group_name__nie group_name__nie (optional)
     * @param  string[] $group_name__niew group_name__niew (optional)
     * @param  string[] $group_name__nisw group_name__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  bool $is_cloneable is_cloneable (optional)
     * @param  string[] $label label (optional)
     * @param  bool $label__empty label__empty (optional)
     * @param  string[] $label__ic label__ic (optional)
     * @param  string[] $label__ie label__ie (optional)
     * @param  string[] $label__iew label__iew (optional)
     * @param  string[] $label__isw label__isw (optional)
     * @param  string[] $label__n label__n (optional)
     * @param  string[] $label__nic label__nic (optional)
     * @param  string[] $label__nie label__nie (optional)
     * @param  string[] $label__niew label__niew (optional)
     * @param  string[] $label__nisw label__nisw (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  string $object_type object_type (optional)
     * @param  string $object_type__ic object_type__ic (optional)
     * @param  string $object_type__ie object_type__ie (optional)
     * @param  string $object_type__iew object_type__iew (optional)
     * @param  string $object_type__isw object_type__isw (optional)
     * @param  string $object_type__n object_type__n (optional)
     * @param  string $object_type__nic object_type__nic (optional)
     * @param  string $object_type__nie object_type__nie (optional)
     * @param  string $object_type__niew object_type__niew (optional)
     * @param  string $object_type__nisw object_type__nisw (optional)
     * @param  int[] $object_type_id object_type_id (optional)
     * @param  int[] $object_type_id__n object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $related_object_type related_object_type (optional)
     * @param  string $related_object_type__n related_object_type__n (optional)
     * @param  int[] $related_object_type_id related_object_type_id (optional)
     * @param  int[] $related_object_type_id__n related_object_type_id__n (optional)
     * @param  bool $required required (optional)
     * @param  int[] $search_weight search_weight (optional)
     * @param  bool $search_weight__empty search_weight__empty (optional)
     * @param  int[] $search_weight__gt search_weight__gt (optional)
     * @param  int[] $search_weight__gte search_weight__gte (optional)
     * @param  int[] $search_weight__lt search_weight__lt (optional)
     * @param  int[] $search_weight__lte search_weight__lte (optional)
     * @param  int[] $search_weight__n search_weight__n (optional)
     * @param  string[] $type The type of data this custom field holds (optional)
     * @param  string[] $type__n The type of data this custom field holds (optional)
     * @param  string $ui_editable Specifies whether the custom field value can be edited in the UI  * &#x60;yes&#x60; - Yes * &#x60;no&#x60; - No * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_editable__n Specifies whether the custom field value can be edited in the UI  * &#x60;yes&#x60; - Yes * &#x60;no&#x60; - No * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_visible Specifies whether the custom field is displayed in the UI  * &#x60;always&#x60; - Always * &#x60;if-set&#x60; - If set * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_visible__n Specifies whether the custom field is displayed in the UI  * &#x60;always&#x60; - Always * &#x60;if-set&#x60; - If set * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  int[] $validation_maximum validation_maximum (optional)
     * @param  bool $validation_maximum__empty validation_maximum__empty (optional)
     * @param  int[] $validation_maximum__gt validation_maximum__gt (optional)
     * @param  int[] $validation_maximum__gte validation_maximum__gte (optional)
     * @param  int[] $validation_maximum__lt validation_maximum__lt (optional)
     * @param  int[] $validation_maximum__lte validation_maximum__lte (optional)
     * @param  int[] $validation_maximum__n validation_maximum__n (optional)
     * @param  int[] $validation_minimum validation_minimum (optional)
     * @param  bool $validation_minimum__empty validation_minimum__empty (optional)
     * @param  int[] $validation_minimum__gt validation_minimum__gt (optional)
     * @param  int[] $validation_minimum__gte validation_minimum__gte (optional)
     * @param  int[] $validation_minimum__lt validation_minimum__lt (optional)
     * @param  int[] $validation_minimum__lte validation_minimum__lte (optional)
     * @param  int[] $validation_minimum__n validation_minimum__n (optional)
     * @param  string[] $validation_regex validation_regex (optional)
     * @param  bool $validation_regex__empty validation_regex__empty (optional)
     * @param  string[] $validation_regex__ic validation_regex__ic (optional)
     * @param  string[] $validation_regex__ie validation_regex__ie (optional)
     * @param  string[] $validation_regex__iew validation_regex__iew (optional)
     * @param  string[] $validation_regex__isw validation_regex__isw (optional)
     * @param  string[] $validation_regex__n validation_regex__n (optional)
     * @param  string[] $validation_regex__nic validation_regex__nic (optional)
     * @param  string[] $validation_regex__nie validation_regex__nie (optional)
     * @param  string[] $validation_regex__niew validation_regex__niew (optional)
     * @param  string[] $validation_regex__nisw validation_regex__nisw (optional)
     * @param  int[] $weight weight (optional)
     * @param  bool $weight__empty weight__empty (optional)
     * @param  int[] $weight__gt weight__gt (optional)
     * @param  int[] $weight__gte weight__gte (optional)
     * @param  int[] $weight__lt weight__lt (optional)
     * @param  int[] $weight__lte weight__lte (optional)
     * @param  int[] $weight__n weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedCustomFieldList
     */
    public function extrasCustomFieldsList($choice_set = null, $choice_set__n = null, $choice_set_id = null, $choice_set_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $filter_logic = null, $filter_logic__n = null, $group_name = null, $group_name__empty = null, $group_name__ic = null, $group_name__ie = null, $group_name__iew = null, $group_name__isw = null, $group_name__n = null, $group_name__nic = null, $group_name__nie = null, $group_name__niew = null, $group_name__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_cloneable = null, $label = null, $label__empty = null, $label__ic = null, $label__ie = null, $label__iew = null, $label__isw = null, $label__n = null, $label__nic = null, $label__nie = null, $label__niew = null, $label__nisw = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $related_object_type = null, $related_object_type__n = null, $related_object_type_id = null, $related_object_type_id__n = null, $required = null, $search_weight = null, $search_weight__empty = null, $search_weight__gt = null, $search_weight__gte = null, $search_weight__lt = null, $search_weight__lte = null, $search_weight__n = null, $type = null, $type__n = null, $ui_editable = null, $ui_editable__n = null, $ui_visible = null, $ui_visible__n = null, $updated_by_request = null, $validation_maximum = null, $validation_maximum__empty = null, $validation_maximum__gt = null, $validation_maximum__gte = null, $validation_maximum__lt = null, $validation_maximum__lte = null, $validation_maximum__n = null, $validation_minimum = null, $validation_minimum__empty = null, $validation_minimum__gt = null, $validation_minimum__gte = null, $validation_minimum__lt = null, $validation_minimum__lte = null, $validation_minimum__n = null, $validation_regex = null, $validation_regex__empty = null, $validation_regex__ic = null, $validation_regex__ie = null, $validation_regex__iew = null, $validation_regex__isw = null, $validation_regex__n = null, $validation_regex__nic = null, $validation_regex__nie = null, $validation_regex__niew = null, $validation_regex__nisw = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasCustomFieldsList'][0])
    {
        list($response) = $this->extrasCustomFieldsListWithHttpInfo($choice_set, $choice_set__n, $choice_set_id, $choice_set_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $filter_logic, $filter_logic__n, $group_name, $group_name__empty, $group_name__ic, $group_name__ie, $group_name__iew, $group_name__isw, $group_name__n, $group_name__nic, $group_name__nie, $group_name__niew, $group_name__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_cloneable, $label, $label__empty, $label__ic, $label__ie, $label__iew, $label__isw, $label__n, $label__nic, $label__nie, $label__niew, $label__nisw, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $related_object_type, $related_object_type__n, $related_object_type_id, $related_object_type_id__n, $required, $search_weight, $search_weight__empty, $search_weight__gt, $search_weight__gte, $search_weight__lt, $search_weight__lte, $search_weight__n, $type, $type__n, $ui_editable, $ui_editable__n, $ui_visible, $ui_visible__n, $updated_by_request, $validation_maximum, $validation_maximum__empty, $validation_maximum__gt, $validation_maximum__gte, $validation_maximum__lt, $validation_maximum__lte, $validation_maximum__n, $validation_minimum, $validation_minimum__empty, $validation_minimum__gt, $validation_minimum__gte, $validation_minimum__lt, $validation_minimum__lte, $validation_minimum__n, $validation_regex, $validation_regex__empty, $validation_regex__ic, $validation_regex__ie, $validation_regex__iew, $validation_regex__isw, $validation_regex__n, $validation_regex__nic, $validation_regex__nie, $validation_regex__niew, $validation_regex__nisw, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldsListWithHttpInfo
     *
     * @param  string[] $choice_set (optional)
     * @param  string[] $choice_set__n (optional)
     * @param  int[] $choice_set_id (optional)
     * @param  int[] $choice_set_id__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string $filter_logic Loose matches any instance of a given string; exact matches the entire field.  * &#x60;disabled&#x60; - Disabled * &#x60;loose&#x60; - Loose * &#x60;exact&#x60; - Exact (optional)
     * @param  string $filter_logic__n Loose matches any instance of a given string; exact matches the entire field.  * &#x60;disabled&#x60; - Disabled * &#x60;loose&#x60; - Loose * &#x60;exact&#x60; - Exact (optional)
     * @param  string[] $group_name (optional)
     * @param  bool $group_name__empty (optional)
     * @param  string[] $group_name__ic (optional)
     * @param  string[] $group_name__ie (optional)
     * @param  string[] $group_name__iew (optional)
     * @param  string[] $group_name__isw (optional)
     * @param  string[] $group_name__n (optional)
     * @param  string[] $group_name__nic (optional)
     * @param  string[] $group_name__nie (optional)
     * @param  string[] $group_name__niew (optional)
     * @param  string[] $group_name__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_cloneable (optional)
     * @param  string[] $label (optional)
     * @param  bool $label__empty (optional)
     * @param  string[] $label__ic (optional)
     * @param  string[] $label__ie (optional)
     * @param  string[] $label__iew (optional)
     * @param  string[] $label__isw (optional)
     * @param  string[] $label__n (optional)
     * @param  string[] $label__nic (optional)
     * @param  string[] $label__nie (optional)
     * @param  string[] $label__niew (optional)
     * @param  string[] $label__nisw (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $related_object_type (optional)
     * @param  string $related_object_type__n (optional)
     * @param  int[] $related_object_type_id (optional)
     * @param  int[] $related_object_type_id__n (optional)
     * @param  bool $required (optional)
     * @param  int[] $search_weight (optional)
     * @param  bool $search_weight__empty (optional)
     * @param  int[] $search_weight__gt (optional)
     * @param  int[] $search_weight__gte (optional)
     * @param  int[] $search_weight__lt (optional)
     * @param  int[] $search_weight__lte (optional)
     * @param  int[] $search_weight__n (optional)
     * @param  string[] $type The type of data this custom field holds (optional)
     * @param  string[] $type__n The type of data this custom field holds (optional)
     * @param  string $ui_editable Specifies whether the custom field value can be edited in the UI  * &#x60;yes&#x60; - Yes * &#x60;no&#x60; - No * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_editable__n Specifies whether the custom field value can be edited in the UI  * &#x60;yes&#x60; - Yes * &#x60;no&#x60; - No * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_visible Specifies whether the custom field is displayed in the UI  * &#x60;always&#x60; - Always * &#x60;if-set&#x60; - If set * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_visible__n Specifies whether the custom field is displayed in the UI  * &#x60;always&#x60; - Always * &#x60;if-set&#x60; - If set * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $validation_maximum (optional)
     * @param  bool $validation_maximum__empty (optional)
     * @param  int[] $validation_maximum__gt (optional)
     * @param  int[] $validation_maximum__gte (optional)
     * @param  int[] $validation_maximum__lt (optional)
     * @param  int[] $validation_maximum__lte (optional)
     * @param  int[] $validation_maximum__n (optional)
     * @param  int[] $validation_minimum (optional)
     * @param  bool $validation_minimum__empty (optional)
     * @param  int[] $validation_minimum__gt (optional)
     * @param  int[] $validation_minimum__gte (optional)
     * @param  int[] $validation_minimum__lt (optional)
     * @param  int[] $validation_minimum__lte (optional)
     * @param  int[] $validation_minimum__n (optional)
     * @param  string[] $validation_regex (optional)
     * @param  bool $validation_regex__empty (optional)
     * @param  string[] $validation_regex__ic (optional)
     * @param  string[] $validation_regex__ie (optional)
     * @param  string[] $validation_regex__iew (optional)
     * @param  string[] $validation_regex__isw (optional)
     * @param  string[] $validation_regex__n (optional)
     * @param  string[] $validation_regex__nic (optional)
     * @param  string[] $validation_regex__nie (optional)
     * @param  string[] $validation_regex__niew (optional)
     * @param  string[] $validation_regex__nisw (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedCustomFieldList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldsListWithHttpInfo($choice_set = null, $choice_set__n = null, $choice_set_id = null, $choice_set_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $filter_logic = null, $filter_logic__n = null, $group_name = null, $group_name__empty = null, $group_name__ic = null, $group_name__ie = null, $group_name__iew = null, $group_name__isw = null, $group_name__n = null, $group_name__nic = null, $group_name__nie = null, $group_name__niew = null, $group_name__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_cloneable = null, $label = null, $label__empty = null, $label__ic = null, $label__ie = null, $label__iew = null, $label__isw = null, $label__n = null, $label__nic = null, $label__nie = null, $label__niew = null, $label__nisw = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $related_object_type = null, $related_object_type__n = null, $related_object_type_id = null, $related_object_type_id__n = null, $required = null, $search_weight = null, $search_weight__empty = null, $search_weight__gt = null, $search_weight__gte = null, $search_weight__lt = null, $search_weight__lte = null, $search_weight__n = null, $type = null, $type__n = null, $ui_editable = null, $ui_editable__n = null, $ui_visible = null, $ui_visible__n = null, $updated_by_request = null, $validation_maximum = null, $validation_maximum__empty = null, $validation_maximum__gt = null, $validation_maximum__gte = null, $validation_maximum__lt = null, $validation_maximum__lte = null, $validation_maximum__n = null, $validation_minimum = null, $validation_minimum__empty = null, $validation_minimum__gt = null, $validation_minimum__gte = null, $validation_minimum__lt = null, $validation_minimum__lte = null, $validation_minimum__n = null, $validation_regex = null, $validation_regex__empty = null, $validation_regex__ic = null, $validation_regex__ie = null, $validation_regex__iew = null, $validation_regex__isw = null, $validation_regex__n = null, $validation_regex__nic = null, $validation_regex__nie = null, $validation_regex__niew = null, $validation_regex__nisw = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasCustomFieldsList'][0])
    {
        $request = $this->extrasCustomFieldsListRequest($choice_set, $choice_set__n, $choice_set_id, $choice_set_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $filter_logic, $filter_logic__n, $group_name, $group_name__empty, $group_name__ic, $group_name__ie, $group_name__iew, $group_name__isw, $group_name__n, $group_name__nic, $group_name__nie, $group_name__niew, $group_name__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_cloneable, $label, $label__empty, $label__ic, $label__ie, $label__iew, $label__isw, $label__n, $label__nic, $label__nie, $label__niew, $label__nisw, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $related_object_type, $related_object_type__n, $related_object_type_id, $related_object_type_id__n, $required, $search_weight, $search_weight__empty, $search_weight__gt, $search_weight__gte, $search_weight__lt, $search_weight__lte, $search_weight__n, $type, $type__n, $ui_editable, $ui_editable__n, $ui_visible, $ui_visible__n, $updated_by_request, $validation_maximum, $validation_maximum__empty, $validation_maximum__gt, $validation_maximum__gte, $validation_maximum__lt, $validation_maximum__lte, $validation_maximum__n, $validation_minimum, $validation_minimum__empty, $validation_minimum__gt, $validation_minimum__gte, $validation_minimum__lt, $validation_minimum__lte, $validation_minimum__n, $validation_regex, $validation_regex__empty, $validation_regex__ic, $validation_regex__ie, $validation_regex__iew, $validation_regex__isw, $validation_regex__n, $validation_regex__nic, $validation_regex__nie, $validation_regex__niew, $validation_regex__nisw, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedCustomFieldList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedCustomFieldList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedCustomFieldList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedCustomFieldList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedCustomFieldList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldsListAsync
     *
     * @param  string[] $choice_set (optional)
     * @param  string[] $choice_set__n (optional)
     * @param  int[] $choice_set_id (optional)
     * @param  int[] $choice_set_id__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string $filter_logic Loose matches any instance of a given string; exact matches the entire field.  * &#x60;disabled&#x60; - Disabled * &#x60;loose&#x60; - Loose * &#x60;exact&#x60; - Exact (optional)
     * @param  string $filter_logic__n Loose matches any instance of a given string; exact matches the entire field.  * &#x60;disabled&#x60; - Disabled * &#x60;loose&#x60; - Loose * &#x60;exact&#x60; - Exact (optional)
     * @param  string[] $group_name (optional)
     * @param  bool $group_name__empty (optional)
     * @param  string[] $group_name__ic (optional)
     * @param  string[] $group_name__ie (optional)
     * @param  string[] $group_name__iew (optional)
     * @param  string[] $group_name__isw (optional)
     * @param  string[] $group_name__n (optional)
     * @param  string[] $group_name__nic (optional)
     * @param  string[] $group_name__nie (optional)
     * @param  string[] $group_name__niew (optional)
     * @param  string[] $group_name__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_cloneable (optional)
     * @param  string[] $label (optional)
     * @param  bool $label__empty (optional)
     * @param  string[] $label__ic (optional)
     * @param  string[] $label__ie (optional)
     * @param  string[] $label__iew (optional)
     * @param  string[] $label__isw (optional)
     * @param  string[] $label__n (optional)
     * @param  string[] $label__nic (optional)
     * @param  string[] $label__nie (optional)
     * @param  string[] $label__niew (optional)
     * @param  string[] $label__nisw (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $related_object_type (optional)
     * @param  string $related_object_type__n (optional)
     * @param  int[] $related_object_type_id (optional)
     * @param  int[] $related_object_type_id__n (optional)
     * @param  bool $required (optional)
     * @param  int[] $search_weight (optional)
     * @param  bool $search_weight__empty (optional)
     * @param  int[] $search_weight__gt (optional)
     * @param  int[] $search_weight__gte (optional)
     * @param  int[] $search_weight__lt (optional)
     * @param  int[] $search_weight__lte (optional)
     * @param  int[] $search_weight__n (optional)
     * @param  string[] $type The type of data this custom field holds (optional)
     * @param  string[] $type__n The type of data this custom field holds (optional)
     * @param  string $ui_editable Specifies whether the custom field value can be edited in the UI  * &#x60;yes&#x60; - Yes * &#x60;no&#x60; - No * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_editable__n Specifies whether the custom field value can be edited in the UI  * &#x60;yes&#x60; - Yes * &#x60;no&#x60; - No * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_visible Specifies whether the custom field is displayed in the UI  * &#x60;always&#x60; - Always * &#x60;if-set&#x60; - If set * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_visible__n Specifies whether the custom field is displayed in the UI  * &#x60;always&#x60; - Always * &#x60;if-set&#x60; - If set * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $validation_maximum (optional)
     * @param  bool $validation_maximum__empty (optional)
     * @param  int[] $validation_maximum__gt (optional)
     * @param  int[] $validation_maximum__gte (optional)
     * @param  int[] $validation_maximum__lt (optional)
     * @param  int[] $validation_maximum__lte (optional)
     * @param  int[] $validation_maximum__n (optional)
     * @param  int[] $validation_minimum (optional)
     * @param  bool $validation_minimum__empty (optional)
     * @param  int[] $validation_minimum__gt (optional)
     * @param  int[] $validation_minimum__gte (optional)
     * @param  int[] $validation_minimum__lt (optional)
     * @param  int[] $validation_minimum__lte (optional)
     * @param  int[] $validation_minimum__n (optional)
     * @param  string[] $validation_regex (optional)
     * @param  bool $validation_regex__empty (optional)
     * @param  string[] $validation_regex__ic (optional)
     * @param  string[] $validation_regex__ie (optional)
     * @param  string[] $validation_regex__iew (optional)
     * @param  string[] $validation_regex__isw (optional)
     * @param  string[] $validation_regex__n (optional)
     * @param  string[] $validation_regex__nic (optional)
     * @param  string[] $validation_regex__nie (optional)
     * @param  string[] $validation_regex__niew (optional)
     * @param  string[] $validation_regex__nisw (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsListAsync($choice_set = null, $choice_set__n = null, $choice_set_id = null, $choice_set_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $filter_logic = null, $filter_logic__n = null, $group_name = null, $group_name__empty = null, $group_name__ic = null, $group_name__ie = null, $group_name__iew = null, $group_name__isw = null, $group_name__n = null, $group_name__nic = null, $group_name__nie = null, $group_name__niew = null, $group_name__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_cloneable = null, $label = null, $label__empty = null, $label__ic = null, $label__ie = null, $label__iew = null, $label__isw = null, $label__n = null, $label__nic = null, $label__nie = null, $label__niew = null, $label__nisw = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $related_object_type = null, $related_object_type__n = null, $related_object_type_id = null, $related_object_type_id__n = null, $required = null, $search_weight = null, $search_weight__empty = null, $search_weight__gt = null, $search_weight__gte = null, $search_weight__lt = null, $search_weight__lte = null, $search_weight__n = null, $type = null, $type__n = null, $ui_editable = null, $ui_editable__n = null, $ui_visible = null, $ui_visible__n = null, $updated_by_request = null, $validation_maximum = null, $validation_maximum__empty = null, $validation_maximum__gt = null, $validation_maximum__gte = null, $validation_maximum__lt = null, $validation_maximum__lte = null, $validation_maximum__n = null, $validation_minimum = null, $validation_minimum__empty = null, $validation_minimum__gt = null, $validation_minimum__gte = null, $validation_minimum__lt = null, $validation_minimum__lte = null, $validation_minimum__n = null, $validation_regex = null, $validation_regex__empty = null, $validation_regex__ic = null, $validation_regex__ie = null, $validation_regex__iew = null, $validation_regex__isw = null, $validation_regex__n = null, $validation_regex__nic = null, $validation_regex__nie = null, $validation_regex__niew = null, $validation_regex__nisw = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasCustomFieldsList'][0])
    {
        return $this->extrasCustomFieldsListAsyncWithHttpInfo($choice_set, $choice_set__n, $choice_set_id, $choice_set_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $filter_logic, $filter_logic__n, $group_name, $group_name__empty, $group_name__ic, $group_name__ie, $group_name__iew, $group_name__isw, $group_name__n, $group_name__nic, $group_name__nie, $group_name__niew, $group_name__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_cloneable, $label, $label__empty, $label__ic, $label__ie, $label__iew, $label__isw, $label__n, $label__nic, $label__nie, $label__niew, $label__nisw, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $related_object_type, $related_object_type__n, $related_object_type_id, $related_object_type_id__n, $required, $search_weight, $search_weight__empty, $search_weight__gt, $search_weight__gte, $search_weight__lt, $search_weight__lte, $search_weight__n, $type, $type__n, $ui_editable, $ui_editable__n, $ui_visible, $ui_visible__n, $updated_by_request, $validation_maximum, $validation_maximum__empty, $validation_maximum__gt, $validation_maximum__gte, $validation_maximum__lt, $validation_maximum__lte, $validation_maximum__n, $validation_minimum, $validation_minimum__empty, $validation_minimum__gt, $validation_minimum__gte, $validation_minimum__lt, $validation_minimum__lte, $validation_minimum__n, $validation_regex, $validation_regex__empty, $validation_regex__ic, $validation_regex__ie, $validation_regex__iew, $validation_regex__isw, $validation_regex__n, $validation_regex__nic, $validation_regex__nie, $validation_regex__niew, $validation_regex__nisw, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldsListAsyncWithHttpInfo
     *
     * @param  string[] $choice_set (optional)
     * @param  string[] $choice_set__n (optional)
     * @param  int[] $choice_set_id (optional)
     * @param  int[] $choice_set_id__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string $filter_logic Loose matches any instance of a given string; exact matches the entire field.  * &#x60;disabled&#x60; - Disabled * &#x60;loose&#x60; - Loose * &#x60;exact&#x60; - Exact (optional)
     * @param  string $filter_logic__n Loose matches any instance of a given string; exact matches the entire field.  * &#x60;disabled&#x60; - Disabled * &#x60;loose&#x60; - Loose * &#x60;exact&#x60; - Exact (optional)
     * @param  string[] $group_name (optional)
     * @param  bool $group_name__empty (optional)
     * @param  string[] $group_name__ic (optional)
     * @param  string[] $group_name__ie (optional)
     * @param  string[] $group_name__iew (optional)
     * @param  string[] $group_name__isw (optional)
     * @param  string[] $group_name__n (optional)
     * @param  string[] $group_name__nic (optional)
     * @param  string[] $group_name__nie (optional)
     * @param  string[] $group_name__niew (optional)
     * @param  string[] $group_name__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_cloneable (optional)
     * @param  string[] $label (optional)
     * @param  bool $label__empty (optional)
     * @param  string[] $label__ic (optional)
     * @param  string[] $label__ie (optional)
     * @param  string[] $label__iew (optional)
     * @param  string[] $label__isw (optional)
     * @param  string[] $label__n (optional)
     * @param  string[] $label__nic (optional)
     * @param  string[] $label__nie (optional)
     * @param  string[] $label__niew (optional)
     * @param  string[] $label__nisw (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $related_object_type (optional)
     * @param  string $related_object_type__n (optional)
     * @param  int[] $related_object_type_id (optional)
     * @param  int[] $related_object_type_id__n (optional)
     * @param  bool $required (optional)
     * @param  int[] $search_weight (optional)
     * @param  bool $search_weight__empty (optional)
     * @param  int[] $search_weight__gt (optional)
     * @param  int[] $search_weight__gte (optional)
     * @param  int[] $search_weight__lt (optional)
     * @param  int[] $search_weight__lte (optional)
     * @param  int[] $search_weight__n (optional)
     * @param  string[] $type The type of data this custom field holds (optional)
     * @param  string[] $type__n The type of data this custom field holds (optional)
     * @param  string $ui_editable Specifies whether the custom field value can be edited in the UI  * &#x60;yes&#x60; - Yes * &#x60;no&#x60; - No * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_editable__n Specifies whether the custom field value can be edited in the UI  * &#x60;yes&#x60; - Yes * &#x60;no&#x60; - No * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_visible Specifies whether the custom field is displayed in the UI  * &#x60;always&#x60; - Always * &#x60;if-set&#x60; - If set * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_visible__n Specifies whether the custom field is displayed in the UI  * &#x60;always&#x60; - Always * &#x60;if-set&#x60; - If set * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $validation_maximum (optional)
     * @param  bool $validation_maximum__empty (optional)
     * @param  int[] $validation_maximum__gt (optional)
     * @param  int[] $validation_maximum__gte (optional)
     * @param  int[] $validation_maximum__lt (optional)
     * @param  int[] $validation_maximum__lte (optional)
     * @param  int[] $validation_maximum__n (optional)
     * @param  int[] $validation_minimum (optional)
     * @param  bool $validation_minimum__empty (optional)
     * @param  int[] $validation_minimum__gt (optional)
     * @param  int[] $validation_minimum__gte (optional)
     * @param  int[] $validation_minimum__lt (optional)
     * @param  int[] $validation_minimum__lte (optional)
     * @param  int[] $validation_minimum__n (optional)
     * @param  string[] $validation_regex (optional)
     * @param  bool $validation_regex__empty (optional)
     * @param  string[] $validation_regex__ic (optional)
     * @param  string[] $validation_regex__ie (optional)
     * @param  string[] $validation_regex__iew (optional)
     * @param  string[] $validation_regex__isw (optional)
     * @param  string[] $validation_regex__n (optional)
     * @param  string[] $validation_regex__nic (optional)
     * @param  string[] $validation_regex__nie (optional)
     * @param  string[] $validation_regex__niew (optional)
     * @param  string[] $validation_regex__nisw (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsListAsyncWithHttpInfo($choice_set = null, $choice_set__n = null, $choice_set_id = null, $choice_set_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $filter_logic = null, $filter_logic__n = null, $group_name = null, $group_name__empty = null, $group_name__ic = null, $group_name__ie = null, $group_name__iew = null, $group_name__isw = null, $group_name__n = null, $group_name__nic = null, $group_name__nie = null, $group_name__niew = null, $group_name__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_cloneable = null, $label = null, $label__empty = null, $label__ic = null, $label__ie = null, $label__iew = null, $label__isw = null, $label__n = null, $label__nic = null, $label__nie = null, $label__niew = null, $label__nisw = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $related_object_type = null, $related_object_type__n = null, $related_object_type_id = null, $related_object_type_id__n = null, $required = null, $search_weight = null, $search_weight__empty = null, $search_weight__gt = null, $search_weight__gte = null, $search_weight__lt = null, $search_weight__lte = null, $search_weight__n = null, $type = null, $type__n = null, $ui_editable = null, $ui_editable__n = null, $ui_visible = null, $ui_visible__n = null, $updated_by_request = null, $validation_maximum = null, $validation_maximum__empty = null, $validation_maximum__gt = null, $validation_maximum__gte = null, $validation_maximum__lt = null, $validation_maximum__lte = null, $validation_maximum__n = null, $validation_minimum = null, $validation_minimum__empty = null, $validation_minimum__gt = null, $validation_minimum__gte = null, $validation_minimum__lt = null, $validation_minimum__lte = null, $validation_minimum__n = null, $validation_regex = null, $validation_regex__empty = null, $validation_regex__ic = null, $validation_regex__ie = null, $validation_regex__iew = null, $validation_regex__isw = null, $validation_regex__n = null, $validation_regex__nic = null, $validation_regex__nie = null, $validation_regex__niew = null, $validation_regex__nisw = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasCustomFieldsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedCustomFieldList';
        $request = $this->extrasCustomFieldsListRequest($choice_set, $choice_set__n, $choice_set_id, $choice_set_id__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $filter_logic, $filter_logic__n, $group_name, $group_name__empty, $group_name__ic, $group_name__ie, $group_name__iew, $group_name__isw, $group_name__n, $group_name__nic, $group_name__nie, $group_name__niew, $group_name__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_cloneable, $label, $label__empty, $label__ic, $label__ie, $label__iew, $label__isw, $label__n, $label__nic, $label__nie, $label__niew, $label__nisw, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $related_object_type, $related_object_type__n, $related_object_type_id, $related_object_type_id__n, $required, $search_weight, $search_weight__empty, $search_weight__gt, $search_weight__gte, $search_weight__lt, $search_weight__lte, $search_weight__n, $type, $type__n, $ui_editable, $ui_editable__n, $ui_visible, $ui_visible__n, $updated_by_request, $validation_maximum, $validation_maximum__empty, $validation_maximum__gt, $validation_maximum__gte, $validation_maximum__lt, $validation_maximum__lte, $validation_maximum__n, $validation_minimum, $validation_minimum__empty, $validation_minimum__gt, $validation_minimum__gte, $validation_minimum__lt, $validation_minimum__lte, $validation_minimum__n, $validation_regex, $validation_regex__empty, $validation_regex__ic, $validation_regex__ie, $validation_regex__iew, $validation_regex__isw, $validation_regex__n, $validation_regex__nic, $validation_regex__nie, $validation_regex__niew, $validation_regex__nisw, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldsList'
     *
     * @param  string[] $choice_set (optional)
     * @param  string[] $choice_set__n (optional)
     * @param  int[] $choice_set_id (optional)
     * @param  int[] $choice_set_id__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string $filter_logic Loose matches any instance of a given string; exact matches the entire field.  * &#x60;disabled&#x60; - Disabled * &#x60;loose&#x60; - Loose * &#x60;exact&#x60; - Exact (optional)
     * @param  string $filter_logic__n Loose matches any instance of a given string; exact matches the entire field.  * &#x60;disabled&#x60; - Disabled * &#x60;loose&#x60; - Loose * &#x60;exact&#x60; - Exact (optional)
     * @param  string[] $group_name (optional)
     * @param  bool $group_name__empty (optional)
     * @param  string[] $group_name__ic (optional)
     * @param  string[] $group_name__ie (optional)
     * @param  string[] $group_name__iew (optional)
     * @param  string[] $group_name__isw (optional)
     * @param  string[] $group_name__n (optional)
     * @param  string[] $group_name__nic (optional)
     * @param  string[] $group_name__nie (optional)
     * @param  string[] $group_name__niew (optional)
     * @param  string[] $group_name__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_cloneable (optional)
     * @param  string[] $label (optional)
     * @param  bool $label__empty (optional)
     * @param  string[] $label__ic (optional)
     * @param  string[] $label__ie (optional)
     * @param  string[] $label__iew (optional)
     * @param  string[] $label__isw (optional)
     * @param  string[] $label__n (optional)
     * @param  string[] $label__nic (optional)
     * @param  string[] $label__nie (optional)
     * @param  string[] $label__niew (optional)
     * @param  string[] $label__nisw (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $related_object_type (optional)
     * @param  string $related_object_type__n (optional)
     * @param  int[] $related_object_type_id (optional)
     * @param  int[] $related_object_type_id__n (optional)
     * @param  bool $required (optional)
     * @param  int[] $search_weight (optional)
     * @param  bool $search_weight__empty (optional)
     * @param  int[] $search_weight__gt (optional)
     * @param  int[] $search_weight__gte (optional)
     * @param  int[] $search_weight__lt (optional)
     * @param  int[] $search_weight__lte (optional)
     * @param  int[] $search_weight__n (optional)
     * @param  string[] $type The type of data this custom field holds (optional)
     * @param  string[] $type__n The type of data this custom field holds (optional)
     * @param  string $ui_editable Specifies whether the custom field value can be edited in the UI  * &#x60;yes&#x60; - Yes * &#x60;no&#x60; - No * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_editable__n Specifies whether the custom field value can be edited in the UI  * &#x60;yes&#x60; - Yes * &#x60;no&#x60; - No * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_visible Specifies whether the custom field is displayed in the UI  * &#x60;always&#x60; - Always * &#x60;if-set&#x60; - If set * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $ui_visible__n Specifies whether the custom field is displayed in the UI  * &#x60;always&#x60; - Always * &#x60;if-set&#x60; - If set * &#x60;hidden&#x60; - Hidden (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $validation_maximum (optional)
     * @param  bool $validation_maximum__empty (optional)
     * @param  int[] $validation_maximum__gt (optional)
     * @param  int[] $validation_maximum__gte (optional)
     * @param  int[] $validation_maximum__lt (optional)
     * @param  int[] $validation_maximum__lte (optional)
     * @param  int[] $validation_maximum__n (optional)
     * @param  int[] $validation_minimum (optional)
     * @param  bool $validation_minimum__empty (optional)
     * @param  int[] $validation_minimum__gt (optional)
     * @param  int[] $validation_minimum__gte (optional)
     * @param  int[] $validation_minimum__lt (optional)
     * @param  int[] $validation_minimum__lte (optional)
     * @param  int[] $validation_minimum__n (optional)
     * @param  string[] $validation_regex (optional)
     * @param  bool $validation_regex__empty (optional)
     * @param  string[] $validation_regex__ic (optional)
     * @param  string[] $validation_regex__ie (optional)
     * @param  string[] $validation_regex__iew (optional)
     * @param  string[] $validation_regex__isw (optional)
     * @param  string[] $validation_regex__n (optional)
     * @param  string[] $validation_regex__nic (optional)
     * @param  string[] $validation_regex__nie (optional)
     * @param  string[] $validation_regex__niew (optional)
     * @param  string[] $validation_regex__nisw (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldsListRequest($choice_set = null, $choice_set__n = null, $choice_set_id = null, $choice_set_id__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $filter_logic = null, $filter_logic__n = null, $group_name = null, $group_name__empty = null, $group_name__ic = null, $group_name__ie = null, $group_name__iew = null, $group_name__isw = null, $group_name__n = null, $group_name__nic = null, $group_name__nie = null, $group_name__niew = null, $group_name__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_cloneable = null, $label = null, $label__empty = null, $label__ic = null, $label__ie = null, $label__iew = null, $label__isw = null, $label__n = null, $label__nic = null, $label__nie = null, $label__niew = null, $label__nisw = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $related_object_type = null, $related_object_type__n = null, $related_object_type_id = null, $related_object_type_id__n = null, $required = null, $search_weight = null, $search_weight__empty = null, $search_weight__gt = null, $search_weight__gte = null, $search_weight__lt = null, $search_weight__lte = null, $search_weight__n = null, $type = null, $type__n = null, $ui_editable = null, $ui_editable__n = null, $ui_visible = null, $ui_visible__n = null, $updated_by_request = null, $validation_maximum = null, $validation_maximum__empty = null, $validation_maximum__gt = null, $validation_maximum__gte = null, $validation_maximum__lt = null, $validation_maximum__lte = null, $validation_maximum__n = null, $validation_minimum = null, $validation_minimum__empty = null, $validation_minimum__gt = null, $validation_minimum__gte = null, $validation_minimum__lt = null, $validation_minimum__lte = null, $validation_minimum__n = null, $validation_regex = null, $validation_regex__empty = null, $validation_regex__ic = null, $validation_regex__ie = null, $validation_regex__iew = null, $validation_regex__isw = null, $validation_regex__n = null, $validation_regex__nic = null, $validation_regex__nie = null, $validation_regex__niew = null, $validation_regex__nisw = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasCustomFieldsList'][0])
    {















































































































































        $resourcePath = '/api/extras/custom-fields/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $choice_set,
            'choice_set', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $choice_set__n,
            'choice_set__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $choice_set_id,
            'choice_set_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $choice_set_id__n,
            'choice_set_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_logic,
            'filter_logic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_logic__n,
            'filter_logic__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name,
            'group_name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__empty,
            'group_name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__ic,
            'group_name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__ie,
            'group_name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__iew,
            'group_name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__isw,
            'group_name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__n,
            'group_name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__nic,
            'group_name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__nie,
            'group_name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__niew,
            'group_name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__nisw,
            'group_name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_cloneable,
            'is_cloneable', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label,
            'label', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label__empty,
            'label__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label__ic,
            'label__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label__ie,
            'label__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label__iew,
            'label__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label__isw,
            'label__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label__n,
            'label__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label__nic,
            'label__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label__nie,
            'label__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label__niew,
            'label__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label__nisw,
            'label__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type,
            'object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ic,
            'object_type__ic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ie,
            'object_type__ie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__iew,
            'object_type__iew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__isw,
            'object_type__isw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__n,
            'object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nic,
            'object_type__nic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nie,
            'object_type__nie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__niew,
            'object_type__niew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nisw,
            'object_type__nisw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id,
            'object_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__n,
            'object_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_type,
            'related_object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_type__n,
            'related_object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_type_id,
            'related_object_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_type_id__n,
            'related_object_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $required,
            'required', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_weight,
            'search_weight', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_weight__empty,
            'search_weight__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_weight__gt,
            'search_weight__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_weight__gte,
            'search_weight__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_weight__lt,
            'search_weight__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_weight__lte,
            'search_weight__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_weight__n,
            'search_weight__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type__n,
            'type__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ui_editable,
            'ui_editable', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ui_editable__n,
            'ui_editable__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ui_visible,
            'ui_visible', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ui_visible__n,
            'ui_visible__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_maximum,
            'validation_maximum', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_maximum__empty,
            'validation_maximum__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_maximum__gt,
            'validation_maximum__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_maximum__gte,
            'validation_maximum__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_maximum__lt,
            'validation_maximum__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_maximum__lte,
            'validation_maximum__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_maximum__n,
            'validation_maximum__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_minimum,
            'validation_minimum', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_minimum__empty,
            'validation_minimum__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_minimum__gt,
            'validation_minimum__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_minimum__gte,
            'validation_minimum__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_minimum__lt,
            'validation_minimum__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_minimum__lte,
            'validation_minimum__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_minimum__n,
            'validation_minimum__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_regex,
            'validation_regex', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_regex__empty,
            'validation_regex__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_regex__ic,
            'validation_regex__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_regex__ie,
            'validation_regex__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_regex__iew,
            'validation_regex__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_regex__isw,
            'validation_regex__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_regex__n,
            'validation_regex__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_regex__nic,
            'validation_regex__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_regex__nie,
            'validation_regex__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_regex__niew,
            'validation_regex__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validation_regex__nisw,
            'validation_regex__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight,
            'weight', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__empty,
            'weight__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__gt,
            'weight__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__gte,
            'weight__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__lt,
            'weight__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__lte,
            'weight__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__n,
            'weight__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCustomFieldRequest $patched_writable_custom_field_request patched_writable_custom_field_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomField
     */
    public function extrasCustomFieldsPartialUpdate($id, $patched_writable_custom_field_request = null, string $contentType = self::contentTypes['extrasCustomFieldsPartialUpdate'][0])
    {
        list($response) = $this->extrasCustomFieldsPartialUpdateWithHttpInfo($id, $patched_writable_custom_field_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCustomFieldRequest $patched_writable_custom_field_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomField, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldsPartialUpdateWithHttpInfo($id, $patched_writable_custom_field_request = null, string $contentType = self::contentTypes['extrasCustomFieldsPartialUpdate'][0])
    {
        $request = $this->extrasCustomFieldsPartialUpdateRequest($id, $patched_writable_custom_field_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomField' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomField' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomField', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomField';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomField',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCustomFieldRequest $patched_writable_custom_field_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsPartialUpdateAsync($id, $patched_writable_custom_field_request = null, string $contentType = self::contentTypes['extrasCustomFieldsPartialUpdate'][0])
    {
        return $this->extrasCustomFieldsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_custom_field_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCustomFieldRequest $patched_writable_custom_field_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsPartialUpdateAsyncWithHttpInfo($id, $patched_writable_custom_field_request = null, string $contentType = self::contentTypes['extrasCustomFieldsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomField';
        $request = $this->extrasCustomFieldsPartialUpdateRequest($id, $patched_writable_custom_field_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableCustomFieldRequest $patched_writable_custom_field_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldsPartialUpdateRequest($id, $patched_writable_custom_field_request = null, string $contentType = self::contentTypes['extrasCustomFieldsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomFieldsPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/custom-fields/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_custom_field_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_custom_field_request));
            } else {
                $httpBody = $patched_writable_custom_field_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldsRetrieve
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomField
     */
    public function extrasCustomFieldsRetrieve($id, string $contentType = self::contentTypes['extrasCustomFieldsRetrieve'][0])
    {
        list($response) = $this->extrasCustomFieldsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomField, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomFieldsRetrieve'][0])
    {
        $request = $this->extrasCustomFieldsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomField' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomField' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomField', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomField';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomField',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsRetrieveAsync($id, string $contentType = self::contentTypes['extrasCustomFieldsRetrieve'][0])
    {
        return $this->extrasCustomFieldsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomFieldsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomField';
        $request = $this->extrasCustomFieldsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldsRetrieve'
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldsRetrieveRequest($id, string $contentType = self::contentTypes['extrasCustomFieldsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomFieldsRetrieve'
            );
        }


        $resourcePath = '/api/extras/custom-fields/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomFieldsUpdate
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  \OpenAPI\Client\Model\WritableCustomFieldRequest $writable_custom_field_request writable_custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomField
     */
    public function extrasCustomFieldsUpdate($id, $writable_custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsUpdate'][0])
    {
        list($response) = $this->extrasCustomFieldsUpdateWithHttpInfo($id, $writable_custom_field_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomFieldsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  \OpenAPI\Client\Model\WritableCustomFieldRequest $writable_custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomField, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomFieldsUpdateWithHttpInfo($id, $writable_custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsUpdate'][0])
    {
        $request = $this->extrasCustomFieldsUpdateRequest($id, $writable_custom_field_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomField' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomField' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomField', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomField';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomField',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomFieldsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  \OpenAPI\Client\Model\WritableCustomFieldRequest $writable_custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsUpdateAsync($id, $writable_custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsUpdate'][0])
    {
        return $this->extrasCustomFieldsUpdateAsyncWithHttpInfo($id, $writable_custom_field_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomFieldsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  \OpenAPI\Client\Model\WritableCustomFieldRequest $writable_custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomFieldsUpdateAsyncWithHttpInfo($id, $writable_custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomField';
        $request = $this->extrasCustomFieldsUpdateRequest($id, $writable_custom_field_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomFieldsUpdate'
     *
     * @param  int $id A unique integer value identifying this custom field. (required)
     * @param  \OpenAPI\Client\Model\WritableCustomFieldRequest $writable_custom_field_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomFieldsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomFieldsUpdateRequest($id, $writable_custom_field_request, string $contentType = self::contentTypes['extrasCustomFieldsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomFieldsUpdate'
            );
        }

        // verify the required parameter 'writable_custom_field_request' is set
        if ($writable_custom_field_request === null || (is_array($writable_custom_field_request) && count($writable_custom_field_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_custom_field_request when calling extrasCustomFieldsUpdate'
            );
        }


        $resourcePath = '/api/extras/custom-fields/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_custom_field_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_custom_field_request));
            } else {
                $httpBody = $writable_custom_field_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomLinksBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasCustomLinksBulkDestroy($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkDestroy'][0])
    {
        $this->extrasCustomLinksBulkDestroyWithHttpInfo($custom_link_request, $contentType);
    }

    /**
     * Operation extrasCustomLinksBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomLinksBulkDestroyWithHttpInfo($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkDestroy'][0])
    {
        $request = $this->extrasCustomLinksBulkDestroyRequest($custom_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomLinksBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksBulkDestroyAsync($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkDestroy'][0])
    {
        return $this->extrasCustomLinksBulkDestroyAsyncWithHttpInfo($custom_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomLinksBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksBulkDestroyAsyncWithHttpInfo($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasCustomLinksBulkDestroyRequest($custom_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomLinksBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomLinksBulkDestroyRequest($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkDestroy'][0])
    {

        // verify the required parameter 'custom_link_request' is set
        if ($custom_link_request === null || (is_array($custom_link_request) && count($custom_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_link_request when calling extrasCustomLinksBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/custom-links/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_link_request));
            } else {
                $httpBody = $custom_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomLinksBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomLink[]
     */
    public function extrasCustomLinksBulkPartialUpdate($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasCustomLinksBulkPartialUpdateWithHttpInfo($custom_link_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomLinksBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomLink[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomLinksBulkPartialUpdateWithHttpInfo($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkPartialUpdate'][0])
    {
        $request = $this->extrasCustomLinksBulkPartialUpdateRequest($custom_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomLink[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomLink[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomLink[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomLink[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomLink[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomLinksBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksBulkPartialUpdateAsync($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkPartialUpdate'][0])
    {
        return $this->extrasCustomLinksBulkPartialUpdateAsyncWithHttpInfo($custom_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomLinksBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksBulkPartialUpdateAsyncWithHttpInfo($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomLink[]';
        $request = $this->extrasCustomLinksBulkPartialUpdateRequest($custom_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomLinksBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomLinksBulkPartialUpdateRequest($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkPartialUpdate'][0])
    {

        // verify the required parameter 'custom_link_request' is set
        if ($custom_link_request === null || (is_array($custom_link_request) && count($custom_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_link_request when calling extrasCustomLinksBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/custom-links/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_link_request));
            } else {
                $httpBody = $custom_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomLinksBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomLink[]
     */
    public function extrasCustomLinksBulkUpdate($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkUpdate'][0])
    {
        list($response) = $this->extrasCustomLinksBulkUpdateWithHttpInfo($custom_link_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomLinksBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomLink[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomLinksBulkUpdateWithHttpInfo($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkUpdate'][0])
    {
        $request = $this->extrasCustomLinksBulkUpdateRequest($custom_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomLink[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomLink[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomLink[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomLink[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomLink[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomLinksBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksBulkUpdateAsync($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkUpdate'][0])
    {
        return $this->extrasCustomLinksBulkUpdateAsyncWithHttpInfo($custom_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomLinksBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksBulkUpdateAsyncWithHttpInfo($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomLink[]';
        $request = $this->extrasCustomLinksBulkUpdateRequest($custom_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomLinksBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest[] $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomLinksBulkUpdateRequest($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksBulkUpdate'][0])
    {

        // verify the required parameter 'custom_link_request' is set
        if ($custom_link_request === null || (is_array($custom_link_request) && count($custom_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_link_request when calling extrasCustomLinksBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/custom-links/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_link_request));
            } else {
                $httpBody = $custom_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomLinksCreate
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest $custom_link_request custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomLink
     */
    public function extrasCustomLinksCreate($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksCreate'][0])
    {
        list($response) = $this->extrasCustomLinksCreateWithHttpInfo($custom_link_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomLinksCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomLinksCreateWithHttpInfo($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksCreate'][0])
    {
        $request = $this->extrasCustomLinksCreateRequest($custom_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\CustomLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomLinksCreateAsync
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksCreateAsync($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksCreate'][0])
    {
        return $this->extrasCustomLinksCreateAsyncWithHttpInfo($custom_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomLinksCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksCreateAsyncWithHttpInfo($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomLink';
        $request = $this->extrasCustomLinksCreateRequest($custom_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomLinksCreate'
     *
     * @param  \OpenAPI\Client\Model\CustomLinkRequest $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomLinksCreateRequest($custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksCreate'][0])
    {

        // verify the required parameter 'custom_link_request' is set
        if ($custom_link_request === null || (is_array($custom_link_request) && count($custom_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_link_request when calling extrasCustomLinksCreate'
            );
        }


        $resourcePath = '/api/extras/custom-links/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_link_request));
            } else {
                $httpBody = $custom_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomLinksDestroy
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasCustomLinksDestroy($id, string $contentType = self::contentTypes['extrasCustomLinksDestroy'][0])
    {
        $this->extrasCustomLinksDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasCustomLinksDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomLinksDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomLinksDestroy'][0])
    {
        $request = $this->extrasCustomLinksDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomLinksDestroyAsync
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksDestroyAsync($id, string $contentType = self::contentTypes['extrasCustomLinksDestroy'][0])
    {
        return $this->extrasCustomLinksDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomLinksDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomLinksDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasCustomLinksDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomLinksDestroy'
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomLinksDestroyRequest($id, string $contentType = self::contentTypes['extrasCustomLinksDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomLinksDestroy'
            );
        }


        $resourcePath = '/api/extras/custom-links/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomLinksList
     *
     * @param  string $button_class The class of the first link in a group will be used for the dropdown button  * &#x60;outline-dark&#x60; - Default * &#x60;blue&#x60; - Blue * &#x60;indigo&#x60; - Indigo * &#x60;purple&#x60; - Purple * &#x60;pink&#x60; - Pink * &#x60;red&#x60; - Red * &#x60;orange&#x60; - Orange * &#x60;yellow&#x60; - Yellow * &#x60;green&#x60; - Green * &#x60;teal&#x60; - Teal * &#x60;cyan&#x60; - Cyan * &#x60;gray&#x60; - Gray * &#x60;black&#x60; - Black * &#x60;white&#x60; - White * &#x60;ghost-dark&#x60; - Link (optional)
     * @param  string $button_class__n The class of the first link in a group will be used for the dropdown button  * &#x60;outline-dark&#x60; - Default * &#x60;blue&#x60; - Blue * &#x60;indigo&#x60; - Indigo * &#x60;purple&#x60; - Purple * &#x60;pink&#x60; - Pink * &#x60;red&#x60; - Red * &#x60;orange&#x60; - Orange * &#x60;yellow&#x60; - Yellow * &#x60;green&#x60; - Green * &#x60;teal&#x60; - Teal * &#x60;cyan&#x60; - Cyan * &#x60;gray&#x60; - Gray * &#x60;black&#x60; - Black * &#x60;white&#x60; - White * &#x60;ghost-dark&#x60; - Link (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  bool $enabled enabled (optional)
     * @param  string[] $group_name group_name (optional)
     * @param  bool $group_name__empty group_name__empty (optional)
     * @param  string[] $group_name__ic group_name__ic (optional)
     * @param  string[] $group_name__ie group_name__ie (optional)
     * @param  string[] $group_name__iew group_name__iew (optional)
     * @param  string[] $group_name__isw group_name__isw (optional)
     * @param  string[] $group_name__n group_name__n (optional)
     * @param  string[] $group_name__nic group_name__nic (optional)
     * @param  string[] $group_name__nie group_name__nie (optional)
     * @param  string[] $group_name__niew group_name__niew (optional)
     * @param  string[] $group_name__nisw group_name__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $link_text link_text (optional)
     * @param  string $link_text__ic link_text__ic (optional)
     * @param  string $link_text__ie link_text__ie (optional)
     * @param  string $link_text__iew link_text__iew (optional)
     * @param  string $link_text__isw link_text__isw (optional)
     * @param  string $link_text__n link_text__n (optional)
     * @param  string $link_text__nic link_text__nic (optional)
     * @param  string $link_text__nie link_text__nie (optional)
     * @param  string $link_text__niew link_text__niew (optional)
     * @param  string $link_text__nisw link_text__nisw (optional)
     * @param  string $link_url link_url (optional)
     * @param  string $link_url__ic link_url__ic (optional)
     * @param  string $link_url__ie link_url__ie (optional)
     * @param  string $link_url__iew link_url__iew (optional)
     * @param  string $link_url__isw link_url__isw (optional)
     * @param  string $link_url__n link_url__n (optional)
     * @param  string $link_url__nic link_url__nic (optional)
     * @param  string $link_url__nie link_url__nie (optional)
     * @param  string $link_url__niew link_url__niew (optional)
     * @param  string $link_url__nisw link_url__nisw (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  bool $new_window new_window (optional)
     * @param  string $object_type object_type (optional)
     * @param  string $object_type__ic object_type__ic (optional)
     * @param  string $object_type__ie object_type__ie (optional)
     * @param  string $object_type__iew object_type__iew (optional)
     * @param  string $object_type__isw object_type__isw (optional)
     * @param  string $object_type__n object_type__n (optional)
     * @param  string $object_type__nic object_type__nic (optional)
     * @param  string $object_type__nie object_type__nie (optional)
     * @param  string $object_type__niew object_type__niew (optional)
     * @param  string $object_type__nisw object_type__nisw (optional)
     * @param  int[] $object_type_id object_type_id (optional)
     * @param  int[] $object_type_id__n object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  int[] $weight weight (optional)
     * @param  bool $weight__empty weight__empty (optional)
     * @param  int[] $weight__gt weight__gt (optional)
     * @param  int[] $weight__gte weight__gte (optional)
     * @param  int[] $weight__lt weight__lt (optional)
     * @param  int[] $weight__lte weight__lte (optional)
     * @param  int[] $weight__n weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedCustomLinkList
     */
    public function extrasCustomLinksList($button_class = null, $button_class__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $enabled = null, $group_name = null, $group_name__empty = null, $group_name__ic = null, $group_name__ie = null, $group_name__iew = null, $group_name__isw = null, $group_name__n = null, $group_name__nic = null, $group_name__nie = null, $group_name__niew = null, $group_name__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $link_text = null, $link_text__ic = null, $link_text__ie = null, $link_text__iew = null, $link_text__isw = null, $link_text__n = null, $link_text__nic = null, $link_text__nie = null, $link_text__niew = null, $link_text__nisw = null, $link_url = null, $link_url__ic = null, $link_url__ie = null, $link_url__iew = null, $link_url__isw = null, $link_url__n = null, $link_url__nic = null, $link_url__nie = null, $link_url__niew = null, $link_url__nisw = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $new_window = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasCustomLinksList'][0])
    {
        list($response) = $this->extrasCustomLinksListWithHttpInfo($button_class, $button_class__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $enabled, $group_name, $group_name__empty, $group_name__ic, $group_name__ie, $group_name__iew, $group_name__isw, $group_name__n, $group_name__nic, $group_name__nie, $group_name__niew, $group_name__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $link_text, $link_text__ic, $link_text__ie, $link_text__iew, $link_text__isw, $link_text__n, $link_text__nic, $link_text__nie, $link_text__niew, $link_text__nisw, $link_url, $link_url__ic, $link_url__ie, $link_url__iew, $link_url__isw, $link_url__n, $link_url__nic, $link_url__nie, $link_url__niew, $link_url__nisw, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $new_window, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomLinksListWithHttpInfo
     *
     * @param  string $button_class The class of the first link in a group will be used for the dropdown button  * &#x60;outline-dark&#x60; - Default * &#x60;blue&#x60; - Blue * &#x60;indigo&#x60; - Indigo * &#x60;purple&#x60; - Purple * &#x60;pink&#x60; - Pink * &#x60;red&#x60; - Red * &#x60;orange&#x60; - Orange * &#x60;yellow&#x60; - Yellow * &#x60;green&#x60; - Green * &#x60;teal&#x60; - Teal * &#x60;cyan&#x60; - Cyan * &#x60;gray&#x60; - Gray * &#x60;black&#x60; - Black * &#x60;white&#x60; - White * &#x60;ghost-dark&#x60; - Link (optional)
     * @param  string $button_class__n The class of the first link in a group will be used for the dropdown button  * &#x60;outline-dark&#x60; - Default * &#x60;blue&#x60; - Blue * &#x60;indigo&#x60; - Indigo * &#x60;purple&#x60; - Purple * &#x60;pink&#x60; - Pink * &#x60;red&#x60; - Red * &#x60;orange&#x60; - Orange * &#x60;yellow&#x60; - Yellow * &#x60;green&#x60; - Green * &#x60;teal&#x60; - Teal * &#x60;cyan&#x60; - Cyan * &#x60;gray&#x60; - Gray * &#x60;black&#x60; - Black * &#x60;white&#x60; - White * &#x60;ghost-dark&#x60; - Link (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  bool $enabled (optional)
     * @param  string[] $group_name (optional)
     * @param  bool $group_name__empty (optional)
     * @param  string[] $group_name__ic (optional)
     * @param  string[] $group_name__ie (optional)
     * @param  string[] $group_name__iew (optional)
     * @param  string[] $group_name__isw (optional)
     * @param  string[] $group_name__n (optional)
     * @param  string[] $group_name__nic (optional)
     * @param  string[] $group_name__nie (optional)
     * @param  string[] $group_name__niew (optional)
     * @param  string[] $group_name__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $link_text (optional)
     * @param  string $link_text__ic (optional)
     * @param  string $link_text__ie (optional)
     * @param  string $link_text__iew (optional)
     * @param  string $link_text__isw (optional)
     * @param  string $link_text__n (optional)
     * @param  string $link_text__nic (optional)
     * @param  string $link_text__nie (optional)
     * @param  string $link_text__niew (optional)
     * @param  string $link_text__nisw (optional)
     * @param  string $link_url (optional)
     * @param  string $link_url__ic (optional)
     * @param  string $link_url__ie (optional)
     * @param  string $link_url__iew (optional)
     * @param  string $link_url__isw (optional)
     * @param  string $link_url__n (optional)
     * @param  string $link_url__nic (optional)
     * @param  string $link_url__nie (optional)
     * @param  string $link_url__niew (optional)
     * @param  string $link_url__nisw (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  bool $new_window (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedCustomLinkList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomLinksListWithHttpInfo($button_class = null, $button_class__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $enabled = null, $group_name = null, $group_name__empty = null, $group_name__ic = null, $group_name__ie = null, $group_name__iew = null, $group_name__isw = null, $group_name__n = null, $group_name__nic = null, $group_name__nie = null, $group_name__niew = null, $group_name__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $link_text = null, $link_text__ic = null, $link_text__ie = null, $link_text__iew = null, $link_text__isw = null, $link_text__n = null, $link_text__nic = null, $link_text__nie = null, $link_text__niew = null, $link_text__nisw = null, $link_url = null, $link_url__ic = null, $link_url__ie = null, $link_url__iew = null, $link_url__isw = null, $link_url__n = null, $link_url__nic = null, $link_url__nie = null, $link_url__niew = null, $link_url__nisw = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $new_window = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasCustomLinksList'][0])
    {
        $request = $this->extrasCustomLinksListRequest($button_class, $button_class__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $enabled, $group_name, $group_name__empty, $group_name__ic, $group_name__ie, $group_name__iew, $group_name__isw, $group_name__n, $group_name__nic, $group_name__nie, $group_name__niew, $group_name__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $link_text, $link_text__ic, $link_text__ie, $link_text__iew, $link_text__isw, $link_text__n, $link_text__nic, $link_text__nie, $link_text__niew, $link_text__nisw, $link_url, $link_url__ic, $link_url__ie, $link_url__iew, $link_url__isw, $link_url__n, $link_url__nic, $link_url__nie, $link_url__niew, $link_url__nisw, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $new_window, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedCustomLinkList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedCustomLinkList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedCustomLinkList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedCustomLinkList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedCustomLinkList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomLinksListAsync
     *
     * @param  string $button_class The class of the first link in a group will be used for the dropdown button  * &#x60;outline-dark&#x60; - Default * &#x60;blue&#x60; - Blue * &#x60;indigo&#x60; - Indigo * &#x60;purple&#x60; - Purple * &#x60;pink&#x60; - Pink * &#x60;red&#x60; - Red * &#x60;orange&#x60; - Orange * &#x60;yellow&#x60; - Yellow * &#x60;green&#x60; - Green * &#x60;teal&#x60; - Teal * &#x60;cyan&#x60; - Cyan * &#x60;gray&#x60; - Gray * &#x60;black&#x60; - Black * &#x60;white&#x60; - White * &#x60;ghost-dark&#x60; - Link (optional)
     * @param  string $button_class__n The class of the first link in a group will be used for the dropdown button  * &#x60;outline-dark&#x60; - Default * &#x60;blue&#x60; - Blue * &#x60;indigo&#x60; - Indigo * &#x60;purple&#x60; - Purple * &#x60;pink&#x60; - Pink * &#x60;red&#x60; - Red * &#x60;orange&#x60; - Orange * &#x60;yellow&#x60; - Yellow * &#x60;green&#x60; - Green * &#x60;teal&#x60; - Teal * &#x60;cyan&#x60; - Cyan * &#x60;gray&#x60; - Gray * &#x60;black&#x60; - Black * &#x60;white&#x60; - White * &#x60;ghost-dark&#x60; - Link (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  bool $enabled (optional)
     * @param  string[] $group_name (optional)
     * @param  bool $group_name__empty (optional)
     * @param  string[] $group_name__ic (optional)
     * @param  string[] $group_name__ie (optional)
     * @param  string[] $group_name__iew (optional)
     * @param  string[] $group_name__isw (optional)
     * @param  string[] $group_name__n (optional)
     * @param  string[] $group_name__nic (optional)
     * @param  string[] $group_name__nie (optional)
     * @param  string[] $group_name__niew (optional)
     * @param  string[] $group_name__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $link_text (optional)
     * @param  string $link_text__ic (optional)
     * @param  string $link_text__ie (optional)
     * @param  string $link_text__iew (optional)
     * @param  string $link_text__isw (optional)
     * @param  string $link_text__n (optional)
     * @param  string $link_text__nic (optional)
     * @param  string $link_text__nie (optional)
     * @param  string $link_text__niew (optional)
     * @param  string $link_text__nisw (optional)
     * @param  string $link_url (optional)
     * @param  string $link_url__ic (optional)
     * @param  string $link_url__ie (optional)
     * @param  string $link_url__iew (optional)
     * @param  string $link_url__isw (optional)
     * @param  string $link_url__n (optional)
     * @param  string $link_url__nic (optional)
     * @param  string $link_url__nie (optional)
     * @param  string $link_url__niew (optional)
     * @param  string $link_url__nisw (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  bool $new_window (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksListAsync($button_class = null, $button_class__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $enabled = null, $group_name = null, $group_name__empty = null, $group_name__ic = null, $group_name__ie = null, $group_name__iew = null, $group_name__isw = null, $group_name__n = null, $group_name__nic = null, $group_name__nie = null, $group_name__niew = null, $group_name__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $link_text = null, $link_text__ic = null, $link_text__ie = null, $link_text__iew = null, $link_text__isw = null, $link_text__n = null, $link_text__nic = null, $link_text__nie = null, $link_text__niew = null, $link_text__nisw = null, $link_url = null, $link_url__ic = null, $link_url__ie = null, $link_url__iew = null, $link_url__isw = null, $link_url__n = null, $link_url__nic = null, $link_url__nie = null, $link_url__niew = null, $link_url__nisw = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $new_window = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasCustomLinksList'][0])
    {
        return $this->extrasCustomLinksListAsyncWithHttpInfo($button_class, $button_class__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $enabled, $group_name, $group_name__empty, $group_name__ic, $group_name__ie, $group_name__iew, $group_name__isw, $group_name__n, $group_name__nic, $group_name__nie, $group_name__niew, $group_name__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $link_text, $link_text__ic, $link_text__ie, $link_text__iew, $link_text__isw, $link_text__n, $link_text__nic, $link_text__nie, $link_text__niew, $link_text__nisw, $link_url, $link_url__ic, $link_url__ie, $link_url__iew, $link_url__isw, $link_url__n, $link_url__nic, $link_url__nie, $link_url__niew, $link_url__nisw, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $new_window, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomLinksListAsyncWithHttpInfo
     *
     * @param  string $button_class The class of the first link in a group will be used for the dropdown button  * &#x60;outline-dark&#x60; - Default * &#x60;blue&#x60; - Blue * &#x60;indigo&#x60; - Indigo * &#x60;purple&#x60; - Purple * &#x60;pink&#x60; - Pink * &#x60;red&#x60; - Red * &#x60;orange&#x60; - Orange * &#x60;yellow&#x60; - Yellow * &#x60;green&#x60; - Green * &#x60;teal&#x60; - Teal * &#x60;cyan&#x60; - Cyan * &#x60;gray&#x60; - Gray * &#x60;black&#x60; - Black * &#x60;white&#x60; - White * &#x60;ghost-dark&#x60; - Link (optional)
     * @param  string $button_class__n The class of the first link in a group will be used for the dropdown button  * &#x60;outline-dark&#x60; - Default * &#x60;blue&#x60; - Blue * &#x60;indigo&#x60; - Indigo * &#x60;purple&#x60; - Purple * &#x60;pink&#x60; - Pink * &#x60;red&#x60; - Red * &#x60;orange&#x60; - Orange * &#x60;yellow&#x60; - Yellow * &#x60;green&#x60; - Green * &#x60;teal&#x60; - Teal * &#x60;cyan&#x60; - Cyan * &#x60;gray&#x60; - Gray * &#x60;black&#x60; - Black * &#x60;white&#x60; - White * &#x60;ghost-dark&#x60; - Link (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  bool $enabled (optional)
     * @param  string[] $group_name (optional)
     * @param  bool $group_name__empty (optional)
     * @param  string[] $group_name__ic (optional)
     * @param  string[] $group_name__ie (optional)
     * @param  string[] $group_name__iew (optional)
     * @param  string[] $group_name__isw (optional)
     * @param  string[] $group_name__n (optional)
     * @param  string[] $group_name__nic (optional)
     * @param  string[] $group_name__nie (optional)
     * @param  string[] $group_name__niew (optional)
     * @param  string[] $group_name__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $link_text (optional)
     * @param  string $link_text__ic (optional)
     * @param  string $link_text__ie (optional)
     * @param  string $link_text__iew (optional)
     * @param  string $link_text__isw (optional)
     * @param  string $link_text__n (optional)
     * @param  string $link_text__nic (optional)
     * @param  string $link_text__nie (optional)
     * @param  string $link_text__niew (optional)
     * @param  string $link_text__nisw (optional)
     * @param  string $link_url (optional)
     * @param  string $link_url__ic (optional)
     * @param  string $link_url__ie (optional)
     * @param  string $link_url__iew (optional)
     * @param  string $link_url__isw (optional)
     * @param  string $link_url__n (optional)
     * @param  string $link_url__nic (optional)
     * @param  string $link_url__nie (optional)
     * @param  string $link_url__niew (optional)
     * @param  string $link_url__nisw (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  bool $new_window (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksListAsyncWithHttpInfo($button_class = null, $button_class__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $enabled = null, $group_name = null, $group_name__empty = null, $group_name__ic = null, $group_name__ie = null, $group_name__iew = null, $group_name__isw = null, $group_name__n = null, $group_name__nic = null, $group_name__nie = null, $group_name__niew = null, $group_name__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $link_text = null, $link_text__ic = null, $link_text__ie = null, $link_text__iew = null, $link_text__isw = null, $link_text__n = null, $link_text__nic = null, $link_text__nie = null, $link_text__niew = null, $link_text__nisw = null, $link_url = null, $link_url__ic = null, $link_url__ie = null, $link_url__iew = null, $link_url__isw = null, $link_url__n = null, $link_url__nic = null, $link_url__nie = null, $link_url__niew = null, $link_url__nisw = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $new_window = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasCustomLinksList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedCustomLinkList';
        $request = $this->extrasCustomLinksListRequest($button_class, $button_class__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $enabled, $group_name, $group_name__empty, $group_name__ic, $group_name__ie, $group_name__iew, $group_name__isw, $group_name__n, $group_name__nic, $group_name__nie, $group_name__niew, $group_name__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $link_text, $link_text__ic, $link_text__ie, $link_text__iew, $link_text__isw, $link_text__n, $link_text__nic, $link_text__nie, $link_text__niew, $link_text__nisw, $link_url, $link_url__ic, $link_url__ie, $link_url__iew, $link_url__isw, $link_url__n, $link_url__nic, $link_url__nie, $link_url__niew, $link_url__nisw, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $new_window, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomLinksList'
     *
     * @param  string $button_class The class of the first link in a group will be used for the dropdown button  * &#x60;outline-dark&#x60; - Default * &#x60;blue&#x60; - Blue * &#x60;indigo&#x60; - Indigo * &#x60;purple&#x60; - Purple * &#x60;pink&#x60; - Pink * &#x60;red&#x60; - Red * &#x60;orange&#x60; - Orange * &#x60;yellow&#x60; - Yellow * &#x60;green&#x60; - Green * &#x60;teal&#x60; - Teal * &#x60;cyan&#x60; - Cyan * &#x60;gray&#x60; - Gray * &#x60;black&#x60; - Black * &#x60;white&#x60; - White * &#x60;ghost-dark&#x60; - Link (optional)
     * @param  string $button_class__n The class of the first link in a group will be used for the dropdown button  * &#x60;outline-dark&#x60; - Default * &#x60;blue&#x60; - Blue * &#x60;indigo&#x60; - Indigo * &#x60;purple&#x60; - Purple * &#x60;pink&#x60; - Pink * &#x60;red&#x60; - Red * &#x60;orange&#x60; - Orange * &#x60;yellow&#x60; - Yellow * &#x60;green&#x60; - Green * &#x60;teal&#x60; - Teal * &#x60;cyan&#x60; - Cyan * &#x60;gray&#x60; - Gray * &#x60;black&#x60; - Black * &#x60;white&#x60; - White * &#x60;ghost-dark&#x60; - Link (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  bool $enabled (optional)
     * @param  string[] $group_name (optional)
     * @param  bool $group_name__empty (optional)
     * @param  string[] $group_name__ic (optional)
     * @param  string[] $group_name__ie (optional)
     * @param  string[] $group_name__iew (optional)
     * @param  string[] $group_name__isw (optional)
     * @param  string[] $group_name__n (optional)
     * @param  string[] $group_name__nic (optional)
     * @param  string[] $group_name__nie (optional)
     * @param  string[] $group_name__niew (optional)
     * @param  string[] $group_name__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $link_text (optional)
     * @param  string $link_text__ic (optional)
     * @param  string $link_text__ie (optional)
     * @param  string $link_text__iew (optional)
     * @param  string $link_text__isw (optional)
     * @param  string $link_text__n (optional)
     * @param  string $link_text__nic (optional)
     * @param  string $link_text__nie (optional)
     * @param  string $link_text__niew (optional)
     * @param  string $link_text__nisw (optional)
     * @param  string $link_url (optional)
     * @param  string $link_url__ic (optional)
     * @param  string $link_url__ie (optional)
     * @param  string $link_url__iew (optional)
     * @param  string $link_url__isw (optional)
     * @param  string $link_url__n (optional)
     * @param  string $link_url__nic (optional)
     * @param  string $link_url__nie (optional)
     * @param  string $link_url__niew (optional)
     * @param  string $link_url__nisw (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  bool $new_window (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomLinksListRequest($button_class = null, $button_class__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $enabled = null, $group_name = null, $group_name__empty = null, $group_name__ic = null, $group_name__ie = null, $group_name__iew = null, $group_name__isw = null, $group_name__n = null, $group_name__nic = null, $group_name__nie = null, $group_name__niew = null, $group_name__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $link_text = null, $link_text__ic = null, $link_text__ie = null, $link_text__iew = null, $link_text__isw = null, $link_text__n = null, $link_text__nic = null, $link_text__nie = null, $link_text__niew = null, $link_text__nisw = null, $link_url = null, $link_url__ic = null, $link_url__ie = null, $link_url__iew = null, $link_url__isw = null, $link_url__n = null, $link_url__nic = null, $link_url__nie = null, $link_url__niew = null, $link_url__nisw = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $new_window = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasCustomLinksList'][0])
    {































































































        $resourcePath = '/api/extras/custom-links/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $button_class,
            'button_class', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $button_class__n,
            'button_class__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enabled,
            'enabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name,
            'group_name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__empty,
            'group_name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__ic,
            'group_name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__ie,
            'group_name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__iew,
            'group_name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__isw,
            'group_name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__n,
            'group_name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__nic,
            'group_name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__nie,
            'group_name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__niew,
            'group_name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_name__nisw,
            'group_name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_text,
            'link_text', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_text__ic,
            'link_text__ic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_text__ie,
            'link_text__ie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_text__iew,
            'link_text__iew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_text__isw,
            'link_text__isw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_text__n,
            'link_text__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_text__nic,
            'link_text__nic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_text__nie,
            'link_text__nie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_text__niew,
            'link_text__niew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_text__nisw,
            'link_text__nisw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_url,
            'link_url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_url__ic,
            'link_url__ic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_url__ie,
            'link_url__ie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_url__iew,
            'link_url__iew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_url__isw,
            'link_url__isw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_url__n,
            'link_url__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_url__nic,
            'link_url__nic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_url__nie,
            'link_url__nie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_url__niew,
            'link_url__niew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $link_url__nisw,
            'link_url__nisw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_window,
            'new_window', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type,
            'object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ic,
            'object_type__ic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ie,
            'object_type__ie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__iew,
            'object_type__iew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__isw,
            'object_type__isw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__n,
            'object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nic,
            'object_type__nic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nie,
            'object_type__nie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__niew,
            'object_type__niew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nisw,
            'object_type__nisw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id,
            'object_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__n,
            'object_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight,
            'weight', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__empty,
            'weight__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__gt,
            'weight__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__gte,
            'weight__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__lt,
            'weight__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__lte,
            'weight__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__n,
            'weight__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomLinksPartialUpdate
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  \OpenAPI\Client\Model\PatchedCustomLinkRequest $patched_custom_link_request patched_custom_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomLink
     */
    public function extrasCustomLinksPartialUpdate($id, $patched_custom_link_request = null, string $contentType = self::contentTypes['extrasCustomLinksPartialUpdate'][0])
    {
        list($response) = $this->extrasCustomLinksPartialUpdateWithHttpInfo($id, $patched_custom_link_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomLinksPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  \OpenAPI\Client\Model\PatchedCustomLinkRequest $patched_custom_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomLinksPartialUpdateWithHttpInfo($id, $patched_custom_link_request = null, string $contentType = self::contentTypes['extrasCustomLinksPartialUpdate'][0])
    {
        $request = $this->extrasCustomLinksPartialUpdateRequest($id, $patched_custom_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomLinksPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  \OpenAPI\Client\Model\PatchedCustomLinkRequest $patched_custom_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksPartialUpdateAsync($id, $patched_custom_link_request = null, string $contentType = self::contentTypes['extrasCustomLinksPartialUpdate'][0])
    {
        return $this->extrasCustomLinksPartialUpdateAsyncWithHttpInfo($id, $patched_custom_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomLinksPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  \OpenAPI\Client\Model\PatchedCustomLinkRequest $patched_custom_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksPartialUpdateAsyncWithHttpInfo($id, $patched_custom_link_request = null, string $contentType = self::contentTypes['extrasCustomLinksPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomLink';
        $request = $this->extrasCustomLinksPartialUpdateRequest($id, $patched_custom_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomLinksPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  \OpenAPI\Client\Model\PatchedCustomLinkRequest $patched_custom_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomLinksPartialUpdateRequest($id, $patched_custom_link_request = null, string $contentType = self::contentTypes['extrasCustomLinksPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomLinksPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/custom-links/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_custom_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_custom_link_request));
            } else {
                $httpBody = $patched_custom_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomLinksRetrieve
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomLink
     */
    public function extrasCustomLinksRetrieve($id, string $contentType = self::contentTypes['extrasCustomLinksRetrieve'][0])
    {
        list($response) = $this->extrasCustomLinksRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomLinksRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomLinksRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomLinksRetrieve'][0])
    {
        $request = $this->extrasCustomLinksRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomLinksRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksRetrieveAsync($id, string $contentType = self::contentTypes['extrasCustomLinksRetrieve'][0])
    {
        return $this->extrasCustomLinksRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomLinksRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasCustomLinksRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomLink';
        $request = $this->extrasCustomLinksRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomLinksRetrieve'
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomLinksRetrieveRequest($id, string $contentType = self::contentTypes['extrasCustomLinksRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomLinksRetrieve'
            );
        }


        $resourcePath = '/api/extras/custom-links/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasCustomLinksUpdate
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  \OpenAPI\Client\Model\CustomLinkRequest $custom_link_request custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomLink
     */
    public function extrasCustomLinksUpdate($id, $custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksUpdate'][0])
    {
        list($response) = $this->extrasCustomLinksUpdateWithHttpInfo($id, $custom_link_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasCustomLinksUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  \OpenAPI\Client\Model\CustomLinkRequest $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasCustomLinksUpdateWithHttpInfo($id, $custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksUpdate'][0])
    {
        $request = $this->extrasCustomLinksUpdateRequest($id, $custom_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasCustomLinksUpdateAsync
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  \OpenAPI\Client\Model\CustomLinkRequest $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksUpdateAsync($id, $custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksUpdate'][0])
    {
        return $this->extrasCustomLinksUpdateAsyncWithHttpInfo($id, $custom_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasCustomLinksUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  \OpenAPI\Client\Model\CustomLinkRequest $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasCustomLinksUpdateAsyncWithHttpInfo($id, $custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomLink';
        $request = $this->extrasCustomLinksUpdateRequest($id, $custom_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasCustomLinksUpdate'
     *
     * @param  int $id A unique integer value identifying this custom link. (required)
     * @param  \OpenAPI\Client\Model\CustomLinkRequest $custom_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasCustomLinksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasCustomLinksUpdateRequest($id, $custom_link_request, string $contentType = self::contentTypes['extrasCustomLinksUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasCustomLinksUpdate'
            );
        }

        // verify the required parameter 'custom_link_request' is set
        if ($custom_link_request === null || (is_array($custom_link_request) && count($custom_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_link_request when calling extrasCustomLinksUpdate'
            );
        }


        $resourcePath = '/api/extras/custom-links/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_link_request));
            } else {
                $httpBody = $custom_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasDashboardDestroy
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasDashboardDestroy(string $contentType = self::contentTypes['extrasDashboardDestroy'][0])
    {
        $this->extrasDashboardDestroyWithHttpInfo($contentType);
    }

    /**
     * Operation extrasDashboardDestroyWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasDashboardDestroyWithHttpInfo(string $contentType = self::contentTypes['extrasDashboardDestroy'][0])
    {
        $request = $this->extrasDashboardDestroyRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasDashboardDestroyAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasDashboardDestroyAsync(string $contentType = self::contentTypes['extrasDashboardDestroy'][0])
    {
        return $this->extrasDashboardDestroyAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasDashboardDestroyAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasDashboardDestroyAsyncWithHttpInfo(string $contentType = self::contentTypes['extrasDashboardDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasDashboardDestroyRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasDashboardDestroy'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasDashboardDestroyRequest(string $contentType = self::contentTypes['extrasDashboardDestroy'][0])
    {


        $resourcePath = '/api/extras/dashboard/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasDashboardPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\PatchedDashboardRequest $patched_dashboard_request patched_dashboard_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Dashboard
     */
    public function extrasDashboardPartialUpdate($patched_dashboard_request = null, string $contentType = self::contentTypes['extrasDashboardPartialUpdate'][0])
    {
        list($response) = $this->extrasDashboardPartialUpdateWithHttpInfo($patched_dashboard_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasDashboardPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\PatchedDashboardRequest $patched_dashboard_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Dashboard, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasDashboardPartialUpdateWithHttpInfo($patched_dashboard_request = null, string $contentType = self::contentTypes['extrasDashboardPartialUpdate'][0])
    {
        $request = $this->extrasDashboardPartialUpdateRequest($patched_dashboard_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Dashboard' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Dashboard' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Dashboard', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Dashboard';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Dashboard',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasDashboardPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\PatchedDashboardRequest $patched_dashboard_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasDashboardPartialUpdateAsync($patched_dashboard_request = null, string $contentType = self::contentTypes['extrasDashboardPartialUpdate'][0])
    {
        return $this->extrasDashboardPartialUpdateAsyncWithHttpInfo($patched_dashboard_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasDashboardPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\PatchedDashboardRequest $patched_dashboard_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasDashboardPartialUpdateAsyncWithHttpInfo($patched_dashboard_request = null, string $contentType = self::contentTypes['extrasDashboardPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Dashboard';
        $request = $this->extrasDashboardPartialUpdateRequest($patched_dashboard_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasDashboardPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\PatchedDashboardRequest $patched_dashboard_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasDashboardPartialUpdateRequest($patched_dashboard_request = null, string $contentType = self::contentTypes['extrasDashboardPartialUpdate'][0])
    {



        $resourcePath = '/api/extras/dashboard/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_dashboard_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_dashboard_request));
            } else {
                $httpBody = $patched_dashboard_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasDashboardRetrieve
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Dashboard
     */
    public function extrasDashboardRetrieve(string $contentType = self::contentTypes['extrasDashboardRetrieve'][0])
    {
        list($response) = $this->extrasDashboardRetrieveWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation extrasDashboardRetrieveWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Dashboard, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasDashboardRetrieveWithHttpInfo(string $contentType = self::contentTypes['extrasDashboardRetrieve'][0])
    {
        $request = $this->extrasDashboardRetrieveRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Dashboard' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Dashboard' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Dashboard', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Dashboard';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Dashboard',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasDashboardRetrieveAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasDashboardRetrieveAsync(string $contentType = self::contentTypes['extrasDashboardRetrieve'][0])
    {
        return $this->extrasDashboardRetrieveAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasDashboardRetrieveAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasDashboardRetrieveAsyncWithHttpInfo(string $contentType = self::contentTypes['extrasDashboardRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Dashboard';
        $request = $this->extrasDashboardRetrieveRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasDashboardRetrieve'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasDashboardRetrieveRequest(string $contentType = self::contentTypes['extrasDashboardRetrieve'][0])
    {


        $resourcePath = '/api/extras/dashboard/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasDashboardUpdate
     *
     * @param  \OpenAPI\Client\Model\DashboardRequest $dashboard_request dashboard_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Dashboard
     */
    public function extrasDashboardUpdate($dashboard_request = null, string $contentType = self::contentTypes['extrasDashboardUpdate'][0])
    {
        list($response) = $this->extrasDashboardUpdateWithHttpInfo($dashboard_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasDashboardUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\DashboardRequest $dashboard_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Dashboard, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasDashboardUpdateWithHttpInfo($dashboard_request = null, string $contentType = self::contentTypes['extrasDashboardUpdate'][0])
    {
        $request = $this->extrasDashboardUpdateRequest($dashboard_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Dashboard' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Dashboard' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Dashboard', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Dashboard';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Dashboard',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasDashboardUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\DashboardRequest $dashboard_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasDashboardUpdateAsync($dashboard_request = null, string $contentType = self::contentTypes['extrasDashboardUpdate'][0])
    {
        return $this->extrasDashboardUpdateAsyncWithHttpInfo($dashboard_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasDashboardUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\DashboardRequest $dashboard_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasDashboardUpdateAsyncWithHttpInfo($dashboard_request = null, string $contentType = self::contentTypes['extrasDashboardUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Dashboard';
        $request = $this->extrasDashboardUpdateRequest($dashboard_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasDashboardUpdate'
     *
     * @param  \OpenAPI\Client\Model\DashboardRequest $dashboard_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasDashboardUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasDashboardUpdateRequest($dashboard_request = null, string $contentType = self::contentTypes['extrasDashboardUpdate'][0])
    {



        $resourcePath = '/api/extras/dashboard/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($dashboard_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($dashboard_request));
            } else {
                $httpBody = $dashboard_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasEventRulesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasEventRulesBulkDestroy($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkDestroy'][0])
    {
        $this->extrasEventRulesBulkDestroyWithHttpInfo($event_rule_request, $contentType);
    }

    /**
     * Operation extrasEventRulesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasEventRulesBulkDestroyWithHttpInfo($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkDestroy'][0])
    {
        $request = $this->extrasEventRulesBulkDestroyRequest($event_rule_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasEventRulesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesBulkDestroyAsync($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkDestroy'][0])
    {
        return $this->extrasEventRulesBulkDestroyAsyncWithHttpInfo($event_rule_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasEventRulesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesBulkDestroyAsyncWithHttpInfo($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasEventRulesBulkDestroyRequest($event_rule_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasEventRulesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasEventRulesBulkDestroyRequest($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkDestroy'][0])
    {

        // verify the required parameter 'event_rule_request' is set
        if ($event_rule_request === null || (is_array($event_rule_request) && count($event_rule_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $event_rule_request when calling extrasEventRulesBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/event-rules/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($event_rule_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($event_rule_request));
            } else {
                $httpBody = $event_rule_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasEventRulesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EventRule[]
     */
    public function extrasEventRulesBulkPartialUpdate($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasEventRulesBulkPartialUpdateWithHttpInfo($event_rule_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasEventRulesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EventRule[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasEventRulesBulkPartialUpdateWithHttpInfo($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkPartialUpdate'][0])
    {
        $request = $this->extrasEventRulesBulkPartialUpdateRequest($event_rule_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EventRule[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EventRule[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EventRule[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\EventRule[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EventRule[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasEventRulesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesBulkPartialUpdateAsync($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkPartialUpdate'][0])
    {
        return $this->extrasEventRulesBulkPartialUpdateAsyncWithHttpInfo($event_rule_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasEventRulesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesBulkPartialUpdateAsyncWithHttpInfo($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EventRule[]';
        $request = $this->extrasEventRulesBulkPartialUpdateRequest($event_rule_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasEventRulesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasEventRulesBulkPartialUpdateRequest($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'event_rule_request' is set
        if ($event_rule_request === null || (is_array($event_rule_request) && count($event_rule_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $event_rule_request when calling extrasEventRulesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/event-rules/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($event_rule_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($event_rule_request));
            } else {
                $httpBody = $event_rule_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasEventRulesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EventRule[]
     */
    public function extrasEventRulesBulkUpdate($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkUpdate'][0])
    {
        list($response) = $this->extrasEventRulesBulkUpdateWithHttpInfo($event_rule_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasEventRulesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EventRule[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasEventRulesBulkUpdateWithHttpInfo($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkUpdate'][0])
    {
        $request = $this->extrasEventRulesBulkUpdateRequest($event_rule_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EventRule[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EventRule[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EventRule[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\EventRule[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EventRule[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasEventRulesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesBulkUpdateAsync($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkUpdate'][0])
    {
        return $this->extrasEventRulesBulkUpdateAsyncWithHttpInfo($event_rule_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasEventRulesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesBulkUpdateAsyncWithHttpInfo($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EventRule[]';
        $request = $this->extrasEventRulesBulkUpdateRequest($event_rule_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasEventRulesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\EventRuleRequest[] $event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasEventRulesBulkUpdateRequest($event_rule_request, string $contentType = self::contentTypes['extrasEventRulesBulkUpdate'][0])
    {

        // verify the required parameter 'event_rule_request' is set
        if ($event_rule_request === null || (is_array($event_rule_request) && count($event_rule_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $event_rule_request when calling extrasEventRulesBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/event-rules/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($event_rule_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($event_rule_request));
            } else {
                $httpBody = $event_rule_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasEventRulesCreate
     *
     * @param  \OpenAPI\Client\Model\WritableEventRuleRequest $writable_event_rule_request writable_event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EventRule
     */
    public function extrasEventRulesCreate($writable_event_rule_request, string $contentType = self::contentTypes['extrasEventRulesCreate'][0])
    {
        list($response) = $this->extrasEventRulesCreateWithHttpInfo($writable_event_rule_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasEventRulesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableEventRuleRequest $writable_event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EventRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasEventRulesCreateWithHttpInfo($writable_event_rule_request, string $contentType = self::contentTypes['extrasEventRulesCreate'][0])
    {
        $request = $this->extrasEventRulesCreateRequest($writable_event_rule_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\EventRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EventRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EventRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\EventRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EventRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasEventRulesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableEventRuleRequest $writable_event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesCreateAsync($writable_event_rule_request, string $contentType = self::contentTypes['extrasEventRulesCreate'][0])
    {
        return $this->extrasEventRulesCreateAsyncWithHttpInfo($writable_event_rule_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasEventRulesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableEventRuleRequest $writable_event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesCreateAsyncWithHttpInfo($writable_event_rule_request, string $contentType = self::contentTypes['extrasEventRulesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EventRule';
        $request = $this->extrasEventRulesCreateRequest($writable_event_rule_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasEventRulesCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableEventRuleRequest $writable_event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasEventRulesCreateRequest($writable_event_rule_request, string $contentType = self::contentTypes['extrasEventRulesCreate'][0])
    {

        // verify the required parameter 'writable_event_rule_request' is set
        if ($writable_event_rule_request === null || (is_array($writable_event_rule_request) && count($writable_event_rule_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_event_rule_request when calling extrasEventRulesCreate'
            );
        }


        $resourcePath = '/api/extras/event-rules/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_event_rule_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_event_rule_request));
            } else {
                $httpBody = $writable_event_rule_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasEventRulesDestroy
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasEventRulesDestroy($id, string $contentType = self::contentTypes['extrasEventRulesDestroy'][0])
    {
        $this->extrasEventRulesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasEventRulesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasEventRulesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasEventRulesDestroy'][0])
    {
        $request = $this->extrasEventRulesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasEventRulesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesDestroyAsync($id, string $contentType = self::contentTypes['extrasEventRulesDestroy'][0])
    {
        return $this->extrasEventRulesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasEventRulesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasEventRulesDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasEventRulesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasEventRulesDestroy'
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasEventRulesDestroyRequest($id, string $contentType = self::contentTypes['extrasEventRulesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasEventRulesDestroy'
            );
        }


        $resourcePath = '/api/extras/event-rules/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasEventRulesList
     *
     * @param  int[] $action_object_id action_object_id (optional)
     * @param  int[] $action_object_id__empty action_object_id__empty (optional)
     * @param  int[] $action_object_id__gt action_object_id__gt (optional)
     * @param  int[] $action_object_id__gte action_object_id__gte (optional)
     * @param  int[] $action_object_id__lt action_object_id__lt (optional)
     * @param  int[] $action_object_id__lte action_object_id__lte (optional)
     * @param  int[] $action_object_id__n action_object_id__n (optional)
     * @param  string $action_object_type action_object_type (optional)
     * @param  string $action_object_type__n action_object_type__n (optional)
     * @param  string[] $action_type action_type (optional)
     * @param  string[] $action_type__n action_type__n (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  bool $enabled enabled (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  string $object_type object_type (optional)
     * @param  string $object_type__ic object_type__ic (optional)
     * @param  string $object_type__ie object_type__ie (optional)
     * @param  string $object_type__iew object_type__iew (optional)
     * @param  string $object_type__isw object_type__isw (optional)
     * @param  string $object_type__n object_type__n (optional)
     * @param  string $object_type__nic object_type__nic (optional)
     * @param  string $object_type__nie object_type__nie (optional)
     * @param  string $object_type__niew object_type__niew (optional)
     * @param  string $object_type__nisw object_type__nisw (optional)
     * @param  int[] $object_type_id object_type_id (optional)
     * @param  int[] $object_type_id__n object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  bool $type_create type_create (optional)
     * @param  bool $type_delete type_delete (optional)
     * @param  bool $type_job_end type_job_end (optional)
     * @param  bool $type_job_start type_job_start (optional)
     * @param  bool $type_update type_update (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedEventRuleList
     */
    public function extrasEventRulesList($action_object_id = null, $action_object_id__empty = null, $action_object_id__gt = null, $action_object_id__gte = null, $action_object_id__lt = null, $action_object_id__lte = null, $action_object_id__n = null, $action_object_type = null, $action_object_type__n = null, $action_type = null, $action_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $type_create = null, $type_delete = null, $type_job_end = null, $type_job_start = null, $type_update = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasEventRulesList'][0])
    {
        list($response) = $this->extrasEventRulesListWithHttpInfo($action_object_id, $action_object_id__empty, $action_object_id__gt, $action_object_id__gte, $action_object_id__lt, $action_object_id__lte, $action_object_id__n, $action_object_type, $action_object_type__n, $action_type, $action_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $tag, $tag__n, $type_create, $type_delete, $type_job_end, $type_job_start, $type_update, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasEventRulesListWithHttpInfo
     *
     * @param  int[] $action_object_id (optional)
     * @param  int[] $action_object_id__empty (optional)
     * @param  int[] $action_object_id__gt (optional)
     * @param  int[] $action_object_id__gte (optional)
     * @param  int[] $action_object_id__lt (optional)
     * @param  int[] $action_object_id__lte (optional)
     * @param  int[] $action_object_id__n (optional)
     * @param  string $action_object_type (optional)
     * @param  string $action_object_type__n (optional)
     * @param  string[] $action_type (optional)
     * @param  string[] $action_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  bool $type_create (optional)
     * @param  bool $type_delete (optional)
     * @param  bool $type_job_end (optional)
     * @param  bool $type_job_start (optional)
     * @param  bool $type_update (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedEventRuleList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasEventRulesListWithHttpInfo($action_object_id = null, $action_object_id__empty = null, $action_object_id__gt = null, $action_object_id__gte = null, $action_object_id__lt = null, $action_object_id__lte = null, $action_object_id__n = null, $action_object_type = null, $action_object_type__n = null, $action_type = null, $action_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $type_create = null, $type_delete = null, $type_job_end = null, $type_job_start = null, $type_update = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasEventRulesList'][0])
    {
        $request = $this->extrasEventRulesListRequest($action_object_id, $action_object_id__empty, $action_object_id__gt, $action_object_id__gte, $action_object_id__lt, $action_object_id__lte, $action_object_id__n, $action_object_type, $action_object_type__n, $action_type, $action_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $tag, $tag__n, $type_create, $type_delete, $type_job_end, $type_job_start, $type_update, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedEventRuleList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedEventRuleList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedEventRuleList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedEventRuleList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedEventRuleList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasEventRulesListAsync
     *
     * @param  int[] $action_object_id (optional)
     * @param  int[] $action_object_id__empty (optional)
     * @param  int[] $action_object_id__gt (optional)
     * @param  int[] $action_object_id__gte (optional)
     * @param  int[] $action_object_id__lt (optional)
     * @param  int[] $action_object_id__lte (optional)
     * @param  int[] $action_object_id__n (optional)
     * @param  string $action_object_type (optional)
     * @param  string $action_object_type__n (optional)
     * @param  string[] $action_type (optional)
     * @param  string[] $action_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  bool $type_create (optional)
     * @param  bool $type_delete (optional)
     * @param  bool $type_job_end (optional)
     * @param  bool $type_job_start (optional)
     * @param  bool $type_update (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesListAsync($action_object_id = null, $action_object_id__empty = null, $action_object_id__gt = null, $action_object_id__gte = null, $action_object_id__lt = null, $action_object_id__lte = null, $action_object_id__n = null, $action_object_type = null, $action_object_type__n = null, $action_type = null, $action_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $type_create = null, $type_delete = null, $type_job_end = null, $type_job_start = null, $type_update = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasEventRulesList'][0])
    {
        return $this->extrasEventRulesListAsyncWithHttpInfo($action_object_id, $action_object_id__empty, $action_object_id__gt, $action_object_id__gte, $action_object_id__lt, $action_object_id__lte, $action_object_id__n, $action_object_type, $action_object_type__n, $action_type, $action_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $tag, $tag__n, $type_create, $type_delete, $type_job_end, $type_job_start, $type_update, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasEventRulesListAsyncWithHttpInfo
     *
     * @param  int[] $action_object_id (optional)
     * @param  int[] $action_object_id__empty (optional)
     * @param  int[] $action_object_id__gt (optional)
     * @param  int[] $action_object_id__gte (optional)
     * @param  int[] $action_object_id__lt (optional)
     * @param  int[] $action_object_id__lte (optional)
     * @param  int[] $action_object_id__n (optional)
     * @param  string $action_object_type (optional)
     * @param  string $action_object_type__n (optional)
     * @param  string[] $action_type (optional)
     * @param  string[] $action_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  bool $type_create (optional)
     * @param  bool $type_delete (optional)
     * @param  bool $type_job_end (optional)
     * @param  bool $type_job_start (optional)
     * @param  bool $type_update (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesListAsyncWithHttpInfo($action_object_id = null, $action_object_id__empty = null, $action_object_id__gt = null, $action_object_id__gte = null, $action_object_id__lt = null, $action_object_id__lte = null, $action_object_id__n = null, $action_object_type = null, $action_object_type__n = null, $action_type = null, $action_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $type_create = null, $type_delete = null, $type_job_end = null, $type_job_start = null, $type_update = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasEventRulesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedEventRuleList';
        $request = $this->extrasEventRulesListRequest($action_object_id, $action_object_id__empty, $action_object_id__gt, $action_object_id__gte, $action_object_id__lt, $action_object_id__lte, $action_object_id__n, $action_object_type, $action_object_type__n, $action_type, $action_type__n, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $tag, $tag__n, $type_create, $type_delete, $type_job_end, $type_job_start, $type_update, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasEventRulesList'
     *
     * @param  int[] $action_object_id (optional)
     * @param  int[] $action_object_id__empty (optional)
     * @param  int[] $action_object_id__gt (optional)
     * @param  int[] $action_object_id__gte (optional)
     * @param  int[] $action_object_id__lt (optional)
     * @param  int[] $action_object_id__lte (optional)
     * @param  int[] $action_object_id__n (optional)
     * @param  string $action_object_type (optional)
     * @param  string $action_object_type__n (optional)
     * @param  string[] $action_type (optional)
     * @param  string[] $action_type__n (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  bool $type_create (optional)
     * @param  bool $type_delete (optional)
     * @param  bool $type_job_end (optional)
     * @param  bool $type_job_start (optional)
     * @param  bool $type_update (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasEventRulesListRequest($action_object_id = null, $action_object_id__empty = null, $action_object_id__gt = null, $action_object_id__gte = null, $action_object_id__lt = null, $action_object_id__lte = null, $action_object_id__n = null, $action_object_type = null, $action_object_type__n = null, $action_type = null, $action_type__n = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $type_create = null, $type_delete = null, $type_job_end = null, $type_job_start = null, $type_update = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasEventRulesList'][0])
    {



















































































        $resourcePath = '/api/extras/event-rules/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_object_id,
            'action_object_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_object_id__empty,
            'action_object_id__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_object_id__gt,
            'action_object_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_object_id__gte,
            'action_object_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_object_id__lt,
            'action_object_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_object_id__lte,
            'action_object_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_object_id__n,
            'action_object_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_object_type,
            'action_object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_object_type__n,
            'action_object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_type,
            'action_type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_type__n,
            'action_type__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enabled,
            'enabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type,
            'object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ic,
            'object_type__ic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ie,
            'object_type__ie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__iew,
            'object_type__iew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__isw,
            'object_type__isw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__n,
            'object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nic,
            'object_type__nic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nie,
            'object_type__nie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__niew,
            'object_type__niew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nisw,
            'object_type__nisw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id,
            'object_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__n,
            'object_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_create,
            'type_create', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_delete,
            'type_delete', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_job_end,
            'type_job_end', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_job_start,
            'type_job_start', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_update,
            'type_update', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasEventRulesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableEventRuleRequest $patched_writable_event_rule_request patched_writable_event_rule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EventRule
     */
    public function extrasEventRulesPartialUpdate($id, $patched_writable_event_rule_request = null, string $contentType = self::contentTypes['extrasEventRulesPartialUpdate'][0])
    {
        list($response) = $this->extrasEventRulesPartialUpdateWithHttpInfo($id, $patched_writable_event_rule_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasEventRulesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableEventRuleRequest $patched_writable_event_rule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EventRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasEventRulesPartialUpdateWithHttpInfo($id, $patched_writable_event_rule_request = null, string $contentType = self::contentTypes['extrasEventRulesPartialUpdate'][0])
    {
        $request = $this->extrasEventRulesPartialUpdateRequest($id, $patched_writable_event_rule_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EventRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EventRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EventRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\EventRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EventRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasEventRulesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableEventRuleRequest $patched_writable_event_rule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesPartialUpdateAsync($id, $patched_writable_event_rule_request = null, string $contentType = self::contentTypes['extrasEventRulesPartialUpdate'][0])
    {
        return $this->extrasEventRulesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_event_rule_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasEventRulesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableEventRuleRequest $patched_writable_event_rule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_event_rule_request = null, string $contentType = self::contentTypes['extrasEventRulesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EventRule';
        $request = $this->extrasEventRulesPartialUpdateRequest($id, $patched_writable_event_rule_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasEventRulesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableEventRuleRequest $patched_writable_event_rule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasEventRulesPartialUpdateRequest($id, $patched_writable_event_rule_request = null, string $contentType = self::contentTypes['extrasEventRulesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasEventRulesPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/event-rules/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_event_rule_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_event_rule_request));
            } else {
                $httpBody = $patched_writable_event_rule_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasEventRulesRetrieve
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EventRule
     */
    public function extrasEventRulesRetrieve($id, string $contentType = self::contentTypes['extrasEventRulesRetrieve'][0])
    {
        list($response) = $this->extrasEventRulesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasEventRulesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EventRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasEventRulesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasEventRulesRetrieve'][0])
    {
        $request = $this->extrasEventRulesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EventRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EventRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EventRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\EventRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EventRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasEventRulesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesRetrieveAsync($id, string $contentType = self::contentTypes['extrasEventRulesRetrieve'][0])
    {
        return $this->extrasEventRulesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasEventRulesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasEventRulesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EventRule';
        $request = $this->extrasEventRulesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasEventRulesRetrieve'
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasEventRulesRetrieveRequest($id, string $contentType = self::contentTypes['extrasEventRulesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasEventRulesRetrieve'
            );
        }


        $resourcePath = '/api/extras/event-rules/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasEventRulesUpdate
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  \OpenAPI\Client\Model\WritableEventRuleRequest $writable_event_rule_request writable_event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EventRule
     */
    public function extrasEventRulesUpdate($id, $writable_event_rule_request, string $contentType = self::contentTypes['extrasEventRulesUpdate'][0])
    {
        list($response) = $this->extrasEventRulesUpdateWithHttpInfo($id, $writable_event_rule_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasEventRulesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  \OpenAPI\Client\Model\WritableEventRuleRequest $writable_event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EventRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasEventRulesUpdateWithHttpInfo($id, $writable_event_rule_request, string $contentType = self::contentTypes['extrasEventRulesUpdate'][0])
    {
        $request = $this->extrasEventRulesUpdateRequest($id, $writable_event_rule_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EventRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EventRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EventRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\EventRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EventRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasEventRulesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  \OpenAPI\Client\Model\WritableEventRuleRequest $writable_event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesUpdateAsync($id, $writable_event_rule_request, string $contentType = self::contentTypes['extrasEventRulesUpdate'][0])
    {
        return $this->extrasEventRulesUpdateAsyncWithHttpInfo($id, $writable_event_rule_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasEventRulesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  \OpenAPI\Client\Model\WritableEventRuleRequest $writable_event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasEventRulesUpdateAsyncWithHttpInfo($id, $writable_event_rule_request, string $contentType = self::contentTypes['extrasEventRulesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EventRule';
        $request = $this->extrasEventRulesUpdateRequest($id, $writable_event_rule_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasEventRulesUpdate'
     *
     * @param  int $id A unique integer value identifying this event rule. (required)
     * @param  \OpenAPI\Client\Model\WritableEventRuleRequest $writable_event_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasEventRulesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasEventRulesUpdateRequest($id, $writable_event_rule_request, string $contentType = self::contentTypes['extrasEventRulesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasEventRulesUpdate'
            );
        }

        // verify the required parameter 'writable_event_rule_request' is set
        if ($writable_event_rule_request === null || (is_array($writable_event_rule_request) && count($writable_event_rule_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_event_rule_request when calling extrasEventRulesUpdate'
            );
        }


        $resourcePath = '/api/extras/event-rules/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_event_rule_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_event_rule_request));
            } else {
                $httpBody = $writable_event_rule_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasExportTemplatesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasExportTemplatesBulkDestroy($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkDestroy'][0])
    {
        $this->extrasExportTemplatesBulkDestroyWithHttpInfo($export_template_request, $contentType);
    }

    /**
     * Operation extrasExportTemplatesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasExportTemplatesBulkDestroyWithHttpInfo($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkDestroy'][0])
    {
        $request = $this->extrasExportTemplatesBulkDestroyRequest($export_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasExportTemplatesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesBulkDestroyAsync($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkDestroy'][0])
    {
        return $this->extrasExportTemplatesBulkDestroyAsyncWithHttpInfo($export_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasExportTemplatesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesBulkDestroyAsyncWithHttpInfo($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasExportTemplatesBulkDestroyRequest($export_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasExportTemplatesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasExportTemplatesBulkDestroyRequest($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkDestroy'][0])
    {

        // verify the required parameter 'export_template_request' is set
        if ($export_template_request === null || (is_array($export_template_request) && count($export_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_template_request when calling extrasExportTemplatesBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/export-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($export_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($export_template_request));
            } else {
                $httpBody = $export_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasExportTemplatesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExportTemplate[]
     */
    public function extrasExportTemplatesBulkPartialUpdate($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasExportTemplatesBulkPartialUpdateWithHttpInfo($export_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasExportTemplatesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExportTemplate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasExportTemplatesBulkPartialUpdateWithHttpInfo($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkPartialUpdate'][0])
    {
        $request = $this->extrasExportTemplatesBulkPartialUpdateRequest($export_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ExportTemplate[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ExportTemplate[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExportTemplate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ExportTemplate[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExportTemplate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasExportTemplatesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesBulkPartialUpdateAsync($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkPartialUpdate'][0])
    {
        return $this->extrasExportTemplatesBulkPartialUpdateAsyncWithHttpInfo($export_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasExportTemplatesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesBulkPartialUpdateAsyncWithHttpInfo($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ExportTemplate[]';
        $request = $this->extrasExportTemplatesBulkPartialUpdateRequest($export_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasExportTemplatesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasExportTemplatesBulkPartialUpdateRequest($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'export_template_request' is set
        if ($export_template_request === null || (is_array($export_template_request) && count($export_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_template_request when calling extrasExportTemplatesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/export-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($export_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($export_template_request));
            } else {
                $httpBody = $export_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasExportTemplatesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExportTemplate[]
     */
    public function extrasExportTemplatesBulkUpdate($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkUpdate'][0])
    {
        list($response) = $this->extrasExportTemplatesBulkUpdateWithHttpInfo($export_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasExportTemplatesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExportTemplate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasExportTemplatesBulkUpdateWithHttpInfo($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkUpdate'][0])
    {
        $request = $this->extrasExportTemplatesBulkUpdateRequest($export_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ExportTemplate[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ExportTemplate[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExportTemplate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ExportTemplate[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExportTemplate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasExportTemplatesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesBulkUpdateAsync($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkUpdate'][0])
    {
        return $this->extrasExportTemplatesBulkUpdateAsyncWithHttpInfo($export_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasExportTemplatesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesBulkUpdateAsyncWithHttpInfo($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ExportTemplate[]';
        $request = $this->extrasExportTemplatesBulkUpdateRequest($export_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasExportTemplatesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest[] $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasExportTemplatesBulkUpdateRequest($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesBulkUpdate'][0])
    {

        // verify the required parameter 'export_template_request' is set
        if ($export_template_request === null || (is_array($export_template_request) && count($export_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_template_request when calling extrasExportTemplatesBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/export-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($export_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($export_template_request));
            } else {
                $httpBody = $export_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasExportTemplatesCreate
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExportTemplate
     */
    public function extrasExportTemplatesCreate($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesCreate'][0])
    {
        list($response) = $this->extrasExportTemplatesCreateWithHttpInfo($export_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasExportTemplatesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExportTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasExportTemplatesCreateWithHttpInfo($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesCreate'][0])
    {
        $request = $this->extrasExportTemplatesCreateRequest($export_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ExportTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ExportTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExportTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ExportTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExportTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasExportTemplatesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesCreateAsync($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesCreate'][0])
    {
        return $this->extrasExportTemplatesCreateAsyncWithHttpInfo($export_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasExportTemplatesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesCreateAsyncWithHttpInfo($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ExportTemplate';
        $request = $this->extrasExportTemplatesCreateRequest($export_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasExportTemplatesCreate'
     *
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasExportTemplatesCreateRequest($export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesCreate'][0])
    {

        // verify the required parameter 'export_template_request' is set
        if ($export_template_request === null || (is_array($export_template_request) && count($export_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_template_request when calling extrasExportTemplatesCreate'
            );
        }


        $resourcePath = '/api/extras/export-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($export_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($export_template_request));
            } else {
                $httpBody = $export_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasExportTemplatesDestroy
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasExportTemplatesDestroy($id, string $contentType = self::contentTypes['extrasExportTemplatesDestroy'][0])
    {
        $this->extrasExportTemplatesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasExportTemplatesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasExportTemplatesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasExportTemplatesDestroy'][0])
    {
        $request = $this->extrasExportTemplatesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasExportTemplatesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesDestroyAsync($id, string $contentType = self::contentTypes['extrasExportTemplatesDestroy'][0])
    {
        return $this->extrasExportTemplatesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasExportTemplatesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasExportTemplatesDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasExportTemplatesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasExportTemplatesDestroy'
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasExportTemplatesDestroyRequest($id, string $contentType = self::contentTypes['extrasExportTemplatesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasExportTemplatesDestroy'
            );
        }


        $resourcePath = '/api/extras/export-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasExportTemplatesList
     *
     * @param  bool $as_attachment as_attachment (optional)
     * @param  bool $auto_sync_enabled auto_sync_enabled (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced data_synced (optional)
     * @param  bool $data_synced__empty data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n data_synced__n (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $file_extension file_extension (optional)
     * @param  bool $file_extension__empty file_extension__empty (optional)
     * @param  string[] $file_extension__ic file_extension__ic (optional)
     * @param  string[] $file_extension__ie file_extension__ie (optional)
     * @param  string[] $file_extension__iew file_extension__iew (optional)
     * @param  string[] $file_extension__isw file_extension__isw (optional)
     * @param  string[] $file_extension__n file_extension__n (optional)
     * @param  string[] $file_extension__nic file_extension__nic (optional)
     * @param  string[] $file_extension__nie file_extension__nie (optional)
     * @param  string[] $file_extension__niew file_extension__niew (optional)
     * @param  string[] $file_extension__nisw file_extension__nisw (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mime_type mime_type (optional)
     * @param  bool $mime_type__empty mime_type__empty (optional)
     * @param  string[] $mime_type__ic mime_type__ic (optional)
     * @param  string[] $mime_type__ie mime_type__ie (optional)
     * @param  string[] $mime_type__iew mime_type__iew (optional)
     * @param  string[] $mime_type__isw mime_type__isw (optional)
     * @param  string[] $mime_type__n mime_type__n (optional)
     * @param  string[] $mime_type__nic mime_type__nic (optional)
     * @param  string[] $mime_type__nie mime_type__nie (optional)
     * @param  string[] $mime_type__niew mime_type__niew (optional)
     * @param  string[] $mime_type__nisw mime_type__nisw (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  string $object_type object_type (optional)
     * @param  string $object_type__ic object_type__ic (optional)
     * @param  string $object_type__ie object_type__ie (optional)
     * @param  string $object_type__iew object_type__iew (optional)
     * @param  string $object_type__isw object_type__isw (optional)
     * @param  string $object_type__n object_type__n (optional)
     * @param  string $object_type__nic object_type__nic (optional)
     * @param  string $object_type__nie object_type__nie (optional)
     * @param  string $object_type__niew object_type__niew (optional)
     * @param  string $object_type__nisw object_type__nisw (optional)
     * @param  int[] $object_type_id object_type_id (optional)
     * @param  int[] $object_type_id__n object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedExportTemplateList
     */
    public function extrasExportTemplatesList($as_attachment = null, $auto_sync_enabled = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $file_extension = null, $file_extension__empty = null, $file_extension__ic = null, $file_extension__ie = null, $file_extension__iew = null, $file_extension__isw = null, $file_extension__n = null, $file_extension__nic = null, $file_extension__nie = null, $file_extension__niew = null, $file_extension__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mime_type = null, $mime_type__empty = null, $mime_type__ic = null, $mime_type__ie = null, $mime_type__iew = null, $mime_type__isw = null, $mime_type__n = null, $mime_type__nic = null, $mime_type__nie = null, $mime_type__niew = null, $mime_type__nisw = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasExportTemplatesList'][0])
    {
        list($response) = $this->extrasExportTemplatesListWithHttpInfo($as_attachment, $auto_sync_enabled, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $file_extension, $file_extension__empty, $file_extension__ic, $file_extension__ie, $file_extension__iew, $file_extension__isw, $file_extension__n, $file_extension__nic, $file_extension__nie, $file_extension__niew, $file_extension__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mime_type, $mime_type__empty, $mime_type__ic, $mime_type__ie, $mime_type__iew, $mime_type__isw, $mime_type__n, $mime_type__nic, $mime_type__nie, $mime_type__niew, $mime_type__nisw, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasExportTemplatesListWithHttpInfo
     *
     * @param  bool $as_attachment (optional)
     * @param  bool $auto_sync_enabled (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $file_extension (optional)
     * @param  bool $file_extension__empty (optional)
     * @param  string[] $file_extension__ic (optional)
     * @param  string[] $file_extension__ie (optional)
     * @param  string[] $file_extension__iew (optional)
     * @param  string[] $file_extension__isw (optional)
     * @param  string[] $file_extension__n (optional)
     * @param  string[] $file_extension__nic (optional)
     * @param  string[] $file_extension__nie (optional)
     * @param  string[] $file_extension__niew (optional)
     * @param  string[] $file_extension__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mime_type (optional)
     * @param  bool $mime_type__empty (optional)
     * @param  string[] $mime_type__ic (optional)
     * @param  string[] $mime_type__ie (optional)
     * @param  string[] $mime_type__iew (optional)
     * @param  string[] $mime_type__isw (optional)
     * @param  string[] $mime_type__n (optional)
     * @param  string[] $mime_type__nic (optional)
     * @param  string[] $mime_type__nie (optional)
     * @param  string[] $mime_type__niew (optional)
     * @param  string[] $mime_type__nisw (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedExportTemplateList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasExportTemplatesListWithHttpInfo($as_attachment = null, $auto_sync_enabled = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $file_extension = null, $file_extension__empty = null, $file_extension__ic = null, $file_extension__ie = null, $file_extension__iew = null, $file_extension__isw = null, $file_extension__n = null, $file_extension__nic = null, $file_extension__nie = null, $file_extension__niew = null, $file_extension__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mime_type = null, $mime_type__empty = null, $mime_type__ic = null, $mime_type__ie = null, $mime_type__iew = null, $mime_type__isw = null, $mime_type__n = null, $mime_type__nic = null, $mime_type__nie = null, $mime_type__niew = null, $mime_type__nisw = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasExportTemplatesList'][0])
    {
        $request = $this->extrasExportTemplatesListRequest($as_attachment, $auto_sync_enabled, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $file_extension, $file_extension__empty, $file_extension__ic, $file_extension__ie, $file_extension__iew, $file_extension__isw, $file_extension__n, $file_extension__nic, $file_extension__nie, $file_extension__niew, $file_extension__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mime_type, $mime_type__empty, $mime_type__ic, $mime_type__ie, $mime_type__iew, $mime_type__isw, $mime_type__n, $mime_type__nic, $mime_type__nie, $mime_type__niew, $mime_type__nisw, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedExportTemplateList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedExportTemplateList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedExportTemplateList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedExportTemplateList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedExportTemplateList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasExportTemplatesListAsync
     *
     * @param  bool $as_attachment (optional)
     * @param  bool $auto_sync_enabled (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $file_extension (optional)
     * @param  bool $file_extension__empty (optional)
     * @param  string[] $file_extension__ic (optional)
     * @param  string[] $file_extension__ie (optional)
     * @param  string[] $file_extension__iew (optional)
     * @param  string[] $file_extension__isw (optional)
     * @param  string[] $file_extension__n (optional)
     * @param  string[] $file_extension__nic (optional)
     * @param  string[] $file_extension__nie (optional)
     * @param  string[] $file_extension__niew (optional)
     * @param  string[] $file_extension__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mime_type (optional)
     * @param  bool $mime_type__empty (optional)
     * @param  string[] $mime_type__ic (optional)
     * @param  string[] $mime_type__ie (optional)
     * @param  string[] $mime_type__iew (optional)
     * @param  string[] $mime_type__isw (optional)
     * @param  string[] $mime_type__n (optional)
     * @param  string[] $mime_type__nic (optional)
     * @param  string[] $mime_type__nie (optional)
     * @param  string[] $mime_type__niew (optional)
     * @param  string[] $mime_type__nisw (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesListAsync($as_attachment = null, $auto_sync_enabled = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $file_extension = null, $file_extension__empty = null, $file_extension__ic = null, $file_extension__ie = null, $file_extension__iew = null, $file_extension__isw = null, $file_extension__n = null, $file_extension__nic = null, $file_extension__nie = null, $file_extension__niew = null, $file_extension__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mime_type = null, $mime_type__empty = null, $mime_type__ic = null, $mime_type__ie = null, $mime_type__iew = null, $mime_type__isw = null, $mime_type__n = null, $mime_type__nic = null, $mime_type__nie = null, $mime_type__niew = null, $mime_type__nisw = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasExportTemplatesList'][0])
    {
        return $this->extrasExportTemplatesListAsyncWithHttpInfo($as_attachment, $auto_sync_enabled, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $file_extension, $file_extension__empty, $file_extension__ic, $file_extension__ie, $file_extension__iew, $file_extension__isw, $file_extension__n, $file_extension__nic, $file_extension__nie, $file_extension__niew, $file_extension__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mime_type, $mime_type__empty, $mime_type__ic, $mime_type__ie, $mime_type__iew, $mime_type__isw, $mime_type__n, $mime_type__nic, $mime_type__nie, $mime_type__niew, $mime_type__nisw, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasExportTemplatesListAsyncWithHttpInfo
     *
     * @param  bool $as_attachment (optional)
     * @param  bool $auto_sync_enabled (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $file_extension (optional)
     * @param  bool $file_extension__empty (optional)
     * @param  string[] $file_extension__ic (optional)
     * @param  string[] $file_extension__ie (optional)
     * @param  string[] $file_extension__iew (optional)
     * @param  string[] $file_extension__isw (optional)
     * @param  string[] $file_extension__n (optional)
     * @param  string[] $file_extension__nic (optional)
     * @param  string[] $file_extension__nie (optional)
     * @param  string[] $file_extension__niew (optional)
     * @param  string[] $file_extension__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mime_type (optional)
     * @param  bool $mime_type__empty (optional)
     * @param  string[] $mime_type__ic (optional)
     * @param  string[] $mime_type__ie (optional)
     * @param  string[] $mime_type__iew (optional)
     * @param  string[] $mime_type__isw (optional)
     * @param  string[] $mime_type__n (optional)
     * @param  string[] $mime_type__nic (optional)
     * @param  string[] $mime_type__nie (optional)
     * @param  string[] $mime_type__niew (optional)
     * @param  string[] $mime_type__nisw (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesListAsyncWithHttpInfo($as_attachment = null, $auto_sync_enabled = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $file_extension = null, $file_extension__empty = null, $file_extension__ic = null, $file_extension__ie = null, $file_extension__iew = null, $file_extension__isw = null, $file_extension__n = null, $file_extension__nic = null, $file_extension__nie = null, $file_extension__niew = null, $file_extension__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mime_type = null, $mime_type__empty = null, $mime_type__ic = null, $mime_type__ie = null, $mime_type__iew = null, $mime_type__isw = null, $mime_type__n = null, $mime_type__nic = null, $mime_type__nie = null, $mime_type__niew = null, $mime_type__nisw = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasExportTemplatesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedExportTemplateList';
        $request = $this->extrasExportTemplatesListRequest($as_attachment, $auto_sync_enabled, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $data_file_id, $data_file_id__n, $data_source_id, $data_source_id__n, $data_synced, $data_synced__empty, $data_synced__gt, $data_synced__gte, $data_synced__lt, $data_synced__lte, $data_synced__n, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $file_extension, $file_extension__empty, $file_extension__ic, $file_extension__ie, $file_extension__iew, $file_extension__isw, $file_extension__n, $file_extension__nic, $file_extension__nie, $file_extension__niew, $file_extension__nisw, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $mime_type, $mime_type__empty, $mime_type__ic, $mime_type__ie, $mime_type__iew, $mime_type__isw, $mime_type__n, $mime_type__nic, $mime_type__nie, $mime_type__niew, $mime_type__nisw, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasExportTemplatesList'
     *
     * @param  bool $as_attachment (optional)
     * @param  bool $auto_sync_enabled (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $data_file_id Data file (ID) (optional)
     * @param  int[] $data_file_id__n Data file (ID) (optional)
     * @param  int[] $data_source_id Data source (ID) (optional)
     * @param  int[] $data_source_id__n Data source (ID) (optional)
     * @param  \DateTime[] $data_synced (optional)
     * @param  bool $data_synced__empty (optional)
     * @param  \DateTime[] $data_synced__gt (optional)
     * @param  \DateTime[] $data_synced__gte (optional)
     * @param  \DateTime[] $data_synced__lt (optional)
     * @param  \DateTime[] $data_synced__lte (optional)
     * @param  \DateTime[] $data_synced__n (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $file_extension (optional)
     * @param  bool $file_extension__empty (optional)
     * @param  string[] $file_extension__ic (optional)
     * @param  string[] $file_extension__ie (optional)
     * @param  string[] $file_extension__iew (optional)
     * @param  string[] $file_extension__isw (optional)
     * @param  string[] $file_extension__n (optional)
     * @param  string[] $file_extension__nic (optional)
     * @param  string[] $file_extension__nie (optional)
     * @param  string[] $file_extension__niew (optional)
     * @param  string[] $file_extension__nisw (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $mime_type (optional)
     * @param  bool $mime_type__empty (optional)
     * @param  string[] $mime_type__ic (optional)
     * @param  string[] $mime_type__ie (optional)
     * @param  string[] $mime_type__iew (optional)
     * @param  string[] $mime_type__isw (optional)
     * @param  string[] $mime_type__n (optional)
     * @param  string[] $mime_type__nic (optional)
     * @param  string[] $mime_type__nie (optional)
     * @param  string[] $mime_type__niew (optional)
     * @param  string[] $mime_type__nisw (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasExportTemplatesListRequest($as_attachment = null, $auto_sync_enabled = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $data_file_id = null, $data_file_id__n = null, $data_source_id = null, $data_source_id__n = null, $data_synced = null, $data_synced__empty = null, $data_synced__gt = null, $data_synced__gte = null, $data_synced__lt = null, $data_synced__lte = null, $data_synced__n = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $file_extension = null, $file_extension__empty = null, $file_extension__ic = null, $file_extension__ie = null, $file_extension__iew = null, $file_extension__isw = null, $file_extension__n = null, $file_extension__nic = null, $file_extension__nie = null, $file_extension__niew = null, $file_extension__nisw = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $mime_type = null, $mime_type__empty = null, $mime_type__ic = null, $mime_type__ie = null, $mime_type__iew = null, $mime_type__isw = null, $mime_type__n = null, $mime_type__nic = null, $mime_type__nie = null, $mime_type__niew = null, $mime_type__nisw = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasExportTemplatesList'][0])
    {



































































































        $resourcePath = '/api/extras/export-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_attachment,
            'as_attachment', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auto_sync_enabled,
            'auto_sync_enabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_file_id,
            'data_file_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_file_id__n,
            'data_file_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_source_id,
            'data_source_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_source_id__n,
            'data_source_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced,
            'data_synced', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__empty,
            'data_synced__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__gt,
            'data_synced__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__gte,
            'data_synced__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__lt,
            'data_synced__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__lte,
            'data_synced__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data_synced__n,
            'data_synced__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_extension,
            'file_extension', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_extension__empty,
            'file_extension__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_extension__ic,
            'file_extension__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_extension__ie,
            'file_extension__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_extension__iew,
            'file_extension__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_extension__isw,
            'file_extension__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_extension__n,
            'file_extension__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_extension__nic,
            'file_extension__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_extension__nie,
            'file_extension__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_extension__niew,
            'file_extension__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_extension__nisw,
            'file_extension__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type,
            'mime_type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type__empty,
            'mime_type__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type__ic,
            'mime_type__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type__ie,
            'mime_type__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type__iew,
            'mime_type__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type__isw,
            'mime_type__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type__n,
            'mime_type__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type__nic,
            'mime_type__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type__nie,
            'mime_type__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type__niew,
            'mime_type__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type__nisw,
            'mime_type__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type,
            'object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ic,
            'object_type__ic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ie,
            'object_type__ie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__iew,
            'object_type__iew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__isw,
            'object_type__isw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__n,
            'object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nic,
            'object_type__nic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nie,
            'object_type__nie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__niew,
            'object_type__niew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nisw,
            'object_type__nisw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id,
            'object_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__n,
            'object_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasExportTemplatesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\PatchedExportTemplateRequest $patched_export_template_request patched_export_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExportTemplate
     */
    public function extrasExportTemplatesPartialUpdate($id, $patched_export_template_request = null, string $contentType = self::contentTypes['extrasExportTemplatesPartialUpdate'][0])
    {
        list($response) = $this->extrasExportTemplatesPartialUpdateWithHttpInfo($id, $patched_export_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasExportTemplatesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\PatchedExportTemplateRequest $patched_export_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExportTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasExportTemplatesPartialUpdateWithHttpInfo($id, $patched_export_template_request = null, string $contentType = self::contentTypes['extrasExportTemplatesPartialUpdate'][0])
    {
        $request = $this->extrasExportTemplatesPartialUpdateRequest($id, $patched_export_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ExportTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ExportTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExportTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ExportTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExportTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasExportTemplatesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\PatchedExportTemplateRequest $patched_export_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesPartialUpdateAsync($id, $patched_export_template_request = null, string $contentType = self::contentTypes['extrasExportTemplatesPartialUpdate'][0])
    {
        return $this->extrasExportTemplatesPartialUpdateAsyncWithHttpInfo($id, $patched_export_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasExportTemplatesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\PatchedExportTemplateRequest $patched_export_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesPartialUpdateAsyncWithHttpInfo($id, $patched_export_template_request = null, string $contentType = self::contentTypes['extrasExportTemplatesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ExportTemplate';
        $request = $this->extrasExportTemplatesPartialUpdateRequest($id, $patched_export_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasExportTemplatesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\PatchedExportTemplateRequest $patched_export_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasExportTemplatesPartialUpdateRequest($id, $patched_export_template_request = null, string $contentType = self::contentTypes['extrasExportTemplatesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasExportTemplatesPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/export-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_export_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_export_template_request));
            } else {
                $httpBody = $patched_export_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasExportTemplatesRetrieve
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExportTemplate
     */
    public function extrasExportTemplatesRetrieve($id, string $contentType = self::contentTypes['extrasExportTemplatesRetrieve'][0])
    {
        list($response) = $this->extrasExportTemplatesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasExportTemplatesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExportTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasExportTemplatesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasExportTemplatesRetrieve'][0])
    {
        $request = $this->extrasExportTemplatesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ExportTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ExportTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExportTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ExportTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExportTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasExportTemplatesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesRetrieveAsync($id, string $contentType = self::contentTypes['extrasExportTemplatesRetrieve'][0])
    {
        return $this->extrasExportTemplatesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasExportTemplatesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasExportTemplatesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ExportTemplate';
        $request = $this->extrasExportTemplatesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasExportTemplatesRetrieve'
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasExportTemplatesRetrieveRequest($id, string $contentType = self::contentTypes['extrasExportTemplatesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasExportTemplatesRetrieve'
            );
        }


        $resourcePath = '/api/extras/export-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasExportTemplatesSyncCreate
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesSyncCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExportTemplate
     */
    public function extrasExportTemplatesSyncCreate($id, $export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesSyncCreate'][0])
    {
        list($response) = $this->extrasExportTemplatesSyncCreateWithHttpInfo($id, $export_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasExportTemplatesSyncCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesSyncCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExportTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasExportTemplatesSyncCreateWithHttpInfo($id, $export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesSyncCreate'][0])
    {
        $request = $this->extrasExportTemplatesSyncCreateRequest($id, $export_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ExportTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ExportTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExportTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ExportTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExportTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasExportTemplatesSyncCreateAsync
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesSyncCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesSyncCreateAsync($id, $export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesSyncCreate'][0])
    {
        return $this->extrasExportTemplatesSyncCreateAsyncWithHttpInfo($id, $export_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasExportTemplatesSyncCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesSyncCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesSyncCreateAsyncWithHttpInfo($id, $export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesSyncCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ExportTemplate';
        $request = $this->extrasExportTemplatesSyncCreateRequest($id, $export_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasExportTemplatesSyncCreate'
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesSyncCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasExportTemplatesSyncCreateRequest($id, $export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesSyncCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasExportTemplatesSyncCreate'
            );
        }

        // verify the required parameter 'export_template_request' is set
        if ($export_template_request === null || (is_array($export_template_request) && count($export_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_template_request when calling extrasExportTemplatesSyncCreate'
            );
        }


        $resourcePath = '/api/extras/export-templates/{id}/sync/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($export_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($export_template_request));
            } else {
                $httpBody = $export_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasExportTemplatesUpdate
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExportTemplate
     */
    public function extrasExportTemplatesUpdate($id, $export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesUpdate'][0])
    {
        list($response) = $this->extrasExportTemplatesUpdateWithHttpInfo($id, $export_template_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasExportTemplatesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExportTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasExportTemplatesUpdateWithHttpInfo($id, $export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesUpdate'][0])
    {
        $request = $this->extrasExportTemplatesUpdateRequest($id, $export_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ExportTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ExportTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ExportTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ExportTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExportTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasExportTemplatesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesUpdateAsync($id, $export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesUpdate'][0])
    {
        return $this->extrasExportTemplatesUpdateAsyncWithHttpInfo($id, $export_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasExportTemplatesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasExportTemplatesUpdateAsyncWithHttpInfo($id, $export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ExportTemplate';
        $request = $this->extrasExportTemplatesUpdateRequest($id, $export_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasExportTemplatesUpdate'
     *
     * @param  int $id A unique integer value identifying this export template. (required)
     * @param  \OpenAPI\Client\Model\ExportTemplateRequest $export_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasExportTemplatesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasExportTemplatesUpdateRequest($id, $export_template_request, string $contentType = self::contentTypes['extrasExportTemplatesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasExportTemplatesUpdate'
            );
        }

        // verify the required parameter 'export_template_request' is set
        if ($export_template_request === null || (is_array($export_template_request) && count($export_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_template_request when calling extrasExportTemplatesUpdate'
            );
        }


        $resourcePath = '/api/extras/export-templates/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($export_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($export_template_request));
            } else {
                $httpBody = $export_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasImageAttachmentsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasImageAttachmentsBulkDestroy($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkDestroy'][0])
    {
        $this->extrasImageAttachmentsBulkDestroyWithHttpInfo($image_attachment_request, $contentType);
    }

    /**
     * Operation extrasImageAttachmentsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasImageAttachmentsBulkDestroyWithHttpInfo($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkDestroy'][0])
    {
        $request = $this->extrasImageAttachmentsBulkDestroyRequest($image_attachment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasImageAttachmentsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsBulkDestroyAsync($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkDestroy'][0])
    {
        return $this->extrasImageAttachmentsBulkDestroyAsyncWithHttpInfo($image_attachment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasImageAttachmentsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsBulkDestroyAsyncWithHttpInfo($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasImageAttachmentsBulkDestroyRequest($image_attachment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasImageAttachmentsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasImageAttachmentsBulkDestroyRequest($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkDestroy'][0])
    {

        // verify the required parameter 'image_attachment_request' is set
        if ($image_attachment_request === null || (is_array($image_attachment_request) && count($image_attachment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_attachment_request when calling extrasImageAttachmentsBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/image-attachments/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($image_attachment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($image_attachment_request));
            } else {
                $httpBody = $image_attachment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasImageAttachmentsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageAttachment[]
     */
    public function extrasImageAttachmentsBulkPartialUpdate($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasImageAttachmentsBulkPartialUpdateWithHttpInfo($image_attachment_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasImageAttachmentsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageAttachment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasImageAttachmentsBulkPartialUpdateWithHttpInfo($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkPartialUpdate'][0])
    {
        $request = $this->extrasImageAttachmentsBulkPartialUpdateRequest($image_attachment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageAttachment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ImageAttachment[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageAttachment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageAttachment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageAttachment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasImageAttachmentsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsBulkPartialUpdateAsync($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkPartialUpdate'][0])
    {
        return $this->extrasImageAttachmentsBulkPartialUpdateAsyncWithHttpInfo($image_attachment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasImageAttachmentsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsBulkPartialUpdateAsyncWithHttpInfo($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ImageAttachment[]';
        $request = $this->extrasImageAttachmentsBulkPartialUpdateRequest($image_attachment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasImageAttachmentsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasImageAttachmentsBulkPartialUpdateRequest($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'image_attachment_request' is set
        if ($image_attachment_request === null || (is_array($image_attachment_request) && count($image_attachment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_attachment_request when calling extrasImageAttachmentsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/image-attachments/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($image_attachment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($image_attachment_request));
            } else {
                $httpBody = $image_attachment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasImageAttachmentsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageAttachment[]
     */
    public function extrasImageAttachmentsBulkUpdate($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkUpdate'][0])
    {
        list($response) = $this->extrasImageAttachmentsBulkUpdateWithHttpInfo($image_attachment_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasImageAttachmentsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageAttachment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasImageAttachmentsBulkUpdateWithHttpInfo($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkUpdate'][0])
    {
        $request = $this->extrasImageAttachmentsBulkUpdateRequest($image_attachment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageAttachment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ImageAttachment[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageAttachment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageAttachment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageAttachment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasImageAttachmentsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsBulkUpdateAsync($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkUpdate'][0])
    {
        return $this->extrasImageAttachmentsBulkUpdateAsyncWithHttpInfo($image_attachment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasImageAttachmentsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsBulkUpdateAsyncWithHttpInfo($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ImageAttachment[]';
        $request = $this->extrasImageAttachmentsBulkUpdateRequest($image_attachment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasImageAttachmentsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest[] $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasImageAttachmentsBulkUpdateRequest($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsBulkUpdate'][0])
    {

        // verify the required parameter 'image_attachment_request' is set
        if ($image_attachment_request === null || (is_array($image_attachment_request) && count($image_attachment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_attachment_request when calling extrasImageAttachmentsBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/image-attachments/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($image_attachment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($image_attachment_request));
            } else {
                $httpBody = $image_attachment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasImageAttachmentsCreate
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest $image_attachment_request image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageAttachment
     */
    public function extrasImageAttachmentsCreate($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsCreate'][0])
    {
        list($response) = $this->extrasImageAttachmentsCreateWithHttpInfo($image_attachment_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasImageAttachmentsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageAttachment, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasImageAttachmentsCreateWithHttpInfo($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsCreate'][0])
    {
        $request = $this->extrasImageAttachmentsCreateRequest($image_attachment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ImageAttachment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ImageAttachment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageAttachment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageAttachment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageAttachment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasImageAttachmentsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsCreateAsync($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsCreate'][0])
    {
        return $this->extrasImageAttachmentsCreateAsyncWithHttpInfo($image_attachment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasImageAttachmentsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsCreateAsyncWithHttpInfo($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ImageAttachment';
        $request = $this->extrasImageAttachmentsCreateRequest($image_attachment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasImageAttachmentsCreate'
     *
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasImageAttachmentsCreateRequest($image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsCreate'][0])
    {

        // verify the required parameter 'image_attachment_request' is set
        if ($image_attachment_request === null || (is_array($image_attachment_request) && count($image_attachment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_attachment_request when calling extrasImageAttachmentsCreate'
            );
        }


        $resourcePath = '/api/extras/image-attachments/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($image_attachment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($image_attachment_request));
            } else {
                $httpBody = $image_attachment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasImageAttachmentsDestroy
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasImageAttachmentsDestroy($id, string $contentType = self::contentTypes['extrasImageAttachmentsDestroy'][0])
    {
        $this->extrasImageAttachmentsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasImageAttachmentsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasImageAttachmentsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasImageAttachmentsDestroy'][0])
    {
        $request = $this->extrasImageAttachmentsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasImageAttachmentsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsDestroyAsync($id, string $contentType = self::contentTypes['extrasImageAttachmentsDestroy'][0])
    {
        return $this->extrasImageAttachmentsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasImageAttachmentsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasImageAttachmentsDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasImageAttachmentsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasImageAttachmentsDestroy'
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasImageAttachmentsDestroyRequest($id, string $contentType = self::contentTypes['extrasImageAttachmentsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasImageAttachmentsDestroy'
            );
        }


        $resourcePath = '/api/extras/image-attachments/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasImageAttachmentsList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  int[] $image_height image_height (optional)
     * @param  bool $image_height__empty image_height__empty (optional)
     * @param  int[] $image_height__gt image_height__gt (optional)
     * @param  int[] $image_height__gte image_height__gte (optional)
     * @param  int[] $image_height__lt image_height__lt (optional)
     * @param  int[] $image_height__lte image_height__lte (optional)
     * @param  int[] $image_height__n image_height__n (optional)
     * @param  int[] $image_width image_width (optional)
     * @param  bool $image_width__empty image_width__empty (optional)
     * @param  int[] $image_width__gt image_width__gt (optional)
     * @param  int[] $image_width__gte image_width__gte (optional)
     * @param  int[] $image_width__lt image_width__lt (optional)
     * @param  int[] $image_width__lte image_width__lte (optional)
     * @param  int[] $image_width__n image_width__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int[] $object_id object_id (optional)
     * @param  bool $object_id__empty object_id__empty (optional)
     * @param  int[] $object_id__gt object_id__gt (optional)
     * @param  int[] $object_id__gte object_id__gte (optional)
     * @param  int[] $object_id__lt object_id__lt (optional)
     * @param  int[] $object_id__lte object_id__lte (optional)
     * @param  int[] $object_id__n object_id__n (optional)
     * @param  string $object_type object_type (optional)
     * @param  string $object_type__n object_type__n (optional)
     * @param  int $object_type_id object_type_id (optional)
     * @param  int $object_type_id__n object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedImageAttachmentList
     */
    public function extrasImageAttachmentsList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $image_height = null, $image_height__empty = null, $image_height__gt = null, $image_height__gte = null, $image_height__lt = null, $image_height__lte = null, $image_height__n = null, $image_width = null, $image_width__empty = null, $image_width__gt = null, $image_width__gte = null, $image_width__lt = null, $image_width__lte = null, $image_width__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_id = null, $object_id__empty = null, $object_id__gt = null, $object_id__gte = null, $object_id__lt = null, $object_id__lte = null, $object_id__n = null, $object_type = null, $object_type__n = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasImageAttachmentsList'][0])
    {
        list($response) = $this->extrasImageAttachmentsListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $image_height, $image_height__empty, $image_height__gt, $image_height__gte, $image_height__lt, $image_height__lte, $image_height__n, $image_width, $image_width__empty, $image_width__gt, $image_width__gte, $image_width__lt, $image_width__lte, $image_width__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_id, $object_id__empty, $object_id__gt, $object_id__gte, $object_id__lt, $object_id__lte, $object_id__n, $object_type, $object_type__n, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasImageAttachmentsListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $image_height (optional)
     * @param  bool $image_height__empty (optional)
     * @param  int[] $image_height__gt (optional)
     * @param  int[] $image_height__gte (optional)
     * @param  int[] $image_height__lt (optional)
     * @param  int[] $image_height__lte (optional)
     * @param  int[] $image_height__n (optional)
     * @param  int[] $image_width (optional)
     * @param  bool $image_width__empty (optional)
     * @param  int[] $image_width__gt (optional)
     * @param  int[] $image_width__gte (optional)
     * @param  int[] $image_width__lt (optional)
     * @param  int[] $image_width__lte (optional)
     * @param  int[] $image_width__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $object_id (optional)
     * @param  bool $object_id__empty (optional)
     * @param  int[] $object_id__gt (optional)
     * @param  int[] $object_id__gte (optional)
     * @param  int[] $object_id__lt (optional)
     * @param  int[] $object_id__lte (optional)
     * @param  int[] $object_id__n (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__n (optional)
     * @param  int $object_type_id (optional)
     * @param  int $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedImageAttachmentList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasImageAttachmentsListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $image_height = null, $image_height__empty = null, $image_height__gt = null, $image_height__gte = null, $image_height__lt = null, $image_height__lte = null, $image_height__n = null, $image_width = null, $image_width__empty = null, $image_width__gt = null, $image_width__gte = null, $image_width__lt = null, $image_width__lte = null, $image_width__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_id = null, $object_id__empty = null, $object_id__gt = null, $object_id__gte = null, $object_id__lt = null, $object_id__lte = null, $object_id__n = null, $object_type = null, $object_type__n = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasImageAttachmentsList'][0])
    {
        $request = $this->extrasImageAttachmentsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $image_height, $image_height__empty, $image_height__gt, $image_height__gte, $image_height__lt, $image_height__lte, $image_height__n, $image_width, $image_width__empty, $image_width__gt, $image_width__gte, $image_width__lt, $image_width__lte, $image_width__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_id, $object_id__empty, $object_id__gt, $object_id__gte, $object_id__lt, $object_id__lte, $object_id__n, $object_type, $object_type__n, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedImageAttachmentList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedImageAttachmentList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedImageAttachmentList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedImageAttachmentList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedImageAttachmentList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasImageAttachmentsListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $image_height (optional)
     * @param  bool $image_height__empty (optional)
     * @param  int[] $image_height__gt (optional)
     * @param  int[] $image_height__gte (optional)
     * @param  int[] $image_height__lt (optional)
     * @param  int[] $image_height__lte (optional)
     * @param  int[] $image_height__n (optional)
     * @param  int[] $image_width (optional)
     * @param  bool $image_width__empty (optional)
     * @param  int[] $image_width__gt (optional)
     * @param  int[] $image_width__gte (optional)
     * @param  int[] $image_width__lt (optional)
     * @param  int[] $image_width__lte (optional)
     * @param  int[] $image_width__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $object_id (optional)
     * @param  bool $object_id__empty (optional)
     * @param  int[] $object_id__gt (optional)
     * @param  int[] $object_id__gte (optional)
     * @param  int[] $object_id__lt (optional)
     * @param  int[] $object_id__lte (optional)
     * @param  int[] $object_id__n (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__n (optional)
     * @param  int $object_type_id (optional)
     * @param  int $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $image_height = null, $image_height__empty = null, $image_height__gt = null, $image_height__gte = null, $image_height__lt = null, $image_height__lte = null, $image_height__n = null, $image_width = null, $image_width__empty = null, $image_width__gt = null, $image_width__gte = null, $image_width__lt = null, $image_width__lte = null, $image_width__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_id = null, $object_id__empty = null, $object_id__gt = null, $object_id__gte = null, $object_id__lt = null, $object_id__lte = null, $object_id__n = null, $object_type = null, $object_type__n = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasImageAttachmentsList'][0])
    {
        return $this->extrasImageAttachmentsListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $image_height, $image_height__empty, $image_height__gt, $image_height__gte, $image_height__lt, $image_height__lte, $image_height__n, $image_width, $image_width__empty, $image_width__gt, $image_width__gte, $image_width__lt, $image_width__lte, $image_width__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_id, $object_id__empty, $object_id__gt, $object_id__gte, $object_id__lt, $object_id__lte, $object_id__n, $object_type, $object_type__n, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasImageAttachmentsListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $image_height (optional)
     * @param  bool $image_height__empty (optional)
     * @param  int[] $image_height__gt (optional)
     * @param  int[] $image_height__gte (optional)
     * @param  int[] $image_height__lt (optional)
     * @param  int[] $image_height__lte (optional)
     * @param  int[] $image_height__n (optional)
     * @param  int[] $image_width (optional)
     * @param  bool $image_width__empty (optional)
     * @param  int[] $image_width__gt (optional)
     * @param  int[] $image_width__gte (optional)
     * @param  int[] $image_width__lt (optional)
     * @param  int[] $image_width__lte (optional)
     * @param  int[] $image_width__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $object_id (optional)
     * @param  bool $object_id__empty (optional)
     * @param  int[] $object_id__gt (optional)
     * @param  int[] $object_id__gte (optional)
     * @param  int[] $object_id__lt (optional)
     * @param  int[] $object_id__lte (optional)
     * @param  int[] $object_id__n (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__n (optional)
     * @param  int $object_type_id (optional)
     * @param  int $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $image_height = null, $image_height__empty = null, $image_height__gt = null, $image_height__gte = null, $image_height__lt = null, $image_height__lte = null, $image_height__n = null, $image_width = null, $image_width__empty = null, $image_width__gt = null, $image_width__gte = null, $image_width__lt = null, $image_width__lte = null, $image_width__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_id = null, $object_id__empty = null, $object_id__gt = null, $object_id__gte = null, $object_id__lt = null, $object_id__lte = null, $object_id__n = null, $object_type = null, $object_type__n = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasImageAttachmentsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedImageAttachmentList';
        $request = $this->extrasImageAttachmentsListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $image_height, $image_height__empty, $image_height__gt, $image_height__gte, $image_height__lt, $image_height__lte, $image_height__n, $image_width, $image_width__empty, $image_width__gt, $image_width__gte, $image_width__lt, $image_width__lte, $image_width__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_id, $object_id__empty, $object_id__gt, $object_id__gte, $object_id__lt, $object_id__lte, $object_id__n, $object_type, $object_type__n, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasImageAttachmentsList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int[] $image_height (optional)
     * @param  bool $image_height__empty (optional)
     * @param  int[] $image_height__gt (optional)
     * @param  int[] $image_height__gte (optional)
     * @param  int[] $image_height__lt (optional)
     * @param  int[] $image_height__lte (optional)
     * @param  int[] $image_height__n (optional)
     * @param  int[] $image_width (optional)
     * @param  bool $image_width__empty (optional)
     * @param  int[] $image_width__gt (optional)
     * @param  int[] $image_width__gte (optional)
     * @param  int[] $image_width__lt (optional)
     * @param  int[] $image_width__lte (optional)
     * @param  int[] $image_width__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $object_id (optional)
     * @param  bool $object_id__empty (optional)
     * @param  int[] $object_id__gt (optional)
     * @param  int[] $object_id__gte (optional)
     * @param  int[] $object_id__lt (optional)
     * @param  int[] $object_id__lte (optional)
     * @param  int[] $object_id__n (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__n (optional)
     * @param  int $object_type_id (optional)
     * @param  int $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasImageAttachmentsListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $image_height = null, $image_height__empty = null, $image_height__gt = null, $image_height__gte = null, $image_height__lt = null, $image_height__lte = null, $image_height__n = null, $image_width = null, $image_width__empty = null, $image_width__gt = null, $image_width__gte = null, $image_width__lt = null, $image_width__lte = null, $image_width__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_id = null, $object_id__empty = null, $object_id__gt = null, $object_id__gte = null, $object_id__lt = null, $object_id__lte = null, $object_id__n = null, $object_type = null, $object_type__n = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasImageAttachmentsList'][0])
    {


































































        $resourcePath = '/api/extras/image-attachments/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_height,
            'image_height', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_height__empty,
            'image_height__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_height__gt,
            'image_height__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_height__gte,
            'image_height__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_height__lt,
            'image_height__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_height__lte,
            'image_height__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_height__n,
            'image_height__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_width,
            'image_width', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_width__empty,
            'image_width__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_width__gt,
            'image_width__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_width__gte,
            'image_width__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_width__lt,
            'image_width__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_width__lte,
            'image_width__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_width__n,
            'image_width__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id,
            'object_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__empty,
            'object_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__gt,
            'object_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__gte,
            'object_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__lt,
            'object_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__lte,
            'object_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_id__n,
            'object_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type,
            'object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__n,
            'object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id,
            'object_type_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__n,
            'object_type_id__n', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasImageAttachmentsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  \OpenAPI\Client\Model\PatchedImageAttachmentRequest $patched_image_attachment_request patched_image_attachment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageAttachment
     */
    public function extrasImageAttachmentsPartialUpdate($id, $patched_image_attachment_request = null, string $contentType = self::contentTypes['extrasImageAttachmentsPartialUpdate'][0])
    {
        list($response) = $this->extrasImageAttachmentsPartialUpdateWithHttpInfo($id, $patched_image_attachment_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasImageAttachmentsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  \OpenAPI\Client\Model\PatchedImageAttachmentRequest $patched_image_attachment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageAttachment, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasImageAttachmentsPartialUpdateWithHttpInfo($id, $patched_image_attachment_request = null, string $contentType = self::contentTypes['extrasImageAttachmentsPartialUpdate'][0])
    {
        $request = $this->extrasImageAttachmentsPartialUpdateRequest($id, $patched_image_attachment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageAttachment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ImageAttachment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageAttachment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageAttachment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageAttachment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasImageAttachmentsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  \OpenAPI\Client\Model\PatchedImageAttachmentRequest $patched_image_attachment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsPartialUpdateAsync($id, $patched_image_attachment_request = null, string $contentType = self::contentTypes['extrasImageAttachmentsPartialUpdate'][0])
    {
        return $this->extrasImageAttachmentsPartialUpdateAsyncWithHttpInfo($id, $patched_image_attachment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasImageAttachmentsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  \OpenAPI\Client\Model\PatchedImageAttachmentRequest $patched_image_attachment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsPartialUpdateAsyncWithHttpInfo($id, $patched_image_attachment_request = null, string $contentType = self::contentTypes['extrasImageAttachmentsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ImageAttachment';
        $request = $this->extrasImageAttachmentsPartialUpdateRequest($id, $patched_image_attachment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasImageAttachmentsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  \OpenAPI\Client\Model\PatchedImageAttachmentRequest $patched_image_attachment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasImageAttachmentsPartialUpdateRequest($id, $patched_image_attachment_request = null, string $contentType = self::contentTypes['extrasImageAttachmentsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasImageAttachmentsPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/image-attachments/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_image_attachment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_image_attachment_request));
            } else {
                $httpBody = $patched_image_attachment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasImageAttachmentsRetrieve
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageAttachment
     */
    public function extrasImageAttachmentsRetrieve($id, string $contentType = self::contentTypes['extrasImageAttachmentsRetrieve'][0])
    {
        list($response) = $this->extrasImageAttachmentsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasImageAttachmentsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageAttachment, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasImageAttachmentsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasImageAttachmentsRetrieve'][0])
    {
        $request = $this->extrasImageAttachmentsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageAttachment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ImageAttachment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageAttachment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageAttachment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageAttachment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasImageAttachmentsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsRetrieveAsync($id, string $contentType = self::contentTypes['extrasImageAttachmentsRetrieve'][0])
    {
        return $this->extrasImageAttachmentsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasImageAttachmentsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasImageAttachmentsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ImageAttachment';
        $request = $this->extrasImageAttachmentsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasImageAttachmentsRetrieve'
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasImageAttachmentsRetrieveRequest($id, string $contentType = self::contentTypes['extrasImageAttachmentsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasImageAttachmentsRetrieve'
            );
        }


        $resourcePath = '/api/extras/image-attachments/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasImageAttachmentsUpdate
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest $image_attachment_request image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageAttachment
     */
    public function extrasImageAttachmentsUpdate($id, $image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsUpdate'][0])
    {
        list($response) = $this->extrasImageAttachmentsUpdateWithHttpInfo($id, $image_attachment_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasImageAttachmentsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageAttachment, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasImageAttachmentsUpdateWithHttpInfo($id, $image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsUpdate'][0])
    {
        $request = $this->extrasImageAttachmentsUpdateRequest($id, $image_attachment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageAttachment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ImageAttachment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageAttachment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageAttachment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageAttachment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasImageAttachmentsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsUpdateAsync($id, $image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsUpdate'][0])
    {
        return $this->extrasImageAttachmentsUpdateAsyncWithHttpInfo($id, $image_attachment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasImageAttachmentsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasImageAttachmentsUpdateAsyncWithHttpInfo($id, $image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ImageAttachment';
        $request = $this->extrasImageAttachmentsUpdateRequest($id, $image_attachment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasImageAttachmentsUpdate'
     *
     * @param  int $id A unique integer value identifying this image attachment. (required)
     * @param  \OpenAPI\Client\Model\ImageAttachmentRequest $image_attachment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasImageAttachmentsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasImageAttachmentsUpdateRequest($id, $image_attachment_request, string $contentType = self::contentTypes['extrasImageAttachmentsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasImageAttachmentsUpdate'
            );
        }

        // verify the required parameter 'image_attachment_request' is set
        if ($image_attachment_request === null || (is_array($image_attachment_request) && count($image_attachment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_attachment_request when calling extrasImageAttachmentsUpdate'
            );
        }


        $resourcePath = '/api/extras/image-attachments/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($image_attachment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($image_attachment_request));
            } else {
                $httpBody = $image_attachment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasJournalEntriesBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasJournalEntriesBulkDestroy($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkDestroy'][0])
    {
        $this->extrasJournalEntriesBulkDestroyWithHttpInfo($journal_entry_request, $contentType);
    }

    /**
     * Operation extrasJournalEntriesBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasJournalEntriesBulkDestroyWithHttpInfo($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkDestroy'][0])
    {
        $request = $this->extrasJournalEntriesBulkDestroyRequest($journal_entry_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasJournalEntriesBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesBulkDestroyAsync($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkDestroy'][0])
    {
        return $this->extrasJournalEntriesBulkDestroyAsyncWithHttpInfo($journal_entry_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasJournalEntriesBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesBulkDestroyAsyncWithHttpInfo($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasJournalEntriesBulkDestroyRequest($journal_entry_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasJournalEntriesBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasJournalEntriesBulkDestroyRequest($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkDestroy'][0])
    {

        // verify the required parameter 'journal_entry_request' is set
        if ($journal_entry_request === null || (is_array($journal_entry_request) && count($journal_entry_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_entry_request when calling extrasJournalEntriesBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/journal-entries/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($journal_entry_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($journal_entry_request));
            } else {
                $httpBody = $journal_entry_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasJournalEntriesBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\JournalEntry[]
     */
    public function extrasJournalEntriesBulkPartialUpdate($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasJournalEntriesBulkPartialUpdateWithHttpInfo($journal_entry_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasJournalEntriesBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\JournalEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasJournalEntriesBulkPartialUpdateWithHttpInfo($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkPartialUpdate'][0])
    {
        $request = $this->extrasJournalEntriesBulkPartialUpdateRequest($journal_entry_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\JournalEntry[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\JournalEntry[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\JournalEntry[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\JournalEntry[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\JournalEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasJournalEntriesBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesBulkPartialUpdateAsync($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkPartialUpdate'][0])
    {
        return $this->extrasJournalEntriesBulkPartialUpdateAsyncWithHttpInfo($journal_entry_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasJournalEntriesBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesBulkPartialUpdateAsyncWithHttpInfo($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\JournalEntry[]';
        $request = $this->extrasJournalEntriesBulkPartialUpdateRequest($journal_entry_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasJournalEntriesBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasJournalEntriesBulkPartialUpdateRequest($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkPartialUpdate'][0])
    {

        // verify the required parameter 'journal_entry_request' is set
        if ($journal_entry_request === null || (is_array($journal_entry_request) && count($journal_entry_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_entry_request when calling extrasJournalEntriesBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/journal-entries/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($journal_entry_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($journal_entry_request));
            } else {
                $httpBody = $journal_entry_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasJournalEntriesBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\JournalEntry[]
     */
    public function extrasJournalEntriesBulkUpdate($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkUpdate'][0])
    {
        list($response) = $this->extrasJournalEntriesBulkUpdateWithHttpInfo($journal_entry_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasJournalEntriesBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\JournalEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasJournalEntriesBulkUpdateWithHttpInfo($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkUpdate'][0])
    {
        $request = $this->extrasJournalEntriesBulkUpdateRequest($journal_entry_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\JournalEntry[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\JournalEntry[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\JournalEntry[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\JournalEntry[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\JournalEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasJournalEntriesBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesBulkUpdateAsync($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkUpdate'][0])
    {
        return $this->extrasJournalEntriesBulkUpdateAsyncWithHttpInfo($journal_entry_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasJournalEntriesBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesBulkUpdateAsyncWithHttpInfo($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\JournalEntry[]';
        $request = $this->extrasJournalEntriesBulkUpdateRequest($journal_entry_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasJournalEntriesBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\JournalEntryRequest[] $journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasJournalEntriesBulkUpdateRequest($journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesBulkUpdate'][0])
    {

        // verify the required parameter 'journal_entry_request' is set
        if ($journal_entry_request === null || (is_array($journal_entry_request) && count($journal_entry_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_entry_request when calling extrasJournalEntriesBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/journal-entries/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($journal_entry_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($journal_entry_request));
            } else {
                $httpBody = $journal_entry_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasJournalEntriesCreate
     *
     * @param  \OpenAPI\Client\Model\WritableJournalEntryRequest $writable_journal_entry_request writable_journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\JournalEntry
     */
    public function extrasJournalEntriesCreate($writable_journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesCreate'][0])
    {
        list($response) = $this->extrasJournalEntriesCreateWithHttpInfo($writable_journal_entry_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasJournalEntriesCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableJournalEntryRequest $writable_journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\JournalEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasJournalEntriesCreateWithHttpInfo($writable_journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesCreate'][0])
    {
        $request = $this->extrasJournalEntriesCreateRequest($writable_journal_entry_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\JournalEntry' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\JournalEntry' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\JournalEntry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\JournalEntry';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\JournalEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasJournalEntriesCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WritableJournalEntryRequest $writable_journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesCreateAsync($writable_journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesCreate'][0])
    {
        return $this->extrasJournalEntriesCreateAsyncWithHttpInfo($writable_journal_entry_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasJournalEntriesCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WritableJournalEntryRequest $writable_journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesCreateAsyncWithHttpInfo($writable_journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\JournalEntry';
        $request = $this->extrasJournalEntriesCreateRequest($writable_journal_entry_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasJournalEntriesCreate'
     *
     * @param  \OpenAPI\Client\Model\WritableJournalEntryRequest $writable_journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasJournalEntriesCreateRequest($writable_journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesCreate'][0])
    {

        // verify the required parameter 'writable_journal_entry_request' is set
        if ($writable_journal_entry_request === null || (is_array($writable_journal_entry_request) && count($writable_journal_entry_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_journal_entry_request when calling extrasJournalEntriesCreate'
            );
        }


        $resourcePath = '/api/extras/journal-entries/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_journal_entry_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_journal_entry_request));
            } else {
                $httpBody = $writable_journal_entry_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasJournalEntriesDestroy
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasJournalEntriesDestroy($id, string $contentType = self::contentTypes['extrasJournalEntriesDestroy'][0])
    {
        $this->extrasJournalEntriesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasJournalEntriesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasJournalEntriesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasJournalEntriesDestroy'][0])
    {
        $request = $this->extrasJournalEntriesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasJournalEntriesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesDestroyAsync($id, string $contentType = self::contentTypes['extrasJournalEntriesDestroy'][0])
    {
        return $this->extrasJournalEntriesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasJournalEntriesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasJournalEntriesDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasJournalEntriesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasJournalEntriesDestroy'
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasJournalEntriesDestroyRequest($id, string $contentType = self::contentTypes['extrasJournalEntriesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasJournalEntriesDestroy'
            );
        }


        $resourcePath = '/api/extras/journal-entries/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasJournalEntriesList
     *
     * @param  int[] $assigned_object_id assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n assigned_object_id__n (optional)
     * @param  string $assigned_object_type assigned_object_type (optional)
     * @param  string $assigned_object_type__n assigned_object_type__n (optional)
     * @param  int[] $assigned_object_type_id assigned_object_type_id (optional)
     * @param  int[] $assigned_object_type_id__n assigned_object_type_id__n (optional)
     * @param  \DateTime $created_after created_after (optional)
     * @param  \DateTime $created_before created_before (optional)
     * @param  string[] $created_by User (name) (optional)
     * @param  string[] $created_by__n User (name) (optional)
     * @param  int[] $created_by_id User (ID) (optional)
     * @param  int[] $created_by_id__n User (ID) (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  string[] $kind kind (optional)
     * @param  string[] $kind__n kind__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedJournalEntryList
     */
    public function extrasJournalEntriesList($assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $assigned_object_type_id = null, $assigned_object_type_id__n = null, $created_after = null, $created_before = null, $created_by = null, $created_by__n = null, $created_by_id = null, $created_by_id__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $kind = null, $kind__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasJournalEntriesList'][0])
    {
        list($response) = $this->extrasJournalEntriesListWithHttpInfo($assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $assigned_object_type_id, $assigned_object_type_id__n, $created_after, $created_before, $created_by, $created_by__n, $created_by_id, $created_by_id__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $kind, $kind__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasJournalEntriesListWithHttpInfo
     *
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  string $assigned_object_type (optional)
     * @param  string $assigned_object_type__n (optional)
     * @param  int[] $assigned_object_type_id (optional)
     * @param  int[] $assigned_object_type_id__n (optional)
     * @param  \DateTime $created_after (optional)
     * @param  \DateTime $created_before (optional)
     * @param  string[] $created_by User (name) (optional)
     * @param  string[] $created_by__n User (name) (optional)
     * @param  int[] $created_by_id User (ID) (optional)
     * @param  int[] $created_by_id__n User (ID) (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $kind (optional)
     * @param  string[] $kind__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedJournalEntryList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasJournalEntriesListWithHttpInfo($assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $assigned_object_type_id = null, $assigned_object_type_id__n = null, $created_after = null, $created_before = null, $created_by = null, $created_by__n = null, $created_by_id = null, $created_by_id__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $kind = null, $kind__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasJournalEntriesList'][0])
    {
        $request = $this->extrasJournalEntriesListRequest($assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $assigned_object_type_id, $assigned_object_type_id__n, $created_after, $created_before, $created_by, $created_by__n, $created_by_id, $created_by_id__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $kind, $kind__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedJournalEntryList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedJournalEntryList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedJournalEntryList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedJournalEntryList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedJournalEntryList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasJournalEntriesListAsync
     *
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  string $assigned_object_type (optional)
     * @param  string $assigned_object_type__n (optional)
     * @param  int[] $assigned_object_type_id (optional)
     * @param  int[] $assigned_object_type_id__n (optional)
     * @param  \DateTime $created_after (optional)
     * @param  \DateTime $created_before (optional)
     * @param  string[] $created_by User (name) (optional)
     * @param  string[] $created_by__n User (name) (optional)
     * @param  int[] $created_by_id User (ID) (optional)
     * @param  int[] $created_by_id__n User (ID) (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $kind (optional)
     * @param  string[] $kind__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesListAsync($assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $assigned_object_type_id = null, $assigned_object_type_id__n = null, $created_after = null, $created_before = null, $created_by = null, $created_by__n = null, $created_by_id = null, $created_by_id__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $kind = null, $kind__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasJournalEntriesList'][0])
    {
        return $this->extrasJournalEntriesListAsyncWithHttpInfo($assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $assigned_object_type_id, $assigned_object_type_id__n, $created_after, $created_before, $created_by, $created_by__n, $created_by_id, $created_by_id__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $kind, $kind__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasJournalEntriesListAsyncWithHttpInfo
     *
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  string $assigned_object_type (optional)
     * @param  string $assigned_object_type__n (optional)
     * @param  int[] $assigned_object_type_id (optional)
     * @param  int[] $assigned_object_type_id__n (optional)
     * @param  \DateTime $created_after (optional)
     * @param  \DateTime $created_before (optional)
     * @param  string[] $created_by User (name) (optional)
     * @param  string[] $created_by__n User (name) (optional)
     * @param  int[] $created_by_id User (ID) (optional)
     * @param  int[] $created_by_id__n User (ID) (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $kind (optional)
     * @param  string[] $kind__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesListAsyncWithHttpInfo($assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $assigned_object_type_id = null, $assigned_object_type_id__n = null, $created_after = null, $created_before = null, $created_by = null, $created_by__n = null, $created_by_id = null, $created_by_id__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $kind = null, $kind__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasJournalEntriesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedJournalEntryList';
        $request = $this->extrasJournalEntriesListRequest($assigned_object_id, $assigned_object_id__empty, $assigned_object_id__gt, $assigned_object_id__gte, $assigned_object_id__lt, $assigned_object_id__lte, $assigned_object_id__n, $assigned_object_type, $assigned_object_type__n, $assigned_object_type_id, $assigned_object_type_id__n, $created_after, $created_before, $created_by, $created_by__n, $created_by_id, $created_by_id__n, $created_by_request, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $kind, $kind__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $offset, $ordering, $q, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasJournalEntriesList'
     *
     * @param  int[] $assigned_object_id (optional)
     * @param  bool $assigned_object_id__empty (optional)
     * @param  int[] $assigned_object_id__gt (optional)
     * @param  int[] $assigned_object_id__gte (optional)
     * @param  int[] $assigned_object_id__lt (optional)
     * @param  int[] $assigned_object_id__lte (optional)
     * @param  int[] $assigned_object_id__n (optional)
     * @param  string $assigned_object_type (optional)
     * @param  string $assigned_object_type__n (optional)
     * @param  int[] $assigned_object_type_id (optional)
     * @param  int[] $assigned_object_type_id__n (optional)
     * @param  \DateTime $created_after (optional)
     * @param  \DateTime $created_before (optional)
     * @param  string[] $created_by User (name) (optional)
     * @param  string[] $created_by__n User (name) (optional)
     * @param  int[] $created_by_id User (ID) (optional)
     * @param  int[] $created_by_id__n User (ID) (optional)
     * @param  string $created_by_request (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  string[] $kind (optional)
     * @param  string[] $kind__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasJournalEntriesListRequest($assigned_object_id = null, $assigned_object_id__empty = null, $assigned_object_id__gt = null, $assigned_object_id__gte = null, $assigned_object_id__lt = null, $assigned_object_id__lte = null, $assigned_object_id__n = null, $assigned_object_type = null, $assigned_object_type__n = null, $assigned_object_type_id = null, $assigned_object_type_id__n = null, $created_after = null, $created_before = null, $created_by = null, $created_by__n = null, $created_by_id = null, $created_by_id__n = null, $created_by_request = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $kind = null, $kind__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $offset = null, $ordering = null, $q = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasJournalEntriesList'][0])
    {












































        $resourcePath = '/api/extras/journal-entries/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id,
            'assigned_object_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__empty,
            'assigned_object_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__gt,
            'assigned_object_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__gte,
            'assigned_object_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__lt,
            'assigned_object_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__lte,
            'assigned_object_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_id__n,
            'assigned_object_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_type,
            'assigned_object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_type__n,
            'assigned_object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_type_id,
            'assigned_object_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_object_type_id__n,
            'assigned_object_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_after,
            'created_after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_before,
            'created_before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by,
            'created_by', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by__n,
            'created_by__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_id,
            'created_by_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_id__n,
            'created_by_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $kind,
            'kind', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $kind__n,
            'kind__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasJournalEntriesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableJournalEntryRequest $patched_writable_journal_entry_request patched_writable_journal_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\JournalEntry
     */
    public function extrasJournalEntriesPartialUpdate($id, $patched_writable_journal_entry_request = null, string $contentType = self::contentTypes['extrasJournalEntriesPartialUpdate'][0])
    {
        list($response) = $this->extrasJournalEntriesPartialUpdateWithHttpInfo($id, $patched_writable_journal_entry_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasJournalEntriesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableJournalEntryRequest $patched_writable_journal_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\JournalEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasJournalEntriesPartialUpdateWithHttpInfo($id, $patched_writable_journal_entry_request = null, string $contentType = self::contentTypes['extrasJournalEntriesPartialUpdate'][0])
    {
        $request = $this->extrasJournalEntriesPartialUpdateRequest($id, $patched_writable_journal_entry_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\JournalEntry' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\JournalEntry' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\JournalEntry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\JournalEntry';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\JournalEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasJournalEntriesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableJournalEntryRequest $patched_writable_journal_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesPartialUpdateAsync($id, $patched_writable_journal_entry_request = null, string $contentType = self::contentTypes['extrasJournalEntriesPartialUpdate'][0])
    {
        return $this->extrasJournalEntriesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_journal_entry_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasJournalEntriesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableJournalEntryRequest $patched_writable_journal_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesPartialUpdateAsyncWithHttpInfo($id, $patched_writable_journal_entry_request = null, string $contentType = self::contentTypes['extrasJournalEntriesPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\JournalEntry';
        $request = $this->extrasJournalEntriesPartialUpdateRequest($id, $patched_writable_journal_entry_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasJournalEntriesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  \OpenAPI\Client\Model\PatchedWritableJournalEntryRequest $patched_writable_journal_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasJournalEntriesPartialUpdateRequest($id, $patched_writable_journal_entry_request = null, string $contentType = self::contentTypes['extrasJournalEntriesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasJournalEntriesPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/journal-entries/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_writable_journal_entry_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_writable_journal_entry_request));
            } else {
                $httpBody = $patched_writable_journal_entry_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasJournalEntriesRetrieve
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\JournalEntry
     */
    public function extrasJournalEntriesRetrieve($id, string $contentType = self::contentTypes['extrasJournalEntriesRetrieve'][0])
    {
        list($response) = $this->extrasJournalEntriesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasJournalEntriesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\JournalEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasJournalEntriesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasJournalEntriesRetrieve'][0])
    {
        $request = $this->extrasJournalEntriesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\JournalEntry' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\JournalEntry' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\JournalEntry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\JournalEntry';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\JournalEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasJournalEntriesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesRetrieveAsync($id, string $contentType = self::contentTypes['extrasJournalEntriesRetrieve'][0])
    {
        return $this->extrasJournalEntriesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasJournalEntriesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasJournalEntriesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\JournalEntry';
        $request = $this->extrasJournalEntriesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasJournalEntriesRetrieve'
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasJournalEntriesRetrieveRequest($id, string $contentType = self::contentTypes['extrasJournalEntriesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasJournalEntriesRetrieve'
            );
        }


        $resourcePath = '/api/extras/journal-entries/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasJournalEntriesUpdate
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  \OpenAPI\Client\Model\WritableJournalEntryRequest $writable_journal_entry_request writable_journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\JournalEntry
     */
    public function extrasJournalEntriesUpdate($id, $writable_journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesUpdate'][0])
    {
        list($response) = $this->extrasJournalEntriesUpdateWithHttpInfo($id, $writable_journal_entry_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasJournalEntriesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  \OpenAPI\Client\Model\WritableJournalEntryRequest $writable_journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\JournalEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasJournalEntriesUpdateWithHttpInfo($id, $writable_journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesUpdate'][0])
    {
        $request = $this->extrasJournalEntriesUpdateRequest($id, $writable_journal_entry_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\JournalEntry' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\JournalEntry' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\JournalEntry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\JournalEntry';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\JournalEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasJournalEntriesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  \OpenAPI\Client\Model\WritableJournalEntryRequest $writable_journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesUpdateAsync($id, $writable_journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesUpdate'][0])
    {
        return $this->extrasJournalEntriesUpdateAsyncWithHttpInfo($id, $writable_journal_entry_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasJournalEntriesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  \OpenAPI\Client\Model\WritableJournalEntryRequest $writable_journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasJournalEntriesUpdateAsyncWithHttpInfo($id, $writable_journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\JournalEntry';
        $request = $this->extrasJournalEntriesUpdateRequest($id, $writable_journal_entry_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasJournalEntriesUpdate'
     *
     * @param  int $id A unique integer value identifying this journal entry. (required)
     * @param  \OpenAPI\Client\Model\WritableJournalEntryRequest $writable_journal_entry_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasJournalEntriesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasJournalEntriesUpdateRequest($id, $writable_journal_entry_request, string $contentType = self::contentTypes['extrasJournalEntriesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasJournalEntriesUpdate'
            );
        }

        // verify the required parameter 'writable_journal_entry_request' is set
        if ($writable_journal_entry_request === null || (is_array($writable_journal_entry_request) && count($writable_journal_entry_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $writable_journal_entry_request when calling extrasJournalEntriesUpdate'
            );
        }


        $resourcePath = '/api/extras/journal-entries/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($writable_journal_entry_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($writable_journal_entry_request));
            } else {
                $httpBody = $writable_journal_entry_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasObjectChangesList
     *
     * @param  string $action * &#x60;create&#x60; - Created * &#x60;update&#x60; - Updated * &#x60;delete&#x60; - Deleted (optional)
     * @param  string $action__n * &#x60;create&#x60; - Created * &#x60;update&#x60; - Updated * &#x60;delete&#x60; - Deleted (optional)
     * @param  int[] $changed_object_id changed_object_id (optional)
     * @param  bool $changed_object_id__empty changed_object_id__empty (optional)
     * @param  int[] $changed_object_id__gt changed_object_id__gt (optional)
     * @param  int[] $changed_object_id__gte changed_object_id__gte (optional)
     * @param  int[] $changed_object_id__lt changed_object_id__lt (optional)
     * @param  int[] $changed_object_id__lte changed_object_id__lte (optional)
     * @param  int[] $changed_object_id__n changed_object_id__n (optional)
     * @param  string $changed_object_type changed_object_type (optional)
     * @param  string $changed_object_type__n changed_object_type__n (optional)
     * @param  int[] $changed_object_type_id changed_object_type_id (optional)
     * @param  int[] $changed_object_type_id__n changed_object_type_id__n (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $object_repr object_repr (optional)
     * @param  bool $object_repr__empty object_repr__empty (optional)
     * @param  string[] $object_repr__ic object_repr__ic (optional)
     * @param  string[] $object_repr__ie object_repr__ie (optional)
     * @param  string[] $object_repr__iew object_repr__iew (optional)
     * @param  string[] $object_repr__isw object_repr__isw (optional)
     * @param  string[] $object_repr__n object_repr__n (optional)
     * @param  string[] $object_repr__nic object_repr__nic (optional)
     * @param  string[] $object_repr__nie object_repr__nie (optional)
     * @param  string[] $object_repr__niew object_repr__niew (optional)
     * @param  string[] $object_repr__nisw object_repr__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $related_object_id related_object_id (optional)
     * @param  bool $related_object_id__empty related_object_id__empty (optional)
     * @param  int[] $related_object_id__gt related_object_id__gt (optional)
     * @param  int[] $related_object_id__gte related_object_id__gte (optional)
     * @param  int[] $related_object_id__lt related_object_id__lt (optional)
     * @param  int[] $related_object_id__lte related_object_id__lte (optional)
     * @param  int[] $related_object_id__n related_object_id__n (optional)
     * @param  int $related_object_type related_object_type (optional)
     * @param  int $related_object_type__n related_object_type__n (optional)
     * @param  string $request_id request_id (optional)
     * @param  \DateTime $time_after time_after (optional)
     * @param  \DateTime $time_before time_before (optional)
     * @param  string[] $user User name (optional)
     * @param  string[] $user__n User name (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string[] $user_name user_name (optional)
     * @param  bool $user_name__empty user_name__empty (optional)
     * @param  string[] $user_name__ic user_name__ic (optional)
     * @param  string[] $user_name__ie user_name__ie (optional)
     * @param  string[] $user_name__iew user_name__iew (optional)
     * @param  string[] $user_name__isw user_name__isw (optional)
     * @param  string[] $user_name__n user_name__n (optional)
     * @param  string[] $user_name__nic user_name__nic (optional)
     * @param  string[] $user_name__nie user_name__nie (optional)
     * @param  string[] $user_name__niew user_name__niew (optional)
     * @param  string[] $user_name__nisw user_name__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectChangesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedObjectChangeList
     */
    public function extrasObjectChangesList($action = null, $action__n = null, $changed_object_id = null, $changed_object_id__empty = null, $changed_object_id__gt = null, $changed_object_id__gte = null, $changed_object_id__lt = null, $changed_object_id__lte = null, $changed_object_id__n = null, $changed_object_type = null, $changed_object_type__n = null, $changed_object_type_id = null, $changed_object_type_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $object_repr = null, $object_repr__empty = null, $object_repr__ic = null, $object_repr__ie = null, $object_repr__iew = null, $object_repr__isw = null, $object_repr__n = null, $object_repr__nic = null, $object_repr__nie = null, $object_repr__niew = null, $object_repr__nisw = null, $offset = null, $ordering = null, $q = null, $related_object_id = null, $related_object_id__empty = null, $related_object_id__gt = null, $related_object_id__gte = null, $related_object_id__lt = null, $related_object_id__lte = null, $related_object_id__n = null, $related_object_type = null, $related_object_type__n = null, $request_id = null, $time_after = null, $time_before = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $user_name = null, $user_name__empty = null, $user_name__ic = null, $user_name__ie = null, $user_name__iew = null, $user_name__isw = null, $user_name__n = null, $user_name__nic = null, $user_name__nie = null, $user_name__niew = null, $user_name__nisw = null, string $contentType = self::contentTypes['extrasObjectChangesList'][0])
    {
        list($response) = $this->extrasObjectChangesListWithHttpInfo($action, $action__n, $changed_object_id, $changed_object_id__empty, $changed_object_id__gt, $changed_object_id__gte, $changed_object_id__lt, $changed_object_id__lte, $changed_object_id__n, $changed_object_type, $changed_object_type__n, $changed_object_type_id, $changed_object_type_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $object_repr, $object_repr__empty, $object_repr__ic, $object_repr__ie, $object_repr__iew, $object_repr__isw, $object_repr__n, $object_repr__nic, $object_repr__nie, $object_repr__niew, $object_repr__nisw, $offset, $ordering, $q, $related_object_id, $related_object_id__empty, $related_object_id__gt, $related_object_id__gte, $related_object_id__lt, $related_object_id__lte, $related_object_id__n, $related_object_type, $related_object_type__n, $request_id, $time_after, $time_before, $user, $user__n, $user_id, $user_id__n, $user_name, $user_name__empty, $user_name__ic, $user_name__ie, $user_name__iew, $user_name__isw, $user_name__n, $user_name__nic, $user_name__nie, $user_name__niew, $user_name__nisw, $contentType);
        return $response;
    }

    /**
     * Operation extrasObjectChangesListWithHttpInfo
     *
     * @param  string $action * &#x60;create&#x60; - Created * &#x60;update&#x60; - Updated * &#x60;delete&#x60; - Deleted (optional)
     * @param  string $action__n * &#x60;create&#x60; - Created * &#x60;update&#x60; - Updated * &#x60;delete&#x60; - Deleted (optional)
     * @param  int[] $changed_object_id (optional)
     * @param  bool $changed_object_id__empty (optional)
     * @param  int[] $changed_object_id__gt (optional)
     * @param  int[] $changed_object_id__gte (optional)
     * @param  int[] $changed_object_id__lt (optional)
     * @param  int[] $changed_object_id__lte (optional)
     * @param  int[] $changed_object_id__n (optional)
     * @param  string $changed_object_type (optional)
     * @param  string $changed_object_type__n (optional)
     * @param  int[] $changed_object_type_id (optional)
     * @param  int[] $changed_object_type_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $object_repr (optional)
     * @param  bool $object_repr__empty (optional)
     * @param  string[] $object_repr__ic (optional)
     * @param  string[] $object_repr__ie (optional)
     * @param  string[] $object_repr__iew (optional)
     * @param  string[] $object_repr__isw (optional)
     * @param  string[] $object_repr__n (optional)
     * @param  string[] $object_repr__nic (optional)
     * @param  string[] $object_repr__nie (optional)
     * @param  string[] $object_repr__niew (optional)
     * @param  string[] $object_repr__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $related_object_id (optional)
     * @param  bool $related_object_id__empty (optional)
     * @param  int[] $related_object_id__gt (optional)
     * @param  int[] $related_object_id__gte (optional)
     * @param  int[] $related_object_id__lt (optional)
     * @param  int[] $related_object_id__lte (optional)
     * @param  int[] $related_object_id__n (optional)
     * @param  int $related_object_type (optional)
     * @param  int $related_object_type__n (optional)
     * @param  string $request_id (optional)
     * @param  \DateTime $time_after (optional)
     * @param  \DateTime $time_before (optional)
     * @param  string[] $user User name (optional)
     * @param  string[] $user__n User name (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string[] $user_name (optional)
     * @param  bool $user_name__empty (optional)
     * @param  string[] $user_name__ic (optional)
     * @param  string[] $user_name__ie (optional)
     * @param  string[] $user_name__iew (optional)
     * @param  string[] $user_name__isw (optional)
     * @param  string[] $user_name__n (optional)
     * @param  string[] $user_name__nic (optional)
     * @param  string[] $user_name__nie (optional)
     * @param  string[] $user_name__niew (optional)
     * @param  string[] $user_name__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectChangesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedObjectChangeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasObjectChangesListWithHttpInfo($action = null, $action__n = null, $changed_object_id = null, $changed_object_id__empty = null, $changed_object_id__gt = null, $changed_object_id__gte = null, $changed_object_id__lt = null, $changed_object_id__lte = null, $changed_object_id__n = null, $changed_object_type = null, $changed_object_type__n = null, $changed_object_type_id = null, $changed_object_type_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $object_repr = null, $object_repr__empty = null, $object_repr__ic = null, $object_repr__ie = null, $object_repr__iew = null, $object_repr__isw = null, $object_repr__n = null, $object_repr__nic = null, $object_repr__nie = null, $object_repr__niew = null, $object_repr__nisw = null, $offset = null, $ordering = null, $q = null, $related_object_id = null, $related_object_id__empty = null, $related_object_id__gt = null, $related_object_id__gte = null, $related_object_id__lt = null, $related_object_id__lte = null, $related_object_id__n = null, $related_object_type = null, $related_object_type__n = null, $request_id = null, $time_after = null, $time_before = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $user_name = null, $user_name__empty = null, $user_name__ic = null, $user_name__ie = null, $user_name__iew = null, $user_name__isw = null, $user_name__n = null, $user_name__nic = null, $user_name__nie = null, $user_name__niew = null, $user_name__nisw = null, string $contentType = self::contentTypes['extrasObjectChangesList'][0])
    {
        $request = $this->extrasObjectChangesListRequest($action, $action__n, $changed_object_id, $changed_object_id__empty, $changed_object_id__gt, $changed_object_id__gte, $changed_object_id__lt, $changed_object_id__lte, $changed_object_id__n, $changed_object_type, $changed_object_type__n, $changed_object_type_id, $changed_object_type_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $object_repr, $object_repr__empty, $object_repr__ic, $object_repr__ie, $object_repr__iew, $object_repr__isw, $object_repr__n, $object_repr__nic, $object_repr__nie, $object_repr__niew, $object_repr__nisw, $offset, $ordering, $q, $related_object_id, $related_object_id__empty, $related_object_id__gt, $related_object_id__gte, $related_object_id__lt, $related_object_id__lte, $related_object_id__n, $related_object_type, $related_object_type__n, $request_id, $time_after, $time_before, $user, $user__n, $user_id, $user_id__n, $user_name, $user_name__empty, $user_name__ic, $user_name__ie, $user_name__iew, $user_name__isw, $user_name__n, $user_name__nic, $user_name__nie, $user_name__niew, $user_name__nisw, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedObjectChangeList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedObjectChangeList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedObjectChangeList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedObjectChangeList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedObjectChangeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasObjectChangesListAsync
     *
     * @param  string $action * &#x60;create&#x60; - Created * &#x60;update&#x60; - Updated * &#x60;delete&#x60; - Deleted (optional)
     * @param  string $action__n * &#x60;create&#x60; - Created * &#x60;update&#x60; - Updated * &#x60;delete&#x60; - Deleted (optional)
     * @param  int[] $changed_object_id (optional)
     * @param  bool $changed_object_id__empty (optional)
     * @param  int[] $changed_object_id__gt (optional)
     * @param  int[] $changed_object_id__gte (optional)
     * @param  int[] $changed_object_id__lt (optional)
     * @param  int[] $changed_object_id__lte (optional)
     * @param  int[] $changed_object_id__n (optional)
     * @param  string $changed_object_type (optional)
     * @param  string $changed_object_type__n (optional)
     * @param  int[] $changed_object_type_id (optional)
     * @param  int[] $changed_object_type_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $object_repr (optional)
     * @param  bool $object_repr__empty (optional)
     * @param  string[] $object_repr__ic (optional)
     * @param  string[] $object_repr__ie (optional)
     * @param  string[] $object_repr__iew (optional)
     * @param  string[] $object_repr__isw (optional)
     * @param  string[] $object_repr__n (optional)
     * @param  string[] $object_repr__nic (optional)
     * @param  string[] $object_repr__nie (optional)
     * @param  string[] $object_repr__niew (optional)
     * @param  string[] $object_repr__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $related_object_id (optional)
     * @param  bool $related_object_id__empty (optional)
     * @param  int[] $related_object_id__gt (optional)
     * @param  int[] $related_object_id__gte (optional)
     * @param  int[] $related_object_id__lt (optional)
     * @param  int[] $related_object_id__lte (optional)
     * @param  int[] $related_object_id__n (optional)
     * @param  int $related_object_type (optional)
     * @param  int $related_object_type__n (optional)
     * @param  string $request_id (optional)
     * @param  \DateTime $time_after (optional)
     * @param  \DateTime $time_before (optional)
     * @param  string[] $user User name (optional)
     * @param  string[] $user__n User name (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string[] $user_name (optional)
     * @param  bool $user_name__empty (optional)
     * @param  string[] $user_name__ic (optional)
     * @param  string[] $user_name__ie (optional)
     * @param  string[] $user_name__iew (optional)
     * @param  string[] $user_name__isw (optional)
     * @param  string[] $user_name__n (optional)
     * @param  string[] $user_name__nic (optional)
     * @param  string[] $user_name__nie (optional)
     * @param  string[] $user_name__niew (optional)
     * @param  string[] $user_name__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectChangesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasObjectChangesListAsync($action = null, $action__n = null, $changed_object_id = null, $changed_object_id__empty = null, $changed_object_id__gt = null, $changed_object_id__gte = null, $changed_object_id__lt = null, $changed_object_id__lte = null, $changed_object_id__n = null, $changed_object_type = null, $changed_object_type__n = null, $changed_object_type_id = null, $changed_object_type_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $object_repr = null, $object_repr__empty = null, $object_repr__ic = null, $object_repr__ie = null, $object_repr__iew = null, $object_repr__isw = null, $object_repr__n = null, $object_repr__nic = null, $object_repr__nie = null, $object_repr__niew = null, $object_repr__nisw = null, $offset = null, $ordering = null, $q = null, $related_object_id = null, $related_object_id__empty = null, $related_object_id__gt = null, $related_object_id__gte = null, $related_object_id__lt = null, $related_object_id__lte = null, $related_object_id__n = null, $related_object_type = null, $related_object_type__n = null, $request_id = null, $time_after = null, $time_before = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $user_name = null, $user_name__empty = null, $user_name__ic = null, $user_name__ie = null, $user_name__iew = null, $user_name__isw = null, $user_name__n = null, $user_name__nic = null, $user_name__nie = null, $user_name__niew = null, $user_name__nisw = null, string $contentType = self::contentTypes['extrasObjectChangesList'][0])
    {
        return $this->extrasObjectChangesListAsyncWithHttpInfo($action, $action__n, $changed_object_id, $changed_object_id__empty, $changed_object_id__gt, $changed_object_id__gte, $changed_object_id__lt, $changed_object_id__lte, $changed_object_id__n, $changed_object_type, $changed_object_type__n, $changed_object_type_id, $changed_object_type_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $object_repr, $object_repr__empty, $object_repr__ic, $object_repr__ie, $object_repr__iew, $object_repr__isw, $object_repr__n, $object_repr__nic, $object_repr__nie, $object_repr__niew, $object_repr__nisw, $offset, $ordering, $q, $related_object_id, $related_object_id__empty, $related_object_id__gt, $related_object_id__gte, $related_object_id__lt, $related_object_id__lte, $related_object_id__n, $related_object_type, $related_object_type__n, $request_id, $time_after, $time_before, $user, $user__n, $user_id, $user_id__n, $user_name, $user_name__empty, $user_name__ic, $user_name__ie, $user_name__iew, $user_name__isw, $user_name__n, $user_name__nic, $user_name__nie, $user_name__niew, $user_name__nisw, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasObjectChangesListAsyncWithHttpInfo
     *
     * @param  string $action * &#x60;create&#x60; - Created * &#x60;update&#x60; - Updated * &#x60;delete&#x60; - Deleted (optional)
     * @param  string $action__n * &#x60;create&#x60; - Created * &#x60;update&#x60; - Updated * &#x60;delete&#x60; - Deleted (optional)
     * @param  int[] $changed_object_id (optional)
     * @param  bool $changed_object_id__empty (optional)
     * @param  int[] $changed_object_id__gt (optional)
     * @param  int[] $changed_object_id__gte (optional)
     * @param  int[] $changed_object_id__lt (optional)
     * @param  int[] $changed_object_id__lte (optional)
     * @param  int[] $changed_object_id__n (optional)
     * @param  string $changed_object_type (optional)
     * @param  string $changed_object_type__n (optional)
     * @param  int[] $changed_object_type_id (optional)
     * @param  int[] $changed_object_type_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $object_repr (optional)
     * @param  bool $object_repr__empty (optional)
     * @param  string[] $object_repr__ic (optional)
     * @param  string[] $object_repr__ie (optional)
     * @param  string[] $object_repr__iew (optional)
     * @param  string[] $object_repr__isw (optional)
     * @param  string[] $object_repr__n (optional)
     * @param  string[] $object_repr__nic (optional)
     * @param  string[] $object_repr__nie (optional)
     * @param  string[] $object_repr__niew (optional)
     * @param  string[] $object_repr__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $related_object_id (optional)
     * @param  bool $related_object_id__empty (optional)
     * @param  int[] $related_object_id__gt (optional)
     * @param  int[] $related_object_id__gte (optional)
     * @param  int[] $related_object_id__lt (optional)
     * @param  int[] $related_object_id__lte (optional)
     * @param  int[] $related_object_id__n (optional)
     * @param  int $related_object_type (optional)
     * @param  int $related_object_type__n (optional)
     * @param  string $request_id (optional)
     * @param  \DateTime $time_after (optional)
     * @param  \DateTime $time_before (optional)
     * @param  string[] $user User name (optional)
     * @param  string[] $user__n User name (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string[] $user_name (optional)
     * @param  bool $user_name__empty (optional)
     * @param  string[] $user_name__ic (optional)
     * @param  string[] $user_name__ie (optional)
     * @param  string[] $user_name__iew (optional)
     * @param  string[] $user_name__isw (optional)
     * @param  string[] $user_name__n (optional)
     * @param  string[] $user_name__nic (optional)
     * @param  string[] $user_name__nie (optional)
     * @param  string[] $user_name__niew (optional)
     * @param  string[] $user_name__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectChangesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasObjectChangesListAsyncWithHttpInfo($action = null, $action__n = null, $changed_object_id = null, $changed_object_id__empty = null, $changed_object_id__gt = null, $changed_object_id__gte = null, $changed_object_id__lt = null, $changed_object_id__lte = null, $changed_object_id__n = null, $changed_object_type = null, $changed_object_type__n = null, $changed_object_type_id = null, $changed_object_type_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $object_repr = null, $object_repr__empty = null, $object_repr__ic = null, $object_repr__ie = null, $object_repr__iew = null, $object_repr__isw = null, $object_repr__n = null, $object_repr__nic = null, $object_repr__nie = null, $object_repr__niew = null, $object_repr__nisw = null, $offset = null, $ordering = null, $q = null, $related_object_id = null, $related_object_id__empty = null, $related_object_id__gt = null, $related_object_id__gte = null, $related_object_id__lt = null, $related_object_id__lte = null, $related_object_id__n = null, $related_object_type = null, $related_object_type__n = null, $request_id = null, $time_after = null, $time_before = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $user_name = null, $user_name__empty = null, $user_name__ic = null, $user_name__ie = null, $user_name__iew = null, $user_name__isw = null, $user_name__n = null, $user_name__nic = null, $user_name__nie = null, $user_name__niew = null, $user_name__nisw = null, string $contentType = self::contentTypes['extrasObjectChangesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedObjectChangeList';
        $request = $this->extrasObjectChangesListRequest($action, $action__n, $changed_object_id, $changed_object_id__empty, $changed_object_id__gt, $changed_object_id__gte, $changed_object_id__lt, $changed_object_id__lte, $changed_object_id__n, $changed_object_type, $changed_object_type__n, $changed_object_type_id, $changed_object_type_id__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $limit, $object_repr, $object_repr__empty, $object_repr__ic, $object_repr__ie, $object_repr__iew, $object_repr__isw, $object_repr__n, $object_repr__nic, $object_repr__nie, $object_repr__niew, $object_repr__nisw, $offset, $ordering, $q, $related_object_id, $related_object_id__empty, $related_object_id__gt, $related_object_id__gte, $related_object_id__lt, $related_object_id__lte, $related_object_id__n, $related_object_type, $related_object_type__n, $request_id, $time_after, $time_before, $user, $user__n, $user_id, $user_id__n, $user_name, $user_name__empty, $user_name__ic, $user_name__ie, $user_name__iew, $user_name__isw, $user_name__n, $user_name__nic, $user_name__nie, $user_name__niew, $user_name__nisw, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasObjectChangesList'
     *
     * @param  string $action * &#x60;create&#x60; - Created * &#x60;update&#x60; - Updated * &#x60;delete&#x60; - Deleted (optional)
     * @param  string $action__n * &#x60;create&#x60; - Created * &#x60;update&#x60; - Updated * &#x60;delete&#x60; - Deleted (optional)
     * @param  int[] $changed_object_id (optional)
     * @param  bool $changed_object_id__empty (optional)
     * @param  int[] $changed_object_id__gt (optional)
     * @param  int[] $changed_object_id__gte (optional)
     * @param  int[] $changed_object_id__lt (optional)
     * @param  int[] $changed_object_id__lte (optional)
     * @param  int[] $changed_object_id__n (optional)
     * @param  string $changed_object_type (optional)
     * @param  string $changed_object_type__n (optional)
     * @param  int[] $changed_object_type_id (optional)
     * @param  int[] $changed_object_type_id__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string[] $object_repr (optional)
     * @param  bool $object_repr__empty (optional)
     * @param  string[] $object_repr__ic (optional)
     * @param  string[] $object_repr__ie (optional)
     * @param  string[] $object_repr__iew (optional)
     * @param  string[] $object_repr__isw (optional)
     * @param  string[] $object_repr__n (optional)
     * @param  string[] $object_repr__nic (optional)
     * @param  string[] $object_repr__nie (optional)
     * @param  string[] $object_repr__niew (optional)
     * @param  string[] $object_repr__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  int[] $related_object_id (optional)
     * @param  bool $related_object_id__empty (optional)
     * @param  int[] $related_object_id__gt (optional)
     * @param  int[] $related_object_id__gte (optional)
     * @param  int[] $related_object_id__lt (optional)
     * @param  int[] $related_object_id__lte (optional)
     * @param  int[] $related_object_id__n (optional)
     * @param  int $related_object_type (optional)
     * @param  int $related_object_type__n (optional)
     * @param  string $request_id (optional)
     * @param  \DateTime $time_after (optional)
     * @param  \DateTime $time_before (optional)
     * @param  string[] $user User name (optional)
     * @param  string[] $user__n User name (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  string[] $user_name (optional)
     * @param  bool $user_name__empty (optional)
     * @param  string[] $user_name__ic (optional)
     * @param  string[] $user_name__ie (optional)
     * @param  string[] $user_name__iew (optional)
     * @param  string[] $user_name__isw (optional)
     * @param  string[] $user_name__n (optional)
     * @param  string[] $user_name__nic (optional)
     * @param  string[] $user_name__nie (optional)
     * @param  string[] $user_name__niew (optional)
     * @param  string[] $user_name__nisw (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectChangesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasObjectChangesListRequest($action = null, $action__n = null, $changed_object_id = null, $changed_object_id__empty = null, $changed_object_id__gt = null, $changed_object_id__gte = null, $changed_object_id__lt = null, $changed_object_id__lte = null, $changed_object_id__n = null, $changed_object_type = null, $changed_object_type__n = null, $changed_object_type_id = null, $changed_object_type_id__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $limit = null, $object_repr = null, $object_repr__empty = null, $object_repr__ic = null, $object_repr__ie = null, $object_repr__iew = null, $object_repr__isw = null, $object_repr__n = null, $object_repr__nic = null, $object_repr__nie = null, $object_repr__niew = null, $object_repr__nisw = null, $offset = null, $ordering = null, $q = null, $related_object_id = null, $related_object_id__empty = null, $related_object_id__gt = null, $related_object_id__gte = null, $related_object_id__lt = null, $related_object_id__lte = null, $related_object_id__n = null, $related_object_type = null, $related_object_type__n = null, $request_id = null, $time_after = null, $time_before = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $user_name = null, $user_name__empty = null, $user_name__ic = null, $user_name__ie = null, $user_name__iew = null, $user_name__isw = null, $user_name__n = null, $user_name__nic = null, $user_name__nie = null, $user_name__niew = null, $user_name__nisw = null, string $contentType = self::contentTypes['extrasObjectChangesList'][0])
    {
































































        $resourcePath = '/api/extras/object-changes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action,
            'action', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action__n,
            'action__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $changed_object_id,
            'changed_object_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $changed_object_id__empty,
            'changed_object_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $changed_object_id__gt,
            'changed_object_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $changed_object_id__gte,
            'changed_object_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $changed_object_id__lt,
            'changed_object_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $changed_object_id__lte,
            'changed_object_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $changed_object_id__n,
            'changed_object_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $changed_object_type,
            'changed_object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $changed_object_type__n,
            'changed_object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $changed_object_type_id,
            'changed_object_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $changed_object_type_id__n,
            'changed_object_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_repr,
            'object_repr', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_repr__empty,
            'object_repr__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_repr__ic,
            'object_repr__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_repr__ie,
            'object_repr__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_repr__iew,
            'object_repr__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_repr__isw,
            'object_repr__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_repr__n,
            'object_repr__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_repr__nic,
            'object_repr__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_repr__nie,
            'object_repr__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_repr__niew,
            'object_repr__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_repr__nisw,
            'object_repr__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_id,
            'related_object_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_id__empty,
            'related_object_id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_id__gt,
            'related_object_id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_id__gte,
            'related_object_id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_id__lt,
            'related_object_id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_id__lte,
            'related_object_id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_id__n,
            'related_object_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_type,
            'related_object_type', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_object_type__n,
            'related_object_type__n', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $request_id,
            'request_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_after,
            'time_after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_before,
            'time_before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user,
            'user', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user__n,
            'user__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'user_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id__n,
            'user_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name,
            'user_name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name__empty,
            'user_name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name__ic,
            'user_name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name__ie,
            'user_name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name__iew,
            'user_name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name__isw,
            'user_name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name__n,
            'user_name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name__nic,
            'user_name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name__nie,
            'user_name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name__niew,
            'user_name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name__nisw,
            'user_name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasObjectChangesRetrieve
     *
     * @param  int $id A unique integer value identifying this object change. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectChangesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectChange
     */
    public function extrasObjectChangesRetrieve($id, string $contentType = self::contentTypes['extrasObjectChangesRetrieve'][0])
    {
        list($response) = $this->extrasObjectChangesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasObjectChangesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this object change. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectChangesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectChange, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasObjectChangesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasObjectChangesRetrieve'][0])
    {
        $request = $this->extrasObjectChangesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ObjectChange' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ObjectChange' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ObjectChange', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ObjectChange';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectChange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasObjectChangesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this object change. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectChangesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasObjectChangesRetrieveAsync($id, string $contentType = self::contentTypes['extrasObjectChangesRetrieve'][0])
    {
        return $this->extrasObjectChangesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasObjectChangesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this object change. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectChangesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasObjectChangesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasObjectChangesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectChange';
        $request = $this->extrasObjectChangesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasObjectChangesRetrieve'
     *
     * @param  int $id A unique integer value identifying this object change. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectChangesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasObjectChangesRetrieveRequest($id, string $contentType = self::contentTypes['extrasObjectChangesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasObjectChangesRetrieve'
            );
        }


        $resourcePath = '/api/extras/object-changes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasObjectTypesList
     *
     * @param  string $app_label app_label (optional)
     * @param  int $id id (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $model model (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectTypesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedObjectTypeList
     */
    public function extrasObjectTypesList($app_label = null, $id = null, $limit = null, $model = null, $offset = null, $ordering = null, $q = null, string $contentType = self::contentTypes['extrasObjectTypesList'][0])
    {
        list($response) = $this->extrasObjectTypesListWithHttpInfo($app_label, $id, $limit, $model, $offset, $ordering, $q, $contentType);
        return $response;
    }

    /**
     * Operation extrasObjectTypesListWithHttpInfo
     *
     * @param  string $app_label (optional)
     * @param  int $id (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $model (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectTypesList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedObjectTypeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasObjectTypesListWithHttpInfo($app_label = null, $id = null, $limit = null, $model = null, $offset = null, $ordering = null, $q = null, string $contentType = self::contentTypes['extrasObjectTypesList'][0])
    {
        $request = $this->extrasObjectTypesListRequest($app_label, $id, $limit, $model, $offset, $ordering, $q, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedObjectTypeList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedObjectTypeList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedObjectTypeList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedObjectTypeList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedObjectTypeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasObjectTypesListAsync
     *
     * @param  string $app_label (optional)
     * @param  int $id (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $model (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectTypesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasObjectTypesListAsync($app_label = null, $id = null, $limit = null, $model = null, $offset = null, $ordering = null, $q = null, string $contentType = self::contentTypes['extrasObjectTypesList'][0])
    {
        return $this->extrasObjectTypesListAsyncWithHttpInfo($app_label, $id, $limit, $model, $offset, $ordering, $q, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasObjectTypesListAsyncWithHttpInfo
     *
     * @param  string $app_label (optional)
     * @param  int $id (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $model (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectTypesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasObjectTypesListAsyncWithHttpInfo($app_label = null, $id = null, $limit = null, $model = null, $offset = null, $ordering = null, $q = null, string $contentType = self::contentTypes['extrasObjectTypesList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedObjectTypeList';
        $request = $this->extrasObjectTypesListRequest($app_label, $id, $limit, $model, $offset, $ordering, $q, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasObjectTypesList'
     *
     * @param  string $app_label (optional)
     * @param  int $id (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $model (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectTypesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasObjectTypesListRequest($app_label = null, $id = null, $limit = null, $model = null, $offset = null, $ordering = null, $q = null, string $contentType = self::contentTypes['extrasObjectTypesList'][0])
    {









        $resourcePath = '/api/extras/object-types/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_label,
            'app_label', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $model,
            'model', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasObjectTypesRetrieve
     *
     * @param  int $id A unique integer value identifying this object type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectTypesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectType
     */
    public function extrasObjectTypesRetrieve($id, string $contentType = self::contentTypes['extrasObjectTypesRetrieve'][0])
    {
        list($response) = $this->extrasObjectTypesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasObjectTypesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this object type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectTypesRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectType, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasObjectTypesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasObjectTypesRetrieve'][0])
    {
        $request = $this->extrasObjectTypesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ObjectType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ObjectType' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ObjectType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ObjectType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasObjectTypesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this object type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectTypesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasObjectTypesRetrieveAsync($id, string $contentType = self::contentTypes['extrasObjectTypesRetrieve'][0])
    {
        return $this->extrasObjectTypesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasObjectTypesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this object type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectTypesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasObjectTypesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasObjectTypesRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectType';
        $request = $this->extrasObjectTypesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasObjectTypesRetrieve'
     *
     * @param  int $id A unique integer value identifying this object type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasObjectTypesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasObjectTypesRetrieveRequest($id, string $contentType = self::contentTypes['extrasObjectTypesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasObjectTypesRetrieve'
            );
        }


        $resourcePath = '/api/extras/object-types/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasSavedFiltersBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasSavedFiltersBulkDestroy($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkDestroy'][0])
    {
        $this->extrasSavedFiltersBulkDestroyWithHttpInfo($saved_filter_request, $contentType);
    }

    /**
     * Operation extrasSavedFiltersBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasSavedFiltersBulkDestroyWithHttpInfo($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkDestroy'][0])
    {
        $request = $this->extrasSavedFiltersBulkDestroyRequest($saved_filter_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasSavedFiltersBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersBulkDestroyAsync($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkDestroy'][0])
    {
        return $this->extrasSavedFiltersBulkDestroyAsyncWithHttpInfo($saved_filter_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasSavedFiltersBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersBulkDestroyAsyncWithHttpInfo($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasSavedFiltersBulkDestroyRequest($saved_filter_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasSavedFiltersBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasSavedFiltersBulkDestroyRequest($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkDestroy'][0])
    {

        // verify the required parameter 'saved_filter_request' is set
        if ($saved_filter_request === null || (is_array($saved_filter_request) && count($saved_filter_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $saved_filter_request when calling extrasSavedFiltersBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/saved-filters/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($saved_filter_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($saved_filter_request));
            } else {
                $httpBody = $saved_filter_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasSavedFiltersBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SavedFilter[]
     */
    public function extrasSavedFiltersBulkPartialUpdate($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasSavedFiltersBulkPartialUpdateWithHttpInfo($saved_filter_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasSavedFiltersBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SavedFilter[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasSavedFiltersBulkPartialUpdateWithHttpInfo($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkPartialUpdate'][0])
    {
        $request = $this->extrasSavedFiltersBulkPartialUpdateRequest($saved_filter_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SavedFilter[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SavedFilter[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SavedFilter[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SavedFilter[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SavedFilter[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasSavedFiltersBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersBulkPartialUpdateAsync($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkPartialUpdate'][0])
    {
        return $this->extrasSavedFiltersBulkPartialUpdateAsyncWithHttpInfo($saved_filter_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasSavedFiltersBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersBulkPartialUpdateAsyncWithHttpInfo($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SavedFilter[]';
        $request = $this->extrasSavedFiltersBulkPartialUpdateRequest($saved_filter_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasSavedFiltersBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasSavedFiltersBulkPartialUpdateRequest($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkPartialUpdate'][0])
    {

        // verify the required parameter 'saved_filter_request' is set
        if ($saved_filter_request === null || (is_array($saved_filter_request) && count($saved_filter_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $saved_filter_request when calling extrasSavedFiltersBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/saved-filters/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($saved_filter_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($saved_filter_request));
            } else {
                $httpBody = $saved_filter_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasSavedFiltersBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SavedFilter[]
     */
    public function extrasSavedFiltersBulkUpdate($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkUpdate'][0])
    {
        list($response) = $this->extrasSavedFiltersBulkUpdateWithHttpInfo($saved_filter_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasSavedFiltersBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SavedFilter[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasSavedFiltersBulkUpdateWithHttpInfo($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkUpdate'][0])
    {
        $request = $this->extrasSavedFiltersBulkUpdateRequest($saved_filter_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SavedFilter[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SavedFilter[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SavedFilter[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SavedFilter[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SavedFilter[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasSavedFiltersBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersBulkUpdateAsync($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkUpdate'][0])
    {
        return $this->extrasSavedFiltersBulkUpdateAsyncWithHttpInfo($saved_filter_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasSavedFiltersBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersBulkUpdateAsyncWithHttpInfo($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SavedFilter[]';
        $request = $this->extrasSavedFiltersBulkUpdateRequest($saved_filter_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasSavedFiltersBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest[] $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasSavedFiltersBulkUpdateRequest($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersBulkUpdate'][0])
    {

        // verify the required parameter 'saved_filter_request' is set
        if ($saved_filter_request === null || (is_array($saved_filter_request) && count($saved_filter_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $saved_filter_request when calling extrasSavedFiltersBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/saved-filters/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($saved_filter_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($saved_filter_request));
            } else {
                $httpBody = $saved_filter_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasSavedFiltersCreate
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest $saved_filter_request saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SavedFilter
     */
    public function extrasSavedFiltersCreate($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersCreate'][0])
    {
        list($response) = $this->extrasSavedFiltersCreateWithHttpInfo($saved_filter_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasSavedFiltersCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SavedFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasSavedFiltersCreateWithHttpInfo($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersCreate'][0])
    {
        $request = $this->extrasSavedFiltersCreateRequest($saved_filter_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\SavedFilter' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SavedFilter' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SavedFilter', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SavedFilter';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SavedFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasSavedFiltersCreateAsync
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersCreateAsync($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersCreate'][0])
    {
        return $this->extrasSavedFiltersCreateAsyncWithHttpInfo($saved_filter_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasSavedFiltersCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersCreateAsyncWithHttpInfo($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SavedFilter';
        $request = $this->extrasSavedFiltersCreateRequest($saved_filter_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasSavedFiltersCreate'
     *
     * @param  \OpenAPI\Client\Model\SavedFilterRequest $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasSavedFiltersCreateRequest($saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersCreate'][0])
    {

        // verify the required parameter 'saved_filter_request' is set
        if ($saved_filter_request === null || (is_array($saved_filter_request) && count($saved_filter_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $saved_filter_request when calling extrasSavedFiltersCreate'
            );
        }


        $resourcePath = '/api/extras/saved-filters/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($saved_filter_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($saved_filter_request));
            } else {
                $httpBody = $saved_filter_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasSavedFiltersDestroy
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasSavedFiltersDestroy($id, string $contentType = self::contentTypes['extrasSavedFiltersDestroy'][0])
    {
        $this->extrasSavedFiltersDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasSavedFiltersDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasSavedFiltersDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasSavedFiltersDestroy'][0])
    {
        $request = $this->extrasSavedFiltersDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasSavedFiltersDestroyAsync
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersDestroyAsync($id, string $contentType = self::contentTypes['extrasSavedFiltersDestroy'][0])
    {
        return $this->extrasSavedFiltersDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasSavedFiltersDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasSavedFiltersDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasSavedFiltersDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasSavedFiltersDestroy'
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasSavedFiltersDestroyRequest($id, string $contentType = self::contentTypes['extrasSavedFiltersDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasSavedFiltersDestroy'
            );
        }


        $resourcePath = '/api/extras/saved-filters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasSavedFiltersList
     *
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  bool $enabled enabled (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  string $object_type object_type (optional)
     * @param  string $object_type__ic object_type__ic (optional)
     * @param  string $object_type__ie object_type__ie (optional)
     * @param  string $object_type__iew object_type__iew (optional)
     * @param  string $object_type__isw object_type__isw (optional)
     * @param  string $object_type__n object_type__n (optional)
     * @param  string $object_type__nic object_type__nic (optional)
     * @param  string $object_type__nie object_type__nie (optional)
     * @param  string $object_type__niew object_type__niew (optional)
     * @param  string $object_type__nisw object_type__nisw (optional)
     * @param  int[] $object_type_id object_type_id (optional)
     * @param  int[] $object_type_id__n object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  bool $shared shared (optional)
     * @param  string[] $slug slug (optional)
     * @param  bool $slug__empty slug__empty (optional)
     * @param  string[] $slug__ic slug__ic (optional)
     * @param  string[] $slug__ie slug__ie (optional)
     * @param  string[] $slug__iew slug__iew (optional)
     * @param  string[] $slug__isw slug__isw (optional)
     * @param  string[] $slug__n slug__n (optional)
     * @param  string[] $slug__nic slug__nic (optional)
     * @param  string[] $slug__nie slug__nie (optional)
     * @param  string[] $slug__niew slug__niew (optional)
     * @param  string[] $slug__nisw slug__nisw (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  bool $usable usable (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  int[] $weight weight (optional)
     * @param  bool $weight__empty weight__empty (optional)
     * @param  int[] $weight__gt weight__gt (optional)
     * @param  int[] $weight__gte weight__gte (optional)
     * @param  int[] $weight__lt weight__lt (optional)
     * @param  int[] $weight__lte weight__lte (optional)
     * @param  int[] $weight__n weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedSavedFilterList
     */
    public function extrasSavedFiltersList($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $shared = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $updated_by_request = null, $usable = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasSavedFiltersList'][0])
    {
        list($response) = $this->extrasSavedFiltersListWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $shared, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $updated_by_request, $usable, $user, $user__n, $user_id, $user_id__n, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);
        return $response;
    }

    /**
     * Operation extrasSavedFiltersListWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  bool $shared (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string $updated_by_request (optional)
     * @param  bool $usable (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedSavedFilterList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasSavedFiltersListWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $shared = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $updated_by_request = null, $usable = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasSavedFiltersList'][0])
    {
        $request = $this->extrasSavedFiltersListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $shared, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $updated_by_request, $usable, $user, $user__n, $user_id, $user_id__n, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedSavedFilterList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedSavedFilterList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedSavedFilterList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedSavedFilterList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedSavedFilterList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasSavedFiltersListAsync
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  bool $shared (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string $updated_by_request (optional)
     * @param  bool $usable (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersListAsync($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $shared = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $updated_by_request = null, $usable = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasSavedFiltersList'][0])
    {
        return $this->extrasSavedFiltersListAsyncWithHttpInfo($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $shared, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $updated_by_request, $usable, $user, $user__n, $user_id, $user_id__n, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasSavedFiltersListAsyncWithHttpInfo
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  bool $shared (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string $updated_by_request (optional)
     * @param  bool $usable (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersListAsyncWithHttpInfo($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $shared = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $updated_by_request = null, $usable = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasSavedFiltersList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedSavedFilterList';
        $request = $this->extrasSavedFiltersListRequest($created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $enabled, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_type, $object_type__ic, $object_type__ie, $object_type__iew, $object_type__isw, $object_type__n, $object_type__nic, $object_type__nie, $object_type__niew, $object_type__nisw, $object_type_id, $object_type_id__n, $offset, $ordering, $q, $shared, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $updated_by_request, $usable, $user, $user__n, $user_id, $user_id__n, $weight, $weight__empty, $weight__gt, $weight__gte, $weight__lt, $weight__lte, $weight__n, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasSavedFiltersList'
     *
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  bool $enabled (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  string $object_type (optional)
     * @param  string $object_type__ic (optional)
     * @param  string $object_type__ie (optional)
     * @param  string $object_type__iew (optional)
     * @param  string $object_type__isw (optional)
     * @param  string $object_type__n (optional)
     * @param  string $object_type__nic (optional)
     * @param  string $object_type__nie (optional)
     * @param  string $object_type__niew (optional)
     * @param  string $object_type__nisw (optional)
     * @param  int[] $object_type_id (optional)
     * @param  int[] $object_type_id__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  bool $shared (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string $updated_by_request (optional)
     * @param  bool $usable (optional)
     * @param  string[] $user User (name) (optional)
     * @param  string[] $user__n User (name) (optional)
     * @param  int[] $user_id User (ID) (optional)
     * @param  int[] $user_id__n User (ID) (optional)
     * @param  int[] $weight (optional)
     * @param  bool $weight__empty (optional)
     * @param  int[] $weight__gt (optional)
     * @param  int[] $weight__gte (optional)
     * @param  int[] $weight__lt (optional)
     * @param  int[] $weight__lte (optional)
     * @param  int[] $weight__n (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasSavedFiltersListRequest($created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $enabled = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_type = null, $object_type__ic = null, $object_type__ie = null, $object_type__iew = null, $object_type__isw = null, $object_type__n = null, $object_type__nic = null, $object_type__nie = null, $object_type__niew = null, $object_type__nisw = null, $object_type_id = null, $object_type_id__n = null, $offset = null, $ordering = null, $q = null, $shared = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $updated_by_request = null, $usable = null, $user = null, $user__n = null, $user_id = null, $user_id__n = null, $weight = null, $weight__empty = null, $weight__gt = null, $weight__gte = null, $weight__lt = null, $weight__lte = null, $weight__n = null, string $contentType = self::contentTypes['extrasSavedFiltersList'][0])
    {

























































































        $resourcePath = '/api/extras/saved-filters/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enabled,
            'enabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type,
            'object_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ic,
            'object_type__ic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__ie,
            'object_type__ie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__iew,
            'object_type__iew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__isw,
            'object_type__isw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__n,
            'object_type__n', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nic,
            'object_type__nic', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nie,
            'object_type__nie', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__niew,
            'object_type__niew', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type__nisw,
            'object_type__nisw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id,
            'object_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_type_id__n,
            'object_type_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shared,
            'shared', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__empty,
            'slug__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ic,
            'slug__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ie,
            'slug__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__iew,
            'slug__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__isw,
            'slug__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__n,
            'slug__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nic,
            'slug__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nie,
            'slug__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__niew,
            'slug__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nisw,
            'slug__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $usable,
            'usable', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user,
            'user', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user__n,
            'user__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'user_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id__n,
            'user_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight,
            'weight', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__empty,
            'weight__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__gt,
            'weight__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__gte,
            'weight__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__lt,
            'weight__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__lte,
            'weight__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $weight__n,
            'weight__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasSavedFiltersPartialUpdate
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  \OpenAPI\Client\Model\PatchedSavedFilterRequest $patched_saved_filter_request patched_saved_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SavedFilter
     */
    public function extrasSavedFiltersPartialUpdate($id, $patched_saved_filter_request = null, string $contentType = self::contentTypes['extrasSavedFiltersPartialUpdate'][0])
    {
        list($response) = $this->extrasSavedFiltersPartialUpdateWithHttpInfo($id, $patched_saved_filter_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasSavedFiltersPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  \OpenAPI\Client\Model\PatchedSavedFilterRequest $patched_saved_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SavedFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasSavedFiltersPartialUpdateWithHttpInfo($id, $patched_saved_filter_request = null, string $contentType = self::contentTypes['extrasSavedFiltersPartialUpdate'][0])
    {
        $request = $this->extrasSavedFiltersPartialUpdateRequest($id, $patched_saved_filter_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SavedFilter' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SavedFilter' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SavedFilter', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SavedFilter';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SavedFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasSavedFiltersPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  \OpenAPI\Client\Model\PatchedSavedFilterRequest $patched_saved_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersPartialUpdateAsync($id, $patched_saved_filter_request = null, string $contentType = self::contentTypes['extrasSavedFiltersPartialUpdate'][0])
    {
        return $this->extrasSavedFiltersPartialUpdateAsyncWithHttpInfo($id, $patched_saved_filter_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasSavedFiltersPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  \OpenAPI\Client\Model\PatchedSavedFilterRequest $patched_saved_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersPartialUpdateAsyncWithHttpInfo($id, $patched_saved_filter_request = null, string $contentType = self::contentTypes['extrasSavedFiltersPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SavedFilter';
        $request = $this->extrasSavedFiltersPartialUpdateRequest($id, $patched_saved_filter_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasSavedFiltersPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  \OpenAPI\Client\Model\PatchedSavedFilterRequest $patched_saved_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasSavedFiltersPartialUpdateRequest($id, $patched_saved_filter_request = null, string $contentType = self::contentTypes['extrasSavedFiltersPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasSavedFiltersPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/saved-filters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_saved_filter_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_saved_filter_request));
            } else {
                $httpBody = $patched_saved_filter_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasSavedFiltersRetrieve
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SavedFilter
     */
    public function extrasSavedFiltersRetrieve($id, string $contentType = self::contentTypes['extrasSavedFiltersRetrieve'][0])
    {
        list($response) = $this->extrasSavedFiltersRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasSavedFiltersRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SavedFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasSavedFiltersRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasSavedFiltersRetrieve'][0])
    {
        $request = $this->extrasSavedFiltersRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SavedFilter' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SavedFilter' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SavedFilter', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SavedFilter';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SavedFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasSavedFiltersRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersRetrieveAsync($id, string $contentType = self::contentTypes['extrasSavedFiltersRetrieve'][0])
    {
        return $this->extrasSavedFiltersRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasSavedFiltersRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasSavedFiltersRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SavedFilter';
        $request = $this->extrasSavedFiltersRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasSavedFiltersRetrieve'
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasSavedFiltersRetrieveRequest($id, string $contentType = self::contentTypes['extrasSavedFiltersRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasSavedFiltersRetrieve'
            );
        }


        $resourcePath = '/api/extras/saved-filters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasSavedFiltersUpdate
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  \OpenAPI\Client\Model\SavedFilterRequest $saved_filter_request saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SavedFilter
     */
    public function extrasSavedFiltersUpdate($id, $saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersUpdate'][0])
    {
        list($response) = $this->extrasSavedFiltersUpdateWithHttpInfo($id, $saved_filter_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasSavedFiltersUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  \OpenAPI\Client\Model\SavedFilterRequest $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SavedFilter, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasSavedFiltersUpdateWithHttpInfo($id, $saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersUpdate'][0])
    {
        $request = $this->extrasSavedFiltersUpdateRequest($id, $saved_filter_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SavedFilter' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SavedFilter' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SavedFilter', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SavedFilter';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SavedFilter',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasSavedFiltersUpdateAsync
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  \OpenAPI\Client\Model\SavedFilterRequest $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersUpdateAsync($id, $saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersUpdate'][0])
    {
        return $this->extrasSavedFiltersUpdateAsyncWithHttpInfo($id, $saved_filter_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasSavedFiltersUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  \OpenAPI\Client\Model\SavedFilterRequest $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasSavedFiltersUpdateAsyncWithHttpInfo($id, $saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SavedFilter';
        $request = $this->extrasSavedFiltersUpdateRequest($id, $saved_filter_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasSavedFiltersUpdate'
     *
     * @param  int $id A unique integer value identifying this saved filter. (required)
     * @param  \OpenAPI\Client\Model\SavedFilterRequest $saved_filter_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasSavedFiltersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasSavedFiltersUpdateRequest($id, $saved_filter_request, string $contentType = self::contentTypes['extrasSavedFiltersUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasSavedFiltersUpdate'
            );
        }

        // verify the required parameter 'saved_filter_request' is set
        if ($saved_filter_request === null || (is_array($saved_filter_request) && count($saved_filter_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $saved_filter_request when calling extrasSavedFiltersUpdate'
            );
        }


        $resourcePath = '/api/extras/saved-filters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($saved_filter_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($saved_filter_request));
            } else {
                $httpBody = $saved_filter_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasScriptsCreate
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Script
     */
    public function extrasScriptsCreate(string $contentType = self::contentTypes['extrasScriptsCreate'][0])
    {
        list($response) = $this->extrasScriptsCreateWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation extrasScriptsCreateWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Script, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasScriptsCreateWithHttpInfo(string $contentType = self::contentTypes['extrasScriptsCreate'][0])
    {
        $request = $this->extrasScriptsCreateRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Script' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Script' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Script', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Script';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Script',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasScriptsCreateAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsCreateAsync(string $contentType = self::contentTypes['extrasScriptsCreate'][0])
    {
        return $this->extrasScriptsCreateAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasScriptsCreateAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsCreateAsyncWithHttpInfo(string $contentType = self::contentTypes['extrasScriptsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Script';
        $request = $this->extrasScriptsCreateRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasScriptsCreate'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasScriptsCreateRequest(string $contentType = self::contentTypes['extrasScriptsCreate'][0])
    {


        $resourcePath = '/api/extras/scripts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasScriptsDestroy
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasScriptsDestroy($id, string $contentType = self::contentTypes['extrasScriptsDestroy'][0])
    {
        $this->extrasScriptsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasScriptsDestroyWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasScriptsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasScriptsDestroy'][0])
    {
        $request = $this->extrasScriptsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasScriptsDestroyAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsDestroyAsync($id, string $contentType = self::contentTypes['extrasScriptsDestroy'][0])
    {
        return $this->extrasScriptsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasScriptsDestroyAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasScriptsDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasScriptsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasScriptsDestroy'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasScriptsDestroyRequest($id, string $contentType = self::contentTypes['extrasScriptsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasScriptsDestroy'
            );
        }
        if (!preg_match("/^[^\/]+$/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling ExtrasApi.extrasScriptsDestroy, must conform to the pattern /^[^\/]+$/.");
        }
        

        $resourcePath = '/api/extras/scripts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasScriptsList
     *
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  bool $is_executable is_executable (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $module_id Script module (ID) (optional)
     * @param  int[] $module_id__n Script module (ID) (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedScriptList
     */
    public function extrasScriptsList($id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_executable = null, $limit = null, $module_id = null, $module_id__n = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, string $contentType = self::contentTypes['extrasScriptsList'][0])
    {
        list($response) = $this->extrasScriptsListWithHttpInfo($id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_executable, $limit, $module_id, $module_id__n, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $contentType);
        return $response;
    }

    /**
     * Operation extrasScriptsListWithHttpInfo
     *
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_executable (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $module_id Script module (ID) (optional)
     * @param  int[] $module_id__n Script module (ID) (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedScriptList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasScriptsListWithHttpInfo($id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_executable = null, $limit = null, $module_id = null, $module_id__n = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, string $contentType = self::contentTypes['extrasScriptsList'][0])
    {
        $request = $this->extrasScriptsListRequest($id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_executable, $limit, $module_id, $module_id__n, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedScriptList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedScriptList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedScriptList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedScriptList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedScriptList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasScriptsListAsync
     *
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_executable (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $module_id Script module (ID) (optional)
     * @param  int[] $module_id__n Script module (ID) (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsListAsync($id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_executable = null, $limit = null, $module_id = null, $module_id__n = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, string $contentType = self::contentTypes['extrasScriptsList'][0])
    {
        return $this->extrasScriptsListAsyncWithHttpInfo($id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_executable, $limit, $module_id, $module_id__n, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasScriptsListAsyncWithHttpInfo
     *
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_executable (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $module_id Script module (ID) (optional)
     * @param  int[] $module_id__n Script module (ID) (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsListAsyncWithHttpInfo($id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_executable = null, $limit = null, $module_id = null, $module_id__n = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, string $contentType = self::contentTypes['extrasScriptsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedScriptList';
        $request = $this->extrasScriptsListRequest($id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $is_executable, $limit, $module_id, $module_id__n, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $q, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasScriptsList'
     *
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  bool $is_executable (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  int[] $module_id Script module (ID) (optional)
     * @param  int[] $module_id__n Script module (ID) (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasScriptsListRequest($id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $is_executable = null, $limit = null, $module_id = null, $module_id__n = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $q = null, string $contentType = self::contentTypes['extrasScriptsList'][0])
    {



























        $resourcePath = '/api/extras/scripts/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_executable,
            'is_executable', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $module_id,
            'module_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $module_id__n,
            'module_id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasScriptsPartialUpdate
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Script
     */
    public function extrasScriptsPartialUpdate($id, string $contentType = self::contentTypes['extrasScriptsPartialUpdate'][0])
    {
        list($response) = $this->extrasScriptsPartialUpdateWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasScriptsPartialUpdateWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Script, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasScriptsPartialUpdateWithHttpInfo($id, string $contentType = self::contentTypes['extrasScriptsPartialUpdate'][0])
    {
        $request = $this->extrasScriptsPartialUpdateRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Script' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Script' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Script', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Script';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Script',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasScriptsPartialUpdateAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsPartialUpdateAsync($id, string $contentType = self::contentTypes['extrasScriptsPartialUpdate'][0])
    {
        return $this->extrasScriptsPartialUpdateAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasScriptsPartialUpdateAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsPartialUpdateAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasScriptsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Script';
        $request = $this->extrasScriptsPartialUpdateRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasScriptsPartialUpdate'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasScriptsPartialUpdateRequest($id, string $contentType = self::contentTypes['extrasScriptsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasScriptsPartialUpdate'
            );
        }
        if (!preg_match("/^[^\/]+$/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling ExtrasApi.extrasScriptsPartialUpdate, must conform to the pattern /^[^\/]+$/.");
        }
        

        $resourcePath = '/api/extras/scripts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasScriptsRetrieve
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Script
     */
    public function extrasScriptsRetrieve($id, string $contentType = self::contentTypes['extrasScriptsRetrieve'][0])
    {
        list($response) = $this->extrasScriptsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasScriptsRetrieveWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Script, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasScriptsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasScriptsRetrieve'][0])
    {
        $request = $this->extrasScriptsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Script' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Script' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Script', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Script';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Script',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasScriptsRetrieveAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsRetrieveAsync($id, string $contentType = self::contentTypes['extrasScriptsRetrieve'][0])
    {
        return $this->extrasScriptsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasScriptsRetrieveAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasScriptsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Script';
        $request = $this->extrasScriptsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasScriptsRetrieve'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasScriptsRetrieveRequest($id, string $contentType = self::contentTypes['extrasScriptsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasScriptsRetrieve'
            );
        }
        if (!preg_match("/^[^\/]+$/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling ExtrasApi.extrasScriptsRetrieve, must conform to the pattern /^[^\/]+$/.");
        }
        

        $resourcePath = '/api/extras/scripts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasScriptsUpdate
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Script
     */
    public function extrasScriptsUpdate($id, string $contentType = self::contentTypes['extrasScriptsUpdate'][0])
    {
        list($response) = $this->extrasScriptsUpdateWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasScriptsUpdateWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Script, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasScriptsUpdateWithHttpInfo($id, string $contentType = self::contentTypes['extrasScriptsUpdate'][0])
    {
        $request = $this->extrasScriptsUpdateRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Script' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Script' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Script', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Script';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Script',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasScriptsUpdateAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsUpdateAsync($id, string $contentType = self::contentTypes['extrasScriptsUpdate'][0])
    {
        return $this->extrasScriptsUpdateAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasScriptsUpdateAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasScriptsUpdateAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasScriptsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Script';
        $request = $this->extrasScriptsUpdateRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasScriptsUpdate'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasScriptsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasScriptsUpdateRequest($id, string $contentType = self::contentTypes['extrasScriptsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasScriptsUpdate'
            );
        }
        if (!preg_match("/^[^\/]+$/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling ExtrasApi.extrasScriptsUpdate, must conform to the pattern /^[^\/]+$/.");
        }
        

        $resourcePath = '/api/extras/scripts/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasTagsBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasTagsBulkDestroy($tag_request, string $contentType = self::contentTypes['extrasTagsBulkDestroy'][0])
    {
        $this->extrasTagsBulkDestroyWithHttpInfo($tag_request, $contentType);
    }

    /**
     * Operation extrasTagsBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasTagsBulkDestroyWithHttpInfo($tag_request, string $contentType = self::contentTypes['extrasTagsBulkDestroy'][0])
    {
        $request = $this->extrasTagsBulkDestroyRequest($tag_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasTagsBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsBulkDestroyAsync($tag_request, string $contentType = self::contentTypes['extrasTagsBulkDestroy'][0])
    {
        return $this->extrasTagsBulkDestroyAsyncWithHttpInfo($tag_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasTagsBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsBulkDestroyAsyncWithHttpInfo($tag_request, string $contentType = self::contentTypes['extrasTagsBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasTagsBulkDestroyRequest($tag_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasTagsBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasTagsBulkDestroyRequest($tag_request, string $contentType = self::contentTypes['extrasTagsBulkDestroy'][0])
    {

        // verify the required parameter 'tag_request' is set
        if ($tag_request === null || (is_array($tag_request) && count($tag_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag_request when calling extrasTagsBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/tags/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tag_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tag_request));
            } else {
                $httpBody = $tag_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasTagsBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tag[]
     */
    public function extrasTagsBulkPartialUpdate($tag_request, string $contentType = self::contentTypes['extrasTagsBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasTagsBulkPartialUpdateWithHttpInfo($tag_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasTagsBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tag[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasTagsBulkPartialUpdateWithHttpInfo($tag_request, string $contentType = self::contentTypes['extrasTagsBulkPartialUpdate'][0])
    {
        $request = $this->extrasTagsBulkPartialUpdateRequest($tag_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tag[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tag[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tag[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tag[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tag[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasTagsBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsBulkPartialUpdateAsync($tag_request, string $contentType = self::contentTypes['extrasTagsBulkPartialUpdate'][0])
    {
        return $this->extrasTagsBulkPartialUpdateAsyncWithHttpInfo($tag_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasTagsBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsBulkPartialUpdateAsyncWithHttpInfo($tag_request, string $contentType = self::contentTypes['extrasTagsBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tag[]';
        $request = $this->extrasTagsBulkPartialUpdateRequest($tag_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasTagsBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasTagsBulkPartialUpdateRequest($tag_request, string $contentType = self::contentTypes['extrasTagsBulkPartialUpdate'][0])
    {

        // verify the required parameter 'tag_request' is set
        if ($tag_request === null || (is_array($tag_request) && count($tag_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag_request when calling extrasTagsBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/tags/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tag_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tag_request));
            } else {
                $httpBody = $tag_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasTagsBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tag[]
     */
    public function extrasTagsBulkUpdate($tag_request, string $contentType = self::contentTypes['extrasTagsBulkUpdate'][0])
    {
        list($response) = $this->extrasTagsBulkUpdateWithHttpInfo($tag_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasTagsBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tag[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasTagsBulkUpdateWithHttpInfo($tag_request, string $contentType = self::contentTypes['extrasTagsBulkUpdate'][0])
    {
        $request = $this->extrasTagsBulkUpdateRequest($tag_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tag[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tag[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tag[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tag[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tag[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasTagsBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsBulkUpdateAsync($tag_request, string $contentType = self::contentTypes['extrasTagsBulkUpdate'][0])
    {
        return $this->extrasTagsBulkUpdateAsyncWithHttpInfo($tag_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasTagsBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsBulkUpdateAsyncWithHttpInfo($tag_request, string $contentType = self::contentTypes['extrasTagsBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tag[]';
        $request = $this->extrasTagsBulkUpdateRequest($tag_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasTagsBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\TagRequest[] $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasTagsBulkUpdateRequest($tag_request, string $contentType = self::contentTypes['extrasTagsBulkUpdate'][0])
    {

        // verify the required parameter 'tag_request' is set
        if ($tag_request === null || (is_array($tag_request) && count($tag_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag_request when calling extrasTagsBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/tags/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tag_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tag_request));
            } else {
                $httpBody = $tag_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasTagsCreate
     *
     * @param  \OpenAPI\Client\Model\TagRequest $tag_request tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tag
     */
    public function extrasTagsCreate($tag_request, string $contentType = self::contentTypes['extrasTagsCreate'][0])
    {
        list($response) = $this->extrasTagsCreateWithHttpInfo($tag_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasTagsCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TagRequest $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tag, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasTagsCreateWithHttpInfo($tag_request, string $contentType = self::contentTypes['extrasTagsCreate'][0])
    {
        $request = $this->extrasTagsCreateRequest($tag_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Tag' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tag' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tag', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tag';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasTagsCreateAsync
     *
     * @param  \OpenAPI\Client\Model\TagRequest $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsCreateAsync($tag_request, string $contentType = self::contentTypes['extrasTagsCreate'][0])
    {
        return $this->extrasTagsCreateAsyncWithHttpInfo($tag_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasTagsCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\TagRequest $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsCreateAsyncWithHttpInfo($tag_request, string $contentType = self::contentTypes['extrasTagsCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tag';
        $request = $this->extrasTagsCreateRequest($tag_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasTagsCreate'
     *
     * @param  \OpenAPI\Client\Model\TagRequest $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasTagsCreateRequest($tag_request, string $contentType = self::contentTypes['extrasTagsCreate'][0])
    {

        // verify the required parameter 'tag_request' is set
        if ($tag_request === null || (is_array($tag_request) && count($tag_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag_request when calling extrasTagsCreate'
            );
        }


        $resourcePath = '/api/extras/tags/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tag_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tag_request));
            } else {
                $httpBody = $tag_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasTagsDestroy
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasTagsDestroy($id, string $contentType = self::contentTypes['extrasTagsDestroy'][0])
    {
        $this->extrasTagsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasTagsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasTagsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasTagsDestroy'][0])
    {
        $request = $this->extrasTagsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasTagsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsDestroyAsync($id, string $contentType = self::contentTypes['extrasTagsDestroy'][0])
    {
        return $this->extrasTagsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasTagsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasTagsDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasTagsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasTagsDestroy'
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasTagsDestroyRequest($id, string $contentType = self::contentTypes['extrasTagsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasTagsDestroy'
            );
        }


        $resourcePath = '/api/extras/tags/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasTagsList
     *
     * @param  string[] $color color (optional)
     * @param  bool $color__empty color__empty (optional)
     * @param  string[] $color__ic color__ic (optional)
     * @param  string[] $color__ie color__ie (optional)
     * @param  string[] $color__iew color__iew (optional)
     * @param  string[] $color__isw color__isw (optional)
     * @param  string[] $color__n color__n (optional)
     * @param  string[] $color__nic color__nic (optional)
     * @param  string[] $color__nie color__nie (optional)
     * @param  string[] $color__niew color__niew (optional)
     * @param  string[] $color__nisw color__nisw (optional)
     * @param  string[] $content_type content_type (optional)
     * @param  int[] $content_type_id content_type_id (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  int[] $for_object_type_id for_object_type_id (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int[] $object_types object_types (optional)
     * @param  int[] $object_types__n object_types__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug slug (optional)
     * @param  bool $slug__empty slug__empty (optional)
     * @param  string[] $slug__ic slug__ic (optional)
     * @param  string[] $slug__ie slug__ie (optional)
     * @param  string[] $slug__iew slug__iew (optional)
     * @param  string[] $slug__isw slug__isw (optional)
     * @param  string[] $slug__n slug__n (optional)
     * @param  string[] $slug__nic slug__nic (optional)
     * @param  string[] $slug__nie slug__nie (optional)
     * @param  string[] $slug__niew slug__niew (optional)
     * @param  string[] $slug__nisw slug__nisw (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedTagList
     */
    public function extrasTagsList($color = null, $color__empty = null, $color__ic = null, $color__ie = null, $color__iew = null, $color__isw = null, $color__n = null, $color__nic = null, $color__nie = null, $color__niew = null, $color__nisw = null, $content_type = null, $content_type_id = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $for_object_type_id = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_types = null, $object_types__n = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasTagsList'][0])
    {
        list($response) = $this->extrasTagsListWithHttpInfo($color, $color__empty, $color__ic, $color__ie, $color__iew, $color__isw, $color__n, $color__nic, $color__nie, $color__niew, $color__nisw, $content_type, $content_type_id, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $for_object_type_id, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_types, $object_types__n, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasTagsListWithHttpInfo
     *
     * @param  string[] $color (optional)
     * @param  bool $color__empty (optional)
     * @param  string[] $color__ic (optional)
     * @param  string[] $color__ie (optional)
     * @param  string[] $color__iew (optional)
     * @param  string[] $color__isw (optional)
     * @param  string[] $color__n (optional)
     * @param  string[] $color__nic (optional)
     * @param  string[] $color__nie (optional)
     * @param  string[] $color__niew (optional)
     * @param  string[] $color__nisw (optional)
     * @param  string[] $content_type (optional)
     * @param  int[] $content_type_id (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $for_object_type_id (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $object_types (optional)
     * @param  int[] $object_types__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedTagList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasTagsListWithHttpInfo($color = null, $color__empty = null, $color__ic = null, $color__ie = null, $color__iew = null, $color__isw = null, $color__n = null, $color__nic = null, $color__nie = null, $color__niew = null, $color__nisw = null, $content_type = null, $content_type_id = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $for_object_type_id = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_types = null, $object_types__n = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasTagsList'][0])
    {
        $request = $this->extrasTagsListRequest($color, $color__empty, $color__ic, $color__ie, $color__iew, $color__isw, $color__n, $color__nic, $color__nie, $color__niew, $color__nisw, $content_type, $content_type_id, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $for_object_type_id, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_types, $object_types__n, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedTagList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedTagList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedTagList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedTagList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedTagList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasTagsListAsync
     *
     * @param  string[] $color (optional)
     * @param  bool $color__empty (optional)
     * @param  string[] $color__ic (optional)
     * @param  string[] $color__ie (optional)
     * @param  string[] $color__iew (optional)
     * @param  string[] $color__isw (optional)
     * @param  string[] $color__n (optional)
     * @param  string[] $color__nic (optional)
     * @param  string[] $color__nie (optional)
     * @param  string[] $color__niew (optional)
     * @param  string[] $color__nisw (optional)
     * @param  string[] $content_type (optional)
     * @param  int[] $content_type_id (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $for_object_type_id (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $object_types (optional)
     * @param  int[] $object_types__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsListAsync($color = null, $color__empty = null, $color__ic = null, $color__ie = null, $color__iew = null, $color__isw = null, $color__n = null, $color__nic = null, $color__nie = null, $color__niew = null, $color__nisw = null, $content_type = null, $content_type_id = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $for_object_type_id = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_types = null, $object_types__n = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasTagsList'][0])
    {
        return $this->extrasTagsListAsyncWithHttpInfo($color, $color__empty, $color__ic, $color__ie, $color__iew, $color__isw, $color__n, $color__nic, $color__nie, $color__niew, $color__nisw, $content_type, $content_type_id, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $for_object_type_id, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_types, $object_types__n, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasTagsListAsyncWithHttpInfo
     *
     * @param  string[] $color (optional)
     * @param  bool $color__empty (optional)
     * @param  string[] $color__ic (optional)
     * @param  string[] $color__ie (optional)
     * @param  string[] $color__iew (optional)
     * @param  string[] $color__isw (optional)
     * @param  string[] $color__n (optional)
     * @param  string[] $color__nic (optional)
     * @param  string[] $color__nie (optional)
     * @param  string[] $color__niew (optional)
     * @param  string[] $color__nisw (optional)
     * @param  string[] $content_type (optional)
     * @param  int[] $content_type_id (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $for_object_type_id (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $object_types (optional)
     * @param  int[] $object_types__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsListAsyncWithHttpInfo($color = null, $color__empty = null, $color__ic = null, $color__ie = null, $color__iew = null, $color__isw = null, $color__n = null, $color__nic = null, $color__nie = null, $color__niew = null, $color__nisw = null, $content_type = null, $content_type_id = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $for_object_type_id = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_types = null, $object_types__n = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasTagsList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedTagList';
        $request = $this->extrasTagsListRequest($color, $color__empty, $color__ic, $color__ie, $color__iew, $color__isw, $color__n, $color__nic, $color__nie, $color__niew, $color__nisw, $content_type, $content_type_id, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $for_object_type_id, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $object_types, $object_types__n, $offset, $ordering, $q, $slug, $slug__empty, $slug__ic, $slug__ie, $slug__iew, $slug__isw, $slug__n, $slug__nic, $slug__nie, $slug__niew, $slug__nisw, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasTagsList'
     *
     * @param  string[] $color (optional)
     * @param  bool $color__empty (optional)
     * @param  string[] $color__ic (optional)
     * @param  string[] $color__ie (optional)
     * @param  string[] $color__iew (optional)
     * @param  string[] $color__isw (optional)
     * @param  string[] $color__n (optional)
     * @param  string[] $color__nic (optional)
     * @param  string[] $color__nie (optional)
     * @param  string[] $color__niew (optional)
     * @param  string[] $color__nisw (optional)
     * @param  string[] $content_type (optional)
     * @param  int[] $content_type_id (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  int[] $for_object_type_id (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int[] $object_types (optional)
     * @param  int[] $object_types__n (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string $q Search (optional)
     * @param  string[] $slug (optional)
     * @param  bool $slug__empty (optional)
     * @param  string[] $slug__ic (optional)
     * @param  string[] $slug__ie (optional)
     * @param  string[] $slug__iew (optional)
     * @param  string[] $slug__isw (optional)
     * @param  string[] $slug__n (optional)
     * @param  string[] $slug__nic (optional)
     * @param  string[] $slug__nie (optional)
     * @param  string[] $slug__niew (optional)
     * @param  string[] $slug__nisw (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasTagsListRequest($color = null, $color__empty = null, $color__ic = null, $color__ie = null, $color__iew = null, $color__isw = null, $color__n = null, $color__nic = null, $color__nie = null, $color__niew = null, $color__nisw = null, $content_type = null, $content_type_id = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $for_object_type_id = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $object_types = null, $object_types__n = null, $offset = null, $ordering = null, $q = null, $slug = null, $slug__empty = null, $slug__ic = null, $slug__ie = null, $slug__iew = null, $slug__isw = null, $slug__n = null, $slug__nic = null, $slug__nie = null, $slug__niew = null, $slug__nisw = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasTagsList'][0])
    {















































































        $resourcePath = '/api/extras/tags/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color,
            'color', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__empty,
            'color__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__ic,
            'color__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__ie,
            'color__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__iew,
            'color__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__isw,
            'color__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__n,
            'color__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__nic,
            'color__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__nie,
            'color__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__niew,
            'color__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $color__nisw,
            'color__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content_type,
            'content_type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content_type_id,
            'content_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $for_object_type_id,
            'for_object_type_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_types,
            'object_types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $object_types__n,
            'object_types__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__empty,
            'slug__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ic,
            'slug__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__ie,
            'slug__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__iew,
            'slug__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__isw,
            'slug__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__n,
            'slug__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nic,
            'slug__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nie,
            'slug__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__niew,
            'slug__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug__nisw,
            'slug__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasTagsPartialUpdate
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  \OpenAPI\Client\Model\PatchedTagRequest $patched_tag_request patched_tag_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tag
     */
    public function extrasTagsPartialUpdate($id, $patched_tag_request = null, string $contentType = self::contentTypes['extrasTagsPartialUpdate'][0])
    {
        list($response) = $this->extrasTagsPartialUpdateWithHttpInfo($id, $patched_tag_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasTagsPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  \OpenAPI\Client\Model\PatchedTagRequest $patched_tag_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tag, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasTagsPartialUpdateWithHttpInfo($id, $patched_tag_request = null, string $contentType = self::contentTypes['extrasTagsPartialUpdate'][0])
    {
        $request = $this->extrasTagsPartialUpdateRequest($id, $patched_tag_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tag' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tag' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tag', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tag';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasTagsPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  \OpenAPI\Client\Model\PatchedTagRequest $patched_tag_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsPartialUpdateAsync($id, $patched_tag_request = null, string $contentType = self::contentTypes['extrasTagsPartialUpdate'][0])
    {
        return $this->extrasTagsPartialUpdateAsyncWithHttpInfo($id, $patched_tag_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasTagsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  \OpenAPI\Client\Model\PatchedTagRequest $patched_tag_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsPartialUpdateAsyncWithHttpInfo($id, $patched_tag_request = null, string $contentType = self::contentTypes['extrasTagsPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tag';
        $request = $this->extrasTagsPartialUpdateRequest($id, $patched_tag_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasTagsPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  \OpenAPI\Client\Model\PatchedTagRequest $patched_tag_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasTagsPartialUpdateRequest($id, $patched_tag_request = null, string $contentType = self::contentTypes['extrasTagsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasTagsPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/tags/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_tag_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_tag_request));
            } else {
                $httpBody = $patched_tag_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasTagsRetrieve
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tag
     */
    public function extrasTagsRetrieve($id, string $contentType = self::contentTypes['extrasTagsRetrieve'][0])
    {
        list($response) = $this->extrasTagsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasTagsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tag, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasTagsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasTagsRetrieve'][0])
    {
        $request = $this->extrasTagsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tag' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tag' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tag', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tag';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasTagsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsRetrieveAsync($id, string $contentType = self::contentTypes['extrasTagsRetrieve'][0])
    {
        return $this->extrasTagsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasTagsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasTagsRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tag';
        $request = $this->extrasTagsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasTagsRetrieve'
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasTagsRetrieveRequest($id, string $contentType = self::contentTypes['extrasTagsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasTagsRetrieve'
            );
        }


        $resourcePath = '/api/extras/tags/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasTagsUpdate
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  \OpenAPI\Client\Model\TagRequest $tag_request tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tag
     */
    public function extrasTagsUpdate($id, $tag_request, string $contentType = self::contentTypes['extrasTagsUpdate'][0])
    {
        list($response) = $this->extrasTagsUpdateWithHttpInfo($id, $tag_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasTagsUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  \OpenAPI\Client\Model\TagRequest $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tag, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasTagsUpdateWithHttpInfo($id, $tag_request, string $contentType = self::contentTypes['extrasTagsUpdate'][0])
    {
        $request = $this->extrasTagsUpdateRequest($id, $tag_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tag' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tag' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tag', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tag';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasTagsUpdateAsync
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  \OpenAPI\Client\Model\TagRequest $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsUpdateAsync($id, $tag_request, string $contentType = self::contentTypes['extrasTagsUpdate'][0])
    {
        return $this->extrasTagsUpdateAsyncWithHttpInfo($id, $tag_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasTagsUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  \OpenAPI\Client\Model\TagRequest $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasTagsUpdateAsyncWithHttpInfo($id, $tag_request, string $contentType = self::contentTypes['extrasTagsUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tag';
        $request = $this->extrasTagsUpdateRequest($id, $tag_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasTagsUpdate'
     *
     * @param  int $id A unique integer value identifying this tag. (required)
     * @param  \OpenAPI\Client\Model\TagRequest $tag_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasTagsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasTagsUpdateRequest($id, $tag_request, string $contentType = self::contentTypes['extrasTagsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasTagsUpdate'
            );
        }

        // verify the required parameter 'tag_request' is set
        if ($tag_request === null || (is_array($tag_request) && count($tag_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag_request when calling extrasTagsUpdate'
            );
        }


        $resourcePath = '/api/extras/tags/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tag_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tag_request));
            } else {
                $httpBody = $tag_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasWebhooksBulkDestroy
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasWebhooksBulkDestroy($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkDestroy'][0])
    {
        $this->extrasWebhooksBulkDestroyWithHttpInfo($webhook_request, $contentType);
    }

    /**
     * Operation extrasWebhooksBulkDestroyWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasWebhooksBulkDestroyWithHttpInfo($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkDestroy'][0])
    {
        $request = $this->extrasWebhooksBulkDestroyRequest($webhook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasWebhooksBulkDestroyAsync
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksBulkDestroyAsync($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkDestroy'][0])
    {
        return $this->extrasWebhooksBulkDestroyAsyncWithHttpInfo($webhook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasWebhooksBulkDestroyAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksBulkDestroyAsyncWithHttpInfo($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasWebhooksBulkDestroyRequest($webhook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasWebhooksBulkDestroy'
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasWebhooksBulkDestroyRequest($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkDestroy'][0])
    {

        // verify the required parameter 'webhook_request' is set
        if ($webhook_request === null || (is_array($webhook_request) && count($webhook_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_request when calling extrasWebhooksBulkDestroy'
            );
        }


        $resourcePath = '/api/extras/webhooks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($webhook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhook_request));
            } else {
                $httpBody = $webhook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasWebhooksBulkPartialUpdate
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Webhook[]
     */
    public function extrasWebhooksBulkPartialUpdate($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkPartialUpdate'][0])
    {
        list($response) = $this->extrasWebhooksBulkPartialUpdateWithHttpInfo($webhook_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasWebhooksBulkPartialUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Webhook[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasWebhooksBulkPartialUpdateWithHttpInfo($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkPartialUpdate'][0])
    {
        $request = $this->extrasWebhooksBulkPartialUpdateRequest($webhook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Webhook[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Webhook[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Webhook[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Webhook[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Webhook[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasWebhooksBulkPartialUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksBulkPartialUpdateAsync($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkPartialUpdate'][0])
    {
        return $this->extrasWebhooksBulkPartialUpdateAsyncWithHttpInfo($webhook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasWebhooksBulkPartialUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksBulkPartialUpdateAsyncWithHttpInfo($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Webhook[]';
        $request = $this->extrasWebhooksBulkPartialUpdateRequest($webhook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasWebhooksBulkPartialUpdate'
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasWebhooksBulkPartialUpdateRequest($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkPartialUpdate'][0])
    {

        // verify the required parameter 'webhook_request' is set
        if ($webhook_request === null || (is_array($webhook_request) && count($webhook_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_request when calling extrasWebhooksBulkPartialUpdate'
            );
        }


        $resourcePath = '/api/extras/webhooks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($webhook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhook_request));
            } else {
                $httpBody = $webhook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasWebhooksBulkUpdate
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Webhook[]
     */
    public function extrasWebhooksBulkUpdate($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkUpdate'][0])
    {
        list($response) = $this->extrasWebhooksBulkUpdateWithHttpInfo($webhook_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasWebhooksBulkUpdateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Webhook[], HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasWebhooksBulkUpdateWithHttpInfo($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkUpdate'][0])
    {
        $request = $this->extrasWebhooksBulkUpdateRequest($webhook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Webhook[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Webhook[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Webhook[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Webhook[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Webhook[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasWebhooksBulkUpdateAsync
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksBulkUpdateAsync($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkUpdate'][0])
    {
        return $this->extrasWebhooksBulkUpdateAsyncWithHttpInfo($webhook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasWebhooksBulkUpdateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksBulkUpdateAsyncWithHttpInfo($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Webhook[]';
        $request = $this->extrasWebhooksBulkUpdateRequest($webhook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasWebhooksBulkUpdate'
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest[] $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksBulkUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasWebhooksBulkUpdateRequest($webhook_request, string $contentType = self::contentTypes['extrasWebhooksBulkUpdate'][0])
    {

        // verify the required parameter 'webhook_request' is set
        if ($webhook_request === null || (is_array($webhook_request) && count($webhook_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_request when calling extrasWebhooksBulkUpdate'
            );
        }


        $resourcePath = '/api/extras/webhooks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($webhook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhook_request));
            } else {
                $httpBody = $webhook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasWebhooksCreate
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest $webhook_request webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Webhook
     */
    public function extrasWebhooksCreate($webhook_request, string $contentType = self::contentTypes['extrasWebhooksCreate'][0])
    {
        list($response) = $this->extrasWebhooksCreateWithHttpInfo($webhook_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasWebhooksCreateWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksCreate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasWebhooksCreateWithHttpInfo($webhook_request, string $contentType = self::contentTypes['extrasWebhooksCreate'][0])
    {
        $request = $this->extrasWebhooksCreateRequest($webhook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Webhook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Webhook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Webhook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Webhook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasWebhooksCreateAsync
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksCreateAsync($webhook_request, string $contentType = self::contentTypes['extrasWebhooksCreate'][0])
    {
        return $this->extrasWebhooksCreateAsyncWithHttpInfo($webhook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasWebhooksCreateAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksCreateAsyncWithHttpInfo($webhook_request, string $contentType = self::contentTypes['extrasWebhooksCreate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Webhook';
        $request = $this->extrasWebhooksCreateRequest($webhook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasWebhooksCreate'
     *
     * @param  \OpenAPI\Client\Model\WebhookRequest $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasWebhooksCreateRequest($webhook_request, string $contentType = self::contentTypes['extrasWebhooksCreate'][0])
    {

        // verify the required parameter 'webhook_request' is set
        if ($webhook_request === null || (is_array($webhook_request) && count($webhook_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_request when calling extrasWebhooksCreate'
            );
        }


        $resourcePath = '/api/extras/webhooks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($webhook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhook_request));
            } else {
                $httpBody = $webhook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasWebhooksDestroy
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extrasWebhooksDestroy($id, string $contentType = self::contentTypes['extrasWebhooksDestroy'][0])
    {
        $this->extrasWebhooksDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation extrasWebhooksDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksDestroy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasWebhooksDestroyWithHttpInfo($id, string $contentType = self::contentTypes['extrasWebhooksDestroy'][0])
    {
        $request = $this->extrasWebhooksDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation extrasWebhooksDestroyAsync
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksDestroyAsync($id, string $contentType = self::contentTypes['extrasWebhooksDestroy'][0])
    {
        return $this->extrasWebhooksDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasWebhooksDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasWebhooksDestroy'][0])
    {
        $returnType = '';
        $request = $this->extrasWebhooksDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasWebhooksDestroy'
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasWebhooksDestroyRequest($id, string $contentType = self::contentTypes['extrasWebhooksDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasWebhooksDestroy'
            );
        }


        $resourcePath = '/api/extras/webhooks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasWebhooksList
     *
     * @param  string[] $ca_file_path ca_file_path (optional)
     * @param  bool $ca_file_path__empty ca_file_path__empty (optional)
     * @param  string[] $ca_file_path__ic ca_file_path__ic (optional)
     * @param  string[] $ca_file_path__ie ca_file_path__ie (optional)
     * @param  string[] $ca_file_path__iew ca_file_path__iew (optional)
     * @param  string[] $ca_file_path__isw ca_file_path__isw (optional)
     * @param  string[] $ca_file_path__n ca_file_path__n (optional)
     * @param  string[] $ca_file_path__nic ca_file_path__nic (optional)
     * @param  string[] $ca_file_path__nie ca_file_path__nie (optional)
     * @param  string[] $ca_file_path__niew ca_file_path__niew (optional)
     * @param  string[] $ca_file_path__nisw ca_file_path__nisw (optional)
     * @param  \DateTime[] $created created (optional)
     * @param  \DateTime[] $created__empty created__empty (optional)
     * @param  \DateTime[] $created__gt created__gt (optional)
     * @param  \DateTime[] $created__gte created__gte (optional)
     * @param  \DateTime[] $created__lt created__lt (optional)
     * @param  \DateTime[] $created__lte created__lte (optional)
     * @param  \DateTime[] $created__n created__n (optional)
     * @param  string $created_by_request created_by_request (optional)
     * @param  string[] $description description (optional)
     * @param  bool $description__empty description__empty (optional)
     * @param  string[] $description__ic description__ic (optional)
     * @param  string[] $description__ie description__ie (optional)
     * @param  string[] $description__iew description__iew (optional)
     * @param  string[] $description__isw description__isw (optional)
     * @param  string[] $description__n description__n (optional)
     * @param  string[] $description__nic description__nic (optional)
     * @param  string[] $description__nie description__nie (optional)
     * @param  string[] $description__niew description__niew (optional)
     * @param  string[] $description__nisw description__nisw (optional)
     * @param  string[] $http_content_type http_content_type (optional)
     * @param  bool $http_content_type__empty http_content_type__empty (optional)
     * @param  string[] $http_content_type__ic http_content_type__ic (optional)
     * @param  string[] $http_content_type__ie http_content_type__ie (optional)
     * @param  string[] $http_content_type__iew http_content_type__iew (optional)
     * @param  string[] $http_content_type__isw http_content_type__isw (optional)
     * @param  string[] $http_content_type__n http_content_type__n (optional)
     * @param  string[] $http_content_type__nic http_content_type__nic (optional)
     * @param  string[] $http_content_type__nie http_content_type__nie (optional)
     * @param  string[] $http_content_type__niew http_content_type__niew (optional)
     * @param  string[] $http_content_type__nisw http_content_type__nisw (optional)
     * @param  string[] $http_method http_method (optional)
     * @param  string[] $http_method__n http_method__n (optional)
     * @param  int[] $id id (optional)
     * @param  bool $id__empty id__empty (optional)
     * @param  int[] $id__gt id__gt (optional)
     * @param  int[] $id__gte id__gte (optional)
     * @param  int[] $id__lt id__lt (optional)
     * @param  int[] $id__lte id__lte (optional)
     * @param  int[] $id__n id__n (optional)
     * @param  \DateTime[] $last_updated last_updated (optional)
     * @param  \DateTime[] $last_updated__empty last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request modified_by_request (optional)
     * @param  string[] $name name (optional)
     * @param  bool $name__empty name__empty (optional)
     * @param  string[] $name__ic name__ic (optional)
     * @param  string[] $name__ie name__ie (optional)
     * @param  string[] $name__iew name__iew (optional)
     * @param  string[] $name__isw name__isw (optional)
     * @param  string[] $name__n name__n (optional)
     * @param  string[] $name__nic name__nic (optional)
     * @param  string[] $name__nie name__nie (optional)
     * @param  string[] $name__niew name__niew (optional)
     * @param  string[] $name__nisw name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $payload_url payload_url (optional)
     * @param  string $q Search (optional)
     * @param  string[] $secret secret (optional)
     * @param  bool $secret__empty secret__empty (optional)
     * @param  string[] $secret__ic secret__ic (optional)
     * @param  string[] $secret__ie secret__ie (optional)
     * @param  string[] $secret__iew secret__iew (optional)
     * @param  string[] $secret__isw secret__isw (optional)
     * @param  string[] $secret__n secret__n (optional)
     * @param  string[] $secret__nic secret__nic (optional)
     * @param  string[] $secret__nie secret__nie (optional)
     * @param  string[] $secret__niew secret__niew (optional)
     * @param  string[] $secret__nisw secret__nisw (optional)
     * @param  bool $ssl_verification ssl_verification (optional)
     * @param  string[] $tag tag (optional)
     * @param  string[] $tag__n tag__n (optional)
     * @param  string $updated_by_request updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaginatedWebhookList
     */
    public function extrasWebhooksList($ca_file_path = null, $ca_file_path__empty = null, $ca_file_path__ic = null, $ca_file_path__ie = null, $ca_file_path__iew = null, $ca_file_path__isw = null, $ca_file_path__n = null, $ca_file_path__nic = null, $ca_file_path__nie = null, $ca_file_path__niew = null, $ca_file_path__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $http_content_type = null, $http_content_type__empty = null, $http_content_type__ic = null, $http_content_type__ie = null, $http_content_type__iew = null, $http_content_type__isw = null, $http_content_type__n = null, $http_content_type__nic = null, $http_content_type__nie = null, $http_content_type__niew = null, $http_content_type__nisw = null, $http_method = null, $http_method__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $payload_url = null, $q = null, $secret = null, $secret__empty = null, $secret__ic = null, $secret__ie = null, $secret__iew = null, $secret__isw = null, $secret__n = null, $secret__nic = null, $secret__nie = null, $secret__niew = null, $secret__nisw = null, $ssl_verification = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasWebhooksList'][0])
    {
        list($response) = $this->extrasWebhooksListWithHttpInfo($ca_file_path, $ca_file_path__empty, $ca_file_path__ic, $ca_file_path__ie, $ca_file_path__iew, $ca_file_path__isw, $ca_file_path__n, $ca_file_path__nic, $ca_file_path__nie, $ca_file_path__niew, $ca_file_path__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $http_content_type, $http_content_type__empty, $http_content_type__ic, $http_content_type__ie, $http_content_type__iew, $http_content_type__isw, $http_content_type__n, $http_content_type__nic, $http_content_type__nie, $http_content_type__niew, $http_content_type__nisw, $http_method, $http_method__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $payload_url, $q, $secret, $secret__empty, $secret__ic, $secret__ie, $secret__iew, $secret__isw, $secret__n, $secret__nic, $secret__nie, $secret__niew, $secret__nisw, $ssl_verification, $tag, $tag__n, $updated_by_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasWebhooksListWithHttpInfo
     *
     * @param  string[] $ca_file_path (optional)
     * @param  bool $ca_file_path__empty (optional)
     * @param  string[] $ca_file_path__ic (optional)
     * @param  string[] $ca_file_path__ie (optional)
     * @param  string[] $ca_file_path__iew (optional)
     * @param  string[] $ca_file_path__isw (optional)
     * @param  string[] $ca_file_path__n (optional)
     * @param  string[] $ca_file_path__nic (optional)
     * @param  string[] $ca_file_path__nie (optional)
     * @param  string[] $ca_file_path__niew (optional)
     * @param  string[] $ca_file_path__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $http_content_type (optional)
     * @param  bool $http_content_type__empty (optional)
     * @param  string[] $http_content_type__ic (optional)
     * @param  string[] $http_content_type__ie (optional)
     * @param  string[] $http_content_type__iew (optional)
     * @param  string[] $http_content_type__isw (optional)
     * @param  string[] $http_content_type__n (optional)
     * @param  string[] $http_content_type__nic (optional)
     * @param  string[] $http_content_type__nie (optional)
     * @param  string[] $http_content_type__niew (optional)
     * @param  string[] $http_content_type__nisw (optional)
     * @param  string[] $http_method (optional)
     * @param  string[] $http_method__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $payload_url (optional)
     * @param  string $q Search (optional)
     * @param  string[] $secret (optional)
     * @param  bool $secret__empty (optional)
     * @param  string[] $secret__ic (optional)
     * @param  string[] $secret__ie (optional)
     * @param  string[] $secret__iew (optional)
     * @param  string[] $secret__isw (optional)
     * @param  string[] $secret__n (optional)
     * @param  string[] $secret__nic (optional)
     * @param  string[] $secret__nie (optional)
     * @param  string[] $secret__niew (optional)
     * @param  string[] $secret__nisw (optional)
     * @param  bool $ssl_verification (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaginatedWebhookList, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasWebhooksListWithHttpInfo($ca_file_path = null, $ca_file_path__empty = null, $ca_file_path__ic = null, $ca_file_path__ie = null, $ca_file_path__iew = null, $ca_file_path__isw = null, $ca_file_path__n = null, $ca_file_path__nic = null, $ca_file_path__nie = null, $ca_file_path__niew = null, $ca_file_path__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $http_content_type = null, $http_content_type__empty = null, $http_content_type__ic = null, $http_content_type__ie = null, $http_content_type__iew = null, $http_content_type__isw = null, $http_content_type__n = null, $http_content_type__nic = null, $http_content_type__nie = null, $http_content_type__niew = null, $http_content_type__nisw = null, $http_method = null, $http_method__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $payload_url = null, $q = null, $secret = null, $secret__empty = null, $secret__ic = null, $secret__ie = null, $secret__iew = null, $secret__isw = null, $secret__n = null, $secret__nic = null, $secret__nie = null, $secret__niew = null, $secret__nisw = null, $ssl_verification = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasWebhooksList'][0])
    {
        $request = $this->extrasWebhooksListRequest($ca_file_path, $ca_file_path__empty, $ca_file_path__ic, $ca_file_path__ie, $ca_file_path__iew, $ca_file_path__isw, $ca_file_path__n, $ca_file_path__nic, $ca_file_path__nie, $ca_file_path__niew, $ca_file_path__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $http_content_type, $http_content_type__empty, $http_content_type__ic, $http_content_type__ie, $http_content_type__iew, $http_content_type__isw, $http_content_type__n, $http_content_type__nic, $http_content_type__nie, $http_content_type__niew, $http_content_type__nisw, $http_method, $http_method__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $payload_url, $q, $secret, $secret__empty, $secret__ic, $secret__ie, $secret__iew, $secret__isw, $secret__n, $secret__nic, $secret__nie, $secret__niew, $secret__nisw, $ssl_verification, $tag, $tag__n, $updated_by_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaginatedWebhookList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaginatedWebhookList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaginatedWebhookList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaginatedWebhookList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaginatedWebhookList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasWebhooksListAsync
     *
     * @param  string[] $ca_file_path (optional)
     * @param  bool $ca_file_path__empty (optional)
     * @param  string[] $ca_file_path__ic (optional)
     * @param  string[] $ca_file_path__ie (optional)
     * @param  string[] $ca_file_path__iew (optional)
     * @param  string[] $ca_file_path__isw (optional)
     * @param  string[] $ca_file_path__n (optional)
     * @param  string[] $ca_file_path__nic (optional)
     * @param  string[] $ca_file_path__nie (optional)
     * @param  string[] $ca_file_path__niew (optional)
     * @param  string[] $ca_file_path__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $http_content_type (optional)
     * @param  bool $http_content_type__empty (optional)
     * @param  string[] $http_content_type__ic (optional)
     * @param  string[] $http_content_type__ie (optional)
     * @param  string[] $http_content_type__iew (optional)
     * @param  string[] $http_content_type__isw (optional)
     * @param  string[] $http_content_type__n (optional)
     * @param  string[] $http_content_type__nic (optional)
     * @param  string[] $http_content_type__nie (optional)
     * @param  string[] $http_content_type__niew (optional)
     * @param  string[] $http_content_type__nisw (optional)
     * @param  string[] $http_method (optional)
     * @param  string[] $http_method__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $payload_url (optional)
     * @param  string $q Search (optional)
     * @param  string[] $secret (optional)
     * @param  bool $secret__empty (optional)
     * @param  string[] $secret__ic (optional)
     * @param  string[] $secret__ie (optional)
     * @param  string[] $secret__iew (optional)
     * @param  string[] $secret__isw (optional)
     * @param  string[] $secret__n (optional)
     * @param  string[] $secret__nic (optional)
     * @param  string[] $secret__nie (optional)
     * @param  string[] $secret__niew (optional)
     * @param  string[] $secret__nisw (optional)
     * @param  bool $ssl_verification (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksListAsync($ca_file_path = null, $ca_file_path__empty = null, $ca_file_path__ic = null, $ca_file_path__ie = null, $ca_file_path__iew = null, $ca_file_path__isw = null, $ca_file_path__n = null, $ca_file_path__nic = null, $ca_file_path__nie = null, $ca_file_path__niew = null, $ca_file_path__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $http_content_type = null, $http_content_type__empty = null, $http_content_type__ic = null, $http_content_type__ie = null, $http_content_type__iew = null, $http_content_type__isw = null, $http_content_type__n = null, $http_content_type__nic = null, $http_content_type__nie = null, $http_content_type__niew = null, $http_content_type__nisw = null, $http_method = null, $http_method__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $payload_url = null, $q = null, $secret = null, $secret__empty = null, $secret__ic = null, $secret__ie = null, $secret__iew = null, $secret__isw = null, $secret__n = null, $secret__nic = null, $secret__nie = null, $secret__niew = null, $secret__nisw = null, $ssl_verification = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasWebhooksList'][0])
    {
        return $this->extrasWebhooksListAsyncWithHttpInfo($ca_file_path, $ca_file_path__empty, $ca_file_path__ic, $ca_file_path__ie, $ca_file_path__iew, $ca_file_path__isw, $ca_file_path__n, $ca_file_path__nic, $ca_file_path__nie, $ca_file_path__niew, $ca_file_path__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $http_content_type, $http_content_type__empty, $http_content_type__ic, $http_content_type__ie, $http_content_type__iew, $http_content_type__isw, $http_content_type__n, $http_content_type__nic, $http_content_type__nie, $http_content_type__niew, $http_content_type__nisw, $http_method, $http_method__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $payload_url, $q, $secret, $secret__empty, $secret__ic, $secret__ie, $secret__iew, $secret__isw, $secret__n, $secret__nic, $secret__nie, $secret__niew, $secret__nisw, $ssl_verification, $tag, $tag__n, $updated_by_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasWebhooksListAsyncWithHttpInfo
     *
     * @param  string[] $ca_file_path (optional)
     * @param  bool $ca_file_path__empty (optional)
     * @param  string[] $ca_file_path__ic (optional)
     * @param  string[] $ca_file_path__ie (optional)
     * @param  string[] $ca_file_path__iew (optional)
     * @param  string[] $ca_file_path__isw (optional)
     * @param  string[] $ca_file_path__n (optional)
     * @param  string[] $ca_file_path__nic (optional)
     * @param  string[] $ca_file_path__nie (optional)
     * @param  string[] $ca_file_path__niew (optional)
     * @param  string[] $ca_file_path__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $http_content_type (optional)
     * @param  bool $http_content_type__empty (optional)
     * @param  string[] $http_content_type__ic (optional)
     * @param  string[] $http_content_type__ie (optional)
     * @param  string[] $http_content_type__iew (optional)
     * @param  string[] $http_content_type__isw (optional)
     * @param  string[] $http_content_type__n (optional)
     * @param  string[] $http_content_type__nic (optional)
     * @param  string[] $http_content_type__nie (optional)
     * @param  string[] $http_content_type__niew (optional)
     * @param  string[] $http_content_type__nisw (optional)
     * @param  string[] $http_method (optional)
     * @param  string[] $http_method__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $payload_url (optional)
     * @param  string $q Search (optional)
     * @param  string[] $secret (optional)
     * @param  bool $secret__empty (optional)
     * @param  string[] $secret__ic (optional)
     * @param  string[] $secret__ie (optional)
     * @param  string[] $secret__iew (optional)
     * @param  string[] $secret__isw (optional)
     * @param  string[] $secret__n (optional)
     * @param  string[] $secret__nic (optional)
     * @param  string[] $secret__nie (optional)
     * @param  string[] $secret__niew (optional)
     * @param  string[] $secret__nisw (optional)
     * @param  bool $ssl_verification (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksListAsyncWithHttpInfo($ca_file_path = null, $ca_file_path__empty = null, $ca_file_path__ic = null, $ca_file_path__ie = null, $ca_file_path__iew = null, $ca_file_path__isw = null, $ca_file_path__n = null, $ca_file_path__nic = null, $ca_file_path__nie = null, $ca_file_path__niew = null, $ca_file_path__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $http_content_type = null, $http_content_type__empty = null, $http_content_type__ic = null, $http_content_type__ie = null, $http_content_type__iew = null, $http_content_type__isw = null, $http_content_type__n = null, $http_content_type__nic = null, $http_content_type__nie = null, $http_content_type__niew = null, $http_content_type__nisw = null, $http_method = null, $http_method__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $payload_url = null, $q = null, $secret = null, $secret__empty = null, $secret__ic = null, $secret__ie = null, $secret__iew = null, $secret__isw = null, $secret__n = null, $secret__nic = null, $secret__nie = null, $secret__niew = null, $secret__nisw = null, $ssl_verification = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasWebhooksList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaginatedWebhookList';
        $request = $this->extrasWebhooksListRequest($ca_file_path, $ca_file_path__empty, $ca_file_path__ic, $ca_file_path__ie, $ca_file_path__iew, $ca_file_path__isw, $ca_file_path__n, $ca_file_path__nic, $ca_file_path__nie, $ca_file_path__niew, $ca_file_path__nisw, $created, $created__empty, $created__gt, $created__gte, $created__lt, $created__lte, $created__n, $created_by_request, $description, $description__empty, $description__ic, $description__ie, $description__iew, $description__isw, $description__n, $description__nic, $description__nie, $description__niew, $description__nisw, $http_content_type, $http_content_type__empty, $http_content_type__ic, $http_content_type__ie, $http_content_type__iew, $http_content_type__isw, $http_content_type__n, $http_content_type__nic, $http_content_type__nie, $http_content_type__niew, $http_content_type__nisw, $http_method, $http_method__n, $id, $id__empty, $id__gt, $id__gte, $id__lt, $id__lte, $id__n, $last_updated, $last_updated__empty, $last_updated__gt, $last_updated__gte, $last_updated__lt, $last_updated__lte, $last_updated__n, $limit, $modified_by_request, $name, $name__empty, $name__ic, $name__ie, $name__iew, $name__isw, $name__n, $name__nic, $name__nie, $name__niew, $name__nisw, $offset, $ordering, $payload_url, $q, $secret, $secret__empty, $secret__ic, $secret__ie, $secret__iew, $secret__isw, $secret__n, $secret__nic, $secret__nie, $secret__niew, $secret__nisw, $ssl_verification, $tag, $tag__n, $updated_by_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasWebhooksList'
     *
     * @param  string[] $ca_file_path (optional)
     * @param  bool $ca_file_path__empty (optional)
     * @param  string[] $ca_file_path__ic (optional)
     * @param  string[] $ca_file_path__ie (optional)
     * @param  string[] $ca_file_path__iew (optional)
     * @param  string[] $ca_file_path__isw (optional)
     * @param  string[] $ca_file_path__n (optional)
     * @param  string[] $ca_file_path__nic (optional)
     * @param  string[] $ca_file_path__nie (optional)
     * @param  string[] $ca_file_path__niew (optional)
     * @param  string[] $ca_file_path__nisw (optional)
     * @param  \DateTime[] $created (optional)
     * @param  \DateTime[] $created__empty (optional)
     * @param  \DateTime[] $created__gt (optional)
     * @param  \DateTime[] $created__gte (optional)
     * @param  \DateTime[] $created__lt (optional)
     * @param  \DateTime[] $created__lte (optional)
     * @param  \DateTime[] $created__n (optional)
     * @param  string $created_by_request (optional)
     * @param  string[] $description (optional)
     * @param  bool $description__empty (optional)
     * @param  string[] $description__ic (optional)
     * @param  string[] $description__ie (optional)
     * @param  string[] $description__iew (optional)
     * @param  string[] $description__isw (optional)
     * @param  string[] $description__n (optional)
     * @param  string[] $description__nic (optional)
     * @param  string[] $description__nie (optional)
     * @param  string[] $description__niew (optional)
     * @param  string[] $description__nisw (optional)
     * @param  string[] $http_content_type (optional)
     * @param  bool $http_content_type__empty (optional)
     * @param  string[] $http_content_type__ic (optional)
     * @param  string[] $http_content_type__ie (optional)
     * @param  string[] $http_content_type__iew (optional)
     * @param  string[] $http_content_type__isw (optional)
     * @param  string[] $http_content_type__n (optional)
     * @param  string[] $http_content_type__nic (optional)
     * @param  string[] $http_content_type__nie (optional)
     * @param  string[] $http_content_type__niew (optional)
     * @param  string[] $http_content_type__nisw (optional)
     * @param  string[] $http_method (optional)
     * @param  string[] $http_method__n (optional)
     * @param  int[] $id (optional)
     * @param  bool $id__empty (optional)
     * @param  int[] $id__gt (optional)
     * @param  int[] $id__gte (optional)
     * @param  int[] $id__lt (optional)
     * @param  int[] $id__lte (optional)
     * @param  int[] $id__n (optional)
     * @param  \DateTime[] $last_updated (optional)
     * @param  \DateTime[] $last_updated__empty (optional)
     * @param  \DateTime[] $last_updated__gt (optional)
     * @param  \DateTime[] $last_updated__gte (optional)
     * @param  \DateTime[] $last_updated__lt (optional)
     * @param  \DateTime[] $last_updated__lte (optional)
     * @param  \DateTime[] $last_updated__n (optional)
     * @param  int $limit Number of results to return per page. (optional)
     * @param  string $modified_by_request (optional)
     * @param  string[] $name (optional)
     * @param  bool $name__empty (optional)
     * @param  string[] $name__ic (optional)
     * @param  string[] $name__ie (optional)
     * @param  string[] $name__iew (optional)
     * @param  string[] $name__isw (optional)
     * @param  string[] $name__n (optional)
     * @param  string[] $name__nic (optional)
     * @param  string[] $name__nie (optional)
     * @param  string[] $name__niew (optional)
     * @param  string[] $name__nisw (optional)
     * @param  int $offset The initial index from which to return the results. (optional)
     * @param  string $ordering Which field to use when ordering the results. (optional)
     * @param  string[] $payload_url (optional)
     * @param  string $q Search (optional)
     * @param  string[] $secret (optional)
     * @param  bool $secret__empty (optional)
     * @param  string[] $secret__ic (optional)
     * @param  string[] $secret__ie (optional)
     * @param  string[] $secret__iew (optional)
     * @param  string[] $secret__isw (optional)
     * @param  string[] $secret__n (optional)
     * @param  string[] $secret__nic (optional)
     * @param  string[] $secret__nie (optional)
     * @param  string[] $secret__niew (optional)
     * @param  string[] $secret__nisw (optional)
     * @param  bool $ssl_verification (optional)
     * @param  string[] $tag (optional)
     * @param  string[] $tag__n (optional)
     * @param  string $updated_by_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasWebhooksListRequest($ca_file_path = null, $ca_file_path__empty = null, $ca_file_path__ic = null, $ca_file_path__ie = null, $ca_file_path__iew = null, $ca_file_path__isw = null, $ca_file_path__n = null, $ca_file_path__nic = null, $ca_file_path__nie = null, $ca_file_path__niew = null, $ca_file_path__nisw = null, $created = null, $created__empty = null, $created__gt = null, $created__gte = null, $created__lt = null, $created__lte = null, $created__n = null, $created_by_request = null, $description = null, $description__empty = null, $description__ic = null, $description__ie = null, $description__iew = null, $description__isw = null, $description__n = null, $description__nic = null, $description__nie = null, $description__niew = null, $description__nisw = null, $http_content_type = null, $http_content_type__empty = null, $http_content_type__ic = null, $http_content_type__ie = null, $http_content_type__iew = null, $http_content_type__isw = null, $http_content_type__n = null, $http_content_type__nic = null, $http_content_type__nie = null, $http_content_type__niew = null, $http_content_type__nisw = null, $http_method = null, $http_method__n = null, $id = null, $id__empty = null, $id__gt = null, $id__gte = null, $id__lt = null, $id__lte = null, $id__n = null, $last_updated = null, $last_updated__empty = null, $last_updated__gt = null, $last_updated__gte = null, $last_updated__lt = null, $last_updated__lte = null, $last_updated__n = null, $limit = null, $modified_by_request = null, $name = null, $name__empty = null, $name__ic = null, $name__ie = null, $name__iew = null, $name__isw = null, $name__n = null, $name__nic = null, $name__nie = null, $name__niew = null, $name__nisw = null, $offset = null, $ordering = null, $payload_url = null, $q = null, $secret = null, $secret__empty = null, $secret__ic = null, $secret__ie = null, $secret__iew = null, $secret__isw = null, $secret__n = null, $secret__nic = null, $secret__nie = null, $secret__niew = null, $secret__nisw = null, $ssl_verification = null, $tag = null, $tag__n = null, $updated_by_request = null, string $contentType = self::contentTypes['extrasWebhooksList'][0])
    {



























































































        $resourcePath = '/api/extras/webhooks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ca_file_path,
            'ca_file_path', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ca_file_path__empty,
            'ca_file_path__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ca_file_path__ic,
            'ca_file_path__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ca_file_path__ie,
            'ca_file_path__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ca_file_path__iew,
            'ca_file_path__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ca_file_path__isw,
            'ca_file_path__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ca_file_path__n,
            'ca_file_path__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ca_file_path__nic,
            'ca_file_path__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ca_file_path__nie,
            'ca_file_path__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ca_file_path__niew,
            'ca_file_path__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ca_file_path__nisw,
            'ca_file_path__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__empty,
            'created__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gt,
            'created__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__gte,
            'created__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lt,
            'created__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__lte,
            'created__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created__n,
            'created__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_by_request,
            'created_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__empty,
            'description__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ic,
            'description__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__ie,
            'description__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__iew,
            'description__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__isw,
            'description__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__n,
            'description__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nic,
            'description__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nie,
            'description__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__niew,
            'description__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description__nisw,
            'description__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_content_type,
            'http_content_type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_content_type__empty,
            'http_content_type__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_content_type__ic,
            'http_content_type__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_content_type__ie,
            'http_content_type__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_content_type__iew,
            'http_content_type__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_content_type__isw,
            'http_content_type__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_content_type__n,
            'http_content_type__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_content_type__nic,
            'http_content_type__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_content_type__nie,
            'http_content_type__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_content_type__niew,
            'http_content_type__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_content_type__nisw,
            'http_content_type__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_method,
            'http_method', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $http_method__n,
            'http_method__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__empty,
            'id__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gt,
            'id__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__gte,
            'id__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lt,
            'id__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__lte,
            'id__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id__n,
            'id__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated,
            'last_updated', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__empty,
            'last_updated__empty', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gt,
            'last_updated__gt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__gte,
            'last_updated__gte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lt,
            'last_updated__lt', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__lte,
            'last_updated__lte', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_updated__n,
            'last_updated__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_by_request,
            'modified_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__empty,
            'name__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ic,
            'name__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__ie,
            'name__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__iew,
            'name__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__isw,
            'name__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__n,
            'name__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nic,
            'name__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nie,
            'name__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__niew,
            'name__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name__nisw,
            'name__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payload_url,
            'payload_url', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secret,
            'secret', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secret__empty,
            'secret__empty', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secret__ic,
            'secret__ic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secret__ie,
            'secret__ie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secret__iew,
            'secret__iew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secret__isw,
            'secret__isw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secret__n,
            'secret__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secret__nic,
            'secret__nic', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secret__nie,
            'secret__nie', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secret__niew,
            'secret__niew', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secret__nisw,
            'secret__nisw', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssl_verification,
            'ssl_verification', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag__n,
            'tag__n', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_by_request,
            'updated_by_request', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasWebhooksPartialUpdate
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  \OpenAPI\Client\Model\PatchedWebhookRequest $patched_webhook_request patched_webhook_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Webhook
     */
    public function extrasWebhooksPartialUpdate($id, $patched_webhook_request = null, string $contentType = self::contentTypes['extrasWebhooksPartialUpdate'][0])
    {
        list($response) = $this->extrasWebhooksPartialUpdateWithHttpInfo($id, $patched_webhook_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasWebhooksPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  \OpenAPI\Client\Model\PatchedWebhookRequest $patched_webhook_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasWebhooksPartialUpdateWithHttpInfo($id, $patched_webhook_request = null, string $contentType = self::contentTypes['extrasWebhooksPartialUpdate'][0])
    {
        $request = $this->extrasWebhooksPartialUpdateRequest($id, $patched_webhook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Webhook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Webhook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Webhook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Webhook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasWebhooksPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  \OpenAPI\Client\Model\PatchedWebhookRequest $patched_webhook_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksPartialUpdateAsync($id, $patched_webhook_request = null, string $contentType = self::contentTypes['extrasWebhooksPartialUpdate'][0])
    {
        return $this->extrasWebhooksPartialUpdateAsyncWithHttpInfo($id, $patched_webhook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasWebhooksPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  \OpenAPI\Client\Model\PatchedWebhookRequest $patched_webhook_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksPartialUpdateAsyncWithHttpInfo($id, $patched_webhook_request = null, string $contentType = self::contentTypes['extrasWebhooksPartialUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Webhook';
        $request = $this->extrasWebhooksPartialUpdateRequest($id, $patched_webhook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasWebhooksPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  \OpenAPI\Client\Model\PatchedWebhookRequest $patched_webhook_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasWebhooksPartialUpdateRequest($id, $patched_webhook_request = null, string $contentType = self::contentTypes['extrasWebhooksPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasWebhooksPartialUpdate'
            );
        }



        $resourcePath = '/api/extras/webhooks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_webhook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_webhook_request));
            } else {
                $httpBody = $patched_webhook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasWebhooksRetrieve
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Webhook
     */
    public function extrasWebhooksRetrieve($id, string $contentType = self::contentTypes['extrasWebhooksRetrieve'][0])
    {
        list($response) = $this->extrasWebhooksRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation extrasWebhooksRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksRetrieve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasWebhooksRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['extrasWebhooksRetrieve'][0])
    {
        $request = $this->extrasWebhooksRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Webhook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Webhook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Webhook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Webhook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasWebhooksRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksRetrieveAsync($id, string $contentType = self::contentTypes['extrasWebhooksRetrieve'][0])
    {
        return $this->extrasWebhooksRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasWebhooksRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['extrasWebhooksRetrieve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Webhook';
        $request = $this->extrasWebhooksRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasWebhooksRetrieve'
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasWebhooksRetrieveRequest($id, string $contentType = self::contentTypes['extrasWebhooksRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasWebhooksRetrieve'
            );
        }


        $resourcePath = '/api/extras/webhooks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extrasWebhooksUpdate
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  \OpenAPI\Client\Model\WebhookRequest $webhook_request webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Webhook
     */
    public function extrasWebhooksUpdate($id, $webhook_request, string $contentType = self::contentTypes['extrasWebhooksUpdate'][0])
    {
        list($response) = $this->extrasWebhooksUpdateWithHttpInfo($id, $webhook_request, $contentType);
        return $response;
    }

    /**
     * Operation extrasWebhooksUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  \OpenAPI\Client\Model\WebhookRequest $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function extrasWebhooksUpdateWithHttpInfo($id, $webhook_request, string $contentType = self::contentTypes['extrasWebhooksUpdate'][0])
    {
        $request = $this->extrasWebhooksUpdateRequest($id, $webhook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Webhook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Webhook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Webhook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Webhook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extrasWebhooksUpdateAsync
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  \OpenAPI\Client\Model\WebhookRequest $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksUpdateAsync($id, $webhook_request, string $contentType = self::contentTypes['extrasWebhooksUpdate'][0])
    {
        return $this->extrasWebhooksUpdateAsyncWithHttpInfo($id, $webhook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extrasWebhooksUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  \OpenAPI\Client\Model\WebhookRequest $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extrasWebhooksUpdateAsyncWithHttpInfo($id, $webhook_request, string $contentType = self::contentTypes['extrasWebhooksUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Webhook';
        $request = $this->extrasWebhooksUpdateRequest($id, $webhook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extrasWebhooksUpdate'
     *
     * @param  int $id A unique integer value identifying this webhook. (required)
     * @param  \OpenAPI\Client\Model\WebhookRequest $webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extrasWebhooksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extrasWebhooksUpdateRequest($id, $webhook_request, string $contentType = self::contentTypes['extrasWebhooksUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling extrasWebhooksUpdate'
            );
        }

        // verify the required parameter 'webhook_request' is set
        if ($webhook_request === null || (is_array($webhook_request) && count($webhook_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_request when calling extrasWebhooksUpdate'
            );
        }


        $resourcePath = '/api/extras/webhooks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($webhook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhook_request));
            } else {
                $httpBody = $webhook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
